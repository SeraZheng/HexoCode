{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/3953273590_704e3899d5_m.jpg","path":"images/3953273590_704e3899d5_m.jpg","modified":0,"renderable":0},{"_id":"source/images/Mockplus.png","path":"images/Mockplus.png","modified":0,"renderable":0},{"_id":"source/images/SelectAll_Button.gif","path":"images/SelectAll_Button.gif","modified":0,"renderable":0},{"_id":"source/images/QuickLook.png","path":"images/QuickLook.png","modified":0,"renderable":0},{"_id":"source/images/SelectAll_CheckBox.png","path":"images/SelectAll_CheckBox.png","modified":0,"renderable":0},{"_id":"source/images/ZS.jpg","path":"images/ZS.jpg","modified":0,"renderable":0},{"_id":"source/images/abstract-1.jpg","path":"images/abstract-1.jpg","modified":0,"renderable":0},{"_id":"source/images/abstract-10.jpg","path":"images/abstract-10.jpg","modified":0,"renderable":0},{"_id":"source/images/abstract-3.jpg","path":"images/abstract-3.jpg","modified":0,"renderable":0},{"_id":"source/images/abstract-6.jpg","path":"images/abstract-6.jpg","modified":0,"renderable":0},{"_id":"source/images/abstract-5.jpg","path":"images/abstract-5.jpg","modified":0,"renderable":0},{"_id":"source/images/apple-touch-icon-114x114-precomposed.png","path":"images/apple-touch-icon-114x114-precomposed.png","modified":0,"renderable":0},{"_id":"source/images/apple-touch-icon-144x144-precomposed.png","path":"images/apple-touch-icon-144x144-precomposed.png","modified":0,"renderable":0},{"_id":"source/images/apple-touch-icon-72x72-precomposed.png","path":"images/apple-touch-icon-72x72-precomposed.png","modified":0,"renderable":0},{"_id":"source/images/apple-touch-icon-precomposed.png","path":"images/apple-touch-icon-precomposed.png","modified":0,"renderable":0},{"_id":"source/images/abstract-4.jpg","path":"images/abstract-4.jpg","modified":0,"renderable":0},{"_id":"source/images/abstract-7.jpg","path":"images/abstract-7.jpg","modified":0,"renderable":0},{"_id":"source/images/logo.jpg","path":"images/logo.jpg","modified":0,"renderable":0},{"_id":"source/images/ps_neutral.png","path":"images/ps_neutral.png","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/triangular.png","path":"images/triangular.png","modified":0,"renderable":0},{"_id":"source/images/abstract-8.jpg","path":"images/abstract-8.jpg","modified":0,"renderable":0},{"_id":"source/images/logo.png","path":"images/logo.png","modified":0,"renderable":0},{"_id":"source/images/witewall_3.png","path":"images/witewall_3.png","modified":0,"renderable":0},{"_id":"source/images/twitter-card-summary-large-image.jpg","path":"images/twitter-card-summary-large-image.jpg","modified":0,"renderable":0},{"_id":"source/images/在info中添加DocumentTypes.png","path":"images/在info中添加DocumentTypes.png","modified":0,"renderable":0},{"_id":"source/images/展示俩个Button.png","path":"images/展示俩个Button.png","modified":0,"renderable":0},{"_id":"source/images/展示UIActivityViewController.png","path":"images/展示UIActivityViewController.png","modified":0,"renderable":0},{"_id":"source/images/展示图标.png","path":"images/展示图标.png","modified":0,"renderable":0},{"_id":"source/images/显示Button.png","path":"images/显示Button.png","modified":0,"renderable":0},{"_id":"source/images/本人.jpg","path":"images/本人.jpg","modified":0,"renderable":0},{"_id":"source/images/鹰.jpg","path":"images/鹰.jpg","modified":0,"renderable":0},{"_id":"source/images/隐藏AirDrop.png","path":"images/隐藏AirDrop.png","modified":0,"renderable":0},{"_id":"source/images/自定义UIActivity.png","path":"images/自定义UIActivity.png","modified":0,"renderable":0},{"_id":"source/images/附加操作.png","path":"images/附加操作.png","modified":0,"renderable":0},{"_id":"source/images/Silent-Push-Notifications-in-iOS1.png","path":"images/Silent-Push-Notifications-in-iOS1.png","modified":0,"renderable":0},{"_id":"source/images/PDF看不到图标.png","path":"images/PDF看不到图标.png","modified":0,"renderable":0},{"_id":"source/images/abstract-2.jpg","path":"images/abstract-2.jpg","modified":0,"renderable":0},{"_id":"source/images/abstract-12.jpg","path":"images/abstract-12.jpg","modified":0,"renderable":0},{"_id":"source/images/abstract-11.jpg","path":"images/abstract-11.jpg","modified":0,"renderable":0},{"_id":"source/images/打开图片看到图标.png","path":"images/打开图片看到图标.png","modified":0,"renderable":0},{"_id":"source/images/注册成功.png","path":"images/注册成功.png","modified":0,"renderable":0},{"_id":"source/images/我的文件列表.png","path":"images/我的文件列表.png","modified":0,"renderable":0},{"_id":"source/images/直接预览.png","path":"images/直接预览.png","modified":0,"renderable":0},{"_id":"source/images/Three20.png","path":"images/Three20.png","modified":0,"renderable":0},{"_id":"source/images/Alcatraz.png","path":"images/Alcatraz.png","modified":0,"renderable":0},{"_id":"source/images/Three20_Advance.png","path":"images/Three20_Advance.png","modified":0,"renderable":0},{"_id":"source/images/显示图片.png","path":"images/显示图片.png","modified":0,"renderable":0},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/jacman.png","path":"img/jacman.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/ZS.png","path":"img/ZS.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":0,"renderable":1},{"_id":"source/images/Animation_Title.gif","path":"images/Animation_Title.gif","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"2e438b759a319eb49a135b2acedfa044c9e259be","modified":1460368883000},{"_id":"themes/jacman/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1460347537000},{"_id":"themes/jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1460347537000},{"_id":"themes/jacman/_config.yml","hash":"3c89fbe82a8a7cb37957c92f1a4b842433cae0af","modified":1460358591000},{"_id":"themes/jacman/README.md","hash":"563fd972b298b6b00540b34c4cfe9485084ea8d5","modified":1460347537000},{"_id":"themes/jacman/README_zh.md","hash":"0854e4c96f53005f3a47e21af3f8aee361719ce4","modified":1460347537000},{"_id":"themes/jacman/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1460347672000},{"_id":"source/_posts/\"Select All\"功能的设计.md","hash":"76e5c4a8d8b5f4f7fe42e51da9143f8c83bfc6c2","modified":1460443830000},{"_id":"source/_posts/Apple推送通知(一)原理.md","hash":"debca141c33904010e62bdfa58450ed991427907","modified":1460443406000},{"_id":"source/_posts/.DS_Store","hash":"692b5f1a8bfc829838f068f96c8d0c40703665c0","modified":1460445319000},{"_id":"source/_posts/Apple推送通知(三)开发.md","hash":"9beb3de9db8b368f276afb5155690345ba30e6a2","modified":1460443464000},{"_id":"source/_posts/Apple推送通知(二)准备.md","hash":"58a7f3abdf884ee5a7147e114a0ef19f3b565e43","modified":1460443434000},{"_id":"source/_posts/NSObject的load和initialize方法.md","hash":"071e9df86dbd8f6fe44b0e65d680c856098ff213","modified":1460443790000},{"_id":"source/_posts/Apple推送通知(四)silent APNS.md","hash":"eef963ae4367decabb2e21c0fbc17516357f2326","modified":1460443518000},{"_id":"source/_posts/UIResponder中的inputView与inputAccessoryView.md","hash":"d2732ece9075f14346c0612fb51b6bd83d121be6","modified":1460443750000},{"_id":"source/_posts/iOS 8使用UIAlertController.md","hash":"adc5302a13dae8cc76cf08a8163814ce6a1dd415","modified":1460443771000},{"_id":"source/_posts/UIViewController解耦---浅析Three20架构.md","hash":"5a6ed9a46555713f12a53281457962c1238a89da","modified":1460444025000},{"_id":"source/_posts/ZSNavigationFilterMenuView动画解析 --- 基于navigationBar的titleView创造.md","hash":"facb967a52e9cc2cd8161f741f72f89ccbb7728b","modified":1460443898000},{"_id":"source/_posts/iOS多线程开发（一）多线程基础.md","hash":"2c3988754c1f2e5afceab6135e780eb1d3e3c41a","modified":1460443593000},{"_id":"source/_posts/iOS多线程开发（五）GCD.md","hash":"9627332701b62f2a5ae12a4f2be4fe37a45b377a","modified":1460443684000},{"_id":"source/_posts/iOS多线程开发（三）线程安全.md","hash":"53d91b6e11b0d79c73252ebb4ab03851812e3ff6","modified":1460443636000},{"_id":"source/_posts/iOS多线程开发（二）使用NSThread.md","hash":"d07b283faaaf47229bcf61c4d7e2efa1b5739563","modified":1460443616000},{"_id":"source/_posts/iOS多线程开发（四）NSOperation和NSOperationQueue.md","hash":"4e18b1c9dec37b4cb19c30e38b2b48823007ba16","modified":1460443662000},{"_id":"source/_posts/iOS实现App之间的内容分享.md","hash":"6269322d5737b38f7dadb451ff79fd749568889d","modified":1460443936000},{"_id":"source/_posts/使用Mockplus设计产品原型.md","hash":"3e1b04ac05089855d2a1da3c934ef608fe70fd7f","modified":1460443810000},{"_id":"source/_posts/使用谓词(NSPredicate)来提高集合遍历与过滤查找的效率.md","hash":"4d7d3cfdef2d7a7a6e98d2cb17d2e783a3e95c60","modified":1460443849000},{"_id":"source/_posts/使用KVC自定义UISearchBar外观.md","hash":"b7e46a9e93287c27e4c513b9fc573c0e75b07e71","modified":1460443870000},{"_id":"source/_posts/使用注释提高iOS开发效率.md","hash":"97a7751cb8f63f74a0168b51f481bd2386d20585","modified":1460443539000},{"_id":"source/_posts/内存管理之属性参数与变量关键字.md","hash":"06f9d63b3f2c5ef5130dc530130ff997fbbd74fe","modified":1460443732000},{"_id":"source/_posts/扒一扒TestFlight的那些事.md","hash":"36a5d4742dc816806341fc89433b2fa8938c2f2b","modified":1460443381000},{"_id":"source/_posts/末班车上一个程序猿的年度总结.md","hash":"6d6cd31b6c937313df6645d9f2d7df45a923648a","modified":1460443996000},{"_id":"source/_posts/我的第一篇博客.md","hash":"fafa96cd05e160be79e8f5771278146510470e8d","modified":1460443319000},{"_id":"source/_posts/浅谈一次练手：GitHub和CocoaPods.md","hash":"9f1a10cf4fd387cad6c32a56b8e7c0c0c9e5b851","modified":1460443356000},{"_id":"source/_posts/自动注释VVDocumenter-Xcode和插件管理Alcatraz.md","hash":"847067dc062b7e7414beedf0a2d0c503d380a5e9","modified":1460443569000},{"_id":"source/_posts/通过UIActivityViewController实现更多分享服务.md","hash":"26c4935b0e84c147147c9d1c401505b0de56ddb0","modified":1460443973000},{"_id":"source/_posts/详解苹果提供的UTI(统一类型标识符).md","hash":"61c432c767898ec62f888bfc624bbef930a72aed","modified":1460443918000},{"_id":"source/_posts/通过UIDocumentInteractionController预览和分享.md","hash":"7bdf555c39ca9bde4ab8ca163bc3fc2a1695f27d","modified":1460444789000},{"_id":"source/_posts/重写prepareForReuse来重用UITableViewCell.md","hash":"ce667be6cb6e80dd4ec902aff9d840f68bce27b5","modified":1460443710000},{"_id":"source/about/index.md","hash":"ac1915a58e64a686d3231be72e8c0ac261e37ed3","modified":1460443072000},{"_id":"source/categories/index.md","hash":"0502d74d0c62add87541cc327aea9c78ca911c3e","modified":1460357300000},{"_id":"source/images/3953273590_704e3899d5_m.jpg","hash":"50258aa007b4a30d3e49c8d52ffb2fe78a0a47ff","modified":1458539764000},{"_id":"source/images/Mockplus.png","hash":"269eb0e91a8b697c9ef5ca2966236d901d4f9b68","modified":1458539764000},{"_id":"source/images/SelectAll_Button.gif","hash":"9c35816d91716c7bd5301c2d5c28eaf5071bcc21","modified":1458539764000},{"_id":"source/images/QuickLook.png","hash":"364266eebd6939c05a7949984f382b358d9bb163","modified":1458539764000},{"_id":"source/images/SelectAll_CheckBox.png","hash":"a7daef84101d4c454b8dba7e77c42f553041961f","modified":1458539764000},{"_id":"source/images/ZS.jpg","hash":"114182e4a343a9b69c6dd7d5a6434bf633ce4951","modified":1458539764000},{"_id":"source/images/abstract-1.jpg","hash":"d0715ea88f6d2b141fc61a26ebdc2bdae5e22daf","modified":1458539764000},{"_id":"source/images/abstract-10.jpg","hash":"a28c4d5b2d376a27b6cb110618ed5f5015db8b88","modified":1458539764000},{"_id":"source/images/abstract-3.jpg","hash":"f9cfd59619122ce6abd3c16773e2b94dd30e8a14","modified":1458539764000},{"_id":"source/images/abstract-6.jpg","hash":"5ed0c433cbbfa810f85fe44bac49a01abd722cba","modified":1458539764000},{"_id":"source/images/abstract-5.jpg","hash":"59e43d16c6c0e78a570b1c048a7e1ee6b2a66809","modified":1458539764000},{"_id":"source/images/apple-touch-icon-114x114-precomposed.png","hash":"6e2c0d534c20454c39007de22218de1bc00d1878","modified":1458539764000},{"_id":"source/images/apple-touch-icon-144x144-precomposed.png","hash":"0c98747abf27c7bf16c4ad9e6b006f692e770f1b","modified":1458539764000},{"_id":"source/images/apple-touch-icon-72x72-precomposed.png","hash":"4ff40f82de38b981e0a53c44b1207a2611ade4ae","modified":1458539764000},{"_id":"source/images/apple-touch-icon-precomposed.png","hash":"46910e121575121459e32b7df14ee1e2867c8a22","modified":1458539764000},{"_id":"source/images/abstract-4.jpg","hash":"ec72f4266c0b8b26c54acd3cf0592ffbd2b0cd83","modified":1458539764000},{"_id":"source/images/abstract-7.jpg","hash":"461d49385ff51918bc8f951a64c4811a31a77170","modified":1458539764000},{"_id":"source/images/logo.jpg","hash":"7c366bf6e137a4e1739571fb9589b57b742ce137","modified":1458539764000},{"_id":"source/images/ps_neutral.png","hash":"a62481b2e72e47998037546955888b7aa7332f62","modified":1458539764000},{"_id":"source/images/avatar.jpg","hash":"05774d6f52b114e54366b89ed1d86f1d8c3d5ddd","modified":1458539764000},{"_id":"source/images/triangular.png","hash":"bcb6d02ccbe45dece0f2153b99c33518a71666e4","modified":1458539764000},{"_id":"source/images/abstract-8.jpg","hash":"5927dc5eff774995feca29cbe2ab0a3c53f22130","modified":1458539764000},{"_id":"source/images/logo.png","hash":"f3b39964be627f84610c8dd085a53fe9451d1a4d","modified":1458539764000},{"_id":"source/images/witewall_3.png","hash":"0b93c5f29c37baa67d8561e8d66cc784c6bd51f6","modified":1458539764000},{"_id":"source/images/twitter-card-summary-large-image.jpg","hash":"cb7455a04bcf92f2de66e14a8c2ab913b62c74b5","modified":1458539764000},{"_id":"source/images/在info中添加DocumentTypes.png","hash":"64895983aeb322428fec4b487aa9147757690c7d","modified":1458539764000},{"_id":"source/images/展示俩个Button.png","hash":"e6e432822a965c2c4479b0ddbb2a8da268c721e7","modified":1458539764000},{"_id":"source/images/展示UIActivityViewController.png","hash":"dd98a38991fc95aac2239048171fff13a448c6cd","modified":1458539764000},{"_id":"source/images/展示图标.png","hash":"591ebbe5f2f2290db504e4c42c342c5a3f7cac13","modified":1458539764000},{"_id":"source/images/显示Button.png","hash":"e6d919605f88b58b4cbf89c62a903f8c1a0d37d2","modified":1458539764000},{"_id":"source/images/本人.jpg","hash":"a745f7eb05e619c0dff761516a5c09e822b63f98","modified":1458539764000},{"_id":"source/images/鹰.jpg","hash":"12c7d0d6a6f092a06293e01c2ade3121283ae0e6","modified":1458539764000},{"_id":"source/images/隐藏AirDrop.png","hash":"32ad9a56166f798a146257e7e2c1a5369360fa5d","modified":1458539764000},{"_id":"source/images/自定义UIActivity.png","hash":"d18145c0ce57fbce68d6267ac9a9b05389974474","modified":1458539764000},{"_id":"themes/jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1460347537000},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1460347537000},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1460347537000},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1460347537000},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1460347537000},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1460347537000},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1460347537000},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1460347537000},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1460347537000},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1460347537000},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1460347537000},{"_id":"source/tags/index.md","hash":"28fb0a222db2f8626e7581d6bf007079a4525cb6","modified":1460357273000},{"_id":"source/images/附加操作.png","hash":"f957a48448a34dd7ceeb4f91168290ba3d5f028c","modified":1458539764000},{"_id":"source/images/Silent-Push-Notifications-in-iOS1.png","hash":"ec82608d692f67b5014c9a3e449ebe12faf3dfb5","modified":1458539764000},{"_id":"source/images/PDF看不到图标.png","hash":"de9b666380702eb917f1c10a634eabf4c1751c1c","modified":1458539764000},{"_id":"source/images/abstract-2.jpg","hash":"8c427ec200839e10e871857fbc485cf8a0f89783","modified":1458539764000},{"_id":"source/images/abstract-12.jpg","hash":"1909308a3be803cb2a8884fee01544c374e0f671","modified":1458539764000},{"_id":"source/images/abstract-11.jpg","hash":"5530006198c8661d073c2abe6450c5281f2c1f9b","modified":1458539764000},{"_id":"source/images/打开图片看到图标.png","hash":"ef7d16851e6af9ffedb6f6891b7242ac7c21042b","modified":1458539764000},{"_id":"source/images/注册成功.png","hash":"b21953101c8bfd9aa6a90ad879a07ba9b6d8f631","modified":1458539764000},{"_id":"source/images/我的文件列表.png","hash":"b0d013cac38ec98cb0a00acfe2eca6a8930b4ceb","modified":1458539764000},{"_id":"source/images/直接预览.png","hash":"6e0b41ecb72c17ef4e47a4b8a447924b618114f6","modified":1458539764000},{"_id":"source/images/Three20.png","hash":"62137e205eee70113fe35f781d45a1a6b51d8071","modified":1458539764000},{"_id":"source/images/Alcatraz.png","hash":"4c2019baa182ef00e9f9a120d1f76af6056663b6","modified":1458539764000},{"_id":"source/images/Three20_Advance.png","hash":"2be5f95606733f6cbdbc759544c74bf2415e86ae","modified":1458539764000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"c703b0c25139b8a5f8f9d24a334a07905e2b7987","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"5f80bf6c6ddcf8c28c4599cd1540b14b25d54f18","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1460347537000},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1460347537000},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1460347537000},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1460347537000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1460347537000},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1460347537000},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1460347537000},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1460347537000},{"_id":"source/images/显示图片.png","hash":"87f9db8bf6fb2e04ce189b8b136d44e1028bb5ba","modified":1458539764000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1460347537000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1460347537000},{"_id":"themes/jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1460347537000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1460347537000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1460347537000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1460347537000},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1460347537000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1460347537000},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1460347537000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1460347537000},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1460347537000},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1460347537000},{"_id":"themes/jacman/source/img/.DS_Store","hash":"97acf91433c5b7c8ff5b64ac285766f4080edcf4","modified":1460356006000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1460347537000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1460347537000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1460347537000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1460347537000},{"_id":"themes/jacman/source/img/favicon.ico","hash":"60cfeac84391b878c7a7852435a5c8d0c8511e02","modified":1460355818000},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1460347537000},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1460347537000},{"_id":"themes/jacman/source/img/jacman.png","hash":"389b89d2fb4daae9a1d98c6255e51330cb61b9a5","modified":1460356049000},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1460347537000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1460347537000},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1460347537000},{"_id":"themes/jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1460347537000},{"_id":"themes/jacman/source/img/logo.png","hash":"db7b1bbc5db0b983ae78b1a6c0b6c8a9d320266e","modified":1460348051000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1460347537000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1460347537000},{"_id":"themes/jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1460347537000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1460347537000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1460347537000},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1460347537000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1460440110000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1460347537000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1460347537000},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1460347537000},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1460347537000},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1460347537000},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1460347537000},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1460347537000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1460347537000},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1460347537000},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1460347537000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1460347537000},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1460347537000},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1460347537000},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1460347537000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1460347537000},{"_id":"themes/jacman/source/img/ZS.png","hash":"f3c5e91eed4d72389b90da0975ed1ed8142120be","modified":1460355985000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1460347537000},{"_id":"themes/jacman/source/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1460347537000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1460347537000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1460347537000},{"_id":"source/images/Animation_Title.gif","hash":"97106d459f871ac314e148efaa2bd2c6c2018b01","modified":1458539764000},{"_id":"public/categories/index.html","hash":"26c697f9ac2b8cd1a4ffd270c8ddeceedb421370","modified":1460447740922},{"_id":"public/tags/index.html","hash":"175df823ddbc927022858a6f3ecb906ba889b6be","modified":1460447740923},{"_id":"public/archives/index.html","hash":"e448176e90efd78ec42bc0a49e3b272ccf37d8d6","modified":1460447740923},{"_id":"public/archives/page/2/index.html","hash":"26f1b0c829e1ff867fc7c51815e35e3877fcf9f1","modified":1460447740924},{"_id":"public/archives/page/3/index.html","hash":"bd73817d09515f6481d4a05dd10323e62cfd6c99","modified":1460447740924},{"_id":"public/archives/2015/index.html","hash":"ab02165fd7895d0fa58b47b989f31d5e42a96125","modified":1460447740924},{"_id":"public/archives/2015/page/2/index.html","hash":"13ed670ee9220b1dfc0c6a86873b0b296fef2af2","modified":1460447740924},{"_id":"public/archives/2015/page/3/index.html","hash":"71c31f13b04ba90360092a7c908f2fda09a259e6","modified":1460447740924},{"_id":"public/archives/2015/07/index.html","hash":"c66a5e74d82c36138c1b361d3da15a5a02ab3863","modified":1460447740924},{"_id":"public/archives/2015/08/index.html","hash":"f46ece22171985cb9788298593b7e4727c81916a","modified":1460447740924},{"_id":"public/archives/2015/09/index.html","hash":"3e08627cac528a86fa123a7d3db3e449a7570b51","modified":1460447740924},{"_id":"public/archives/2015/10/index.html","hash":"d731d755e797cbf04256eca29b5f2e3a19f0254d","modified":1460447740924},{"_id":"public/archives/2015/11/index.html","hash":"b4e5c2efb0911c54458787de386f6033e2415c36","modified":1460447740924},{"_id":"public/archives/2015/12/index.html","hash":"9aeaf4761d6254c34de3d933bb25144929a63c19","modified":1460447740924},{"_id":"public/archives/2016/index.html","hash":"3ad650cc115bbc4aa5b6067056a103eb22965e66","modified":1460447740924},{"_id":"public/archives/2016/01/index.html","hash":"196a50af050c9b4e7754463bfc22b12de5e1c18d","modified":1460447740924},{"_id":"public/source/categories/设计/index.html","hash":"686d13d47b35d8b02f7ec5ebdbd47ec8baf90ee6","modified":1460447740924},{"_id":"public/source/categories/iOS/index.html","hash":"1c13b518712d09b0a456fc73650bb9151b53d059","modified":1460447740924},{"_id":"public/source/categories/iOS/page/2/index.html","hash":"cb62236738f67f5b9a9388f88da84ba02555ea28","modified":1460447740924},{"_id":"public/source/categories/Objective-C/index.html","hash":"72ec6a5b2cc3abc510754143dfcb34acf7998365","modified":1460447740925},{"_id":"public/source/categories/开发心得/index.html","hash":"1f5a14e2848319da3e86ff814a1f8756535a9655","modified":1460447740925},{"_id":"public/source/categories/多线程/index.html","hash":"9854a7490bc65ba7ac9132b125ccd47687763824","modified":1460447740925},{"_id":"public/source/categories/Xcode/index.html","hash":"753797f0af3e3979118c311a8b5024a8cb0eef9a","modified":1460447740925},{"_id":"public/source/tags/设计/index.html","hash":"6f62b62fa7e5694b682f6bf05290a328e5f70e3d","modified":1460447740925},{"_id":"public/source/tags/APNS/index.html","hash":"0f0e1c6d7eb04dbbcf4b464e97ad3adceaf43f0e","modified":1460447740925},{"_id":"public/source/tags/OC基础/index.html","hash":"167ff86e5fab96d59de9824bb5e22287ba72cdeb","modified":1460447740925},{"_id":"public/source/tags/UIKit/index.html","hash":"d639d714a29da97b6bddf2393b7923914307ce56","modified":1460447740925},{"_id":"public/source/tags/架构/index.html","hash":"5fa7cf9d00a7c38fa6f7f85b21042ef84bd8be21","modified":1460447740925},{"_id":"public/source/tags/CoreAnimation/index.html","hash":"f7bfd4be70a74ae2b4ae86209c54851df0a2b81f","modified":1460447740925},{"_id":"public/source/tags/多线程/index.html","hash":"88d3e10c5ddd3da192b87097cca3daf881aa86e3","modified":1460447740925},{"_id":"public/source/tags/UTI/index.html","hash":"a926d2f9606bb0d0b2fc8ffb116cdde0a414e929","modified":1460447740925},{"_id":"public/source/tags/注释/index.html","hash":"feae14f2fd2a64d033baa9d8081d422cf376aed4","modified":1460447740925},{"_id":"public/source/tags/内存管理/index.html","hash":"b1c6c4076e5bab82a2fcafbc774bb1bfdf6d33b9","modified":1460447740925},{"_id":"public/source/tags/TestFlight/index.html","hash":"474b4f6792ce39363ba7188d455add2cfd818e13","modified":1460447740925},{"_id":"public/source/tags/年度总结/index.html","hash":"9af35941c3631023070c0e9809afafc6af3885af","modified":1460447740925},{"_id":"public/source/tags/开篇博客/index.html","hash":"5a0c5b1458226099123d1a67b8219a723e6608e0","modified":1460447740927},{"_id":"public/source/tags/GitHub开源/index.html","hash":"f737adea9d1f83aa1a0e43c13bf1608da8fe0b3d","modified":1460447740927},{"_id":"public/about/index.html","hash":"36d72deeabe2081c2bf82e305982ef78375e9b1c","modified":1460447740927},{"_id":"public/2016-01-13-UIViewController解耦---浅析Three20架构/index.html","hash":"f4de9179f5dd215d4b13ab313110b7fe50d492fc","modified":1460447740927},{"_id":"public/2015-12-15-通过UIActivityViewController实现更多分享服务/index.html","hash":"302464f8d6cc9db01d60da51a2cac4d6a53b6244","modified":1460447740927},{"_id":"public/2015-12-31-末班车上一个程序猿的年度总结/index.html","hash":"67feec419799b78bfe9bedf45cc44d77bb6b71ea","modified":1460447740927},{"_id":"public/2015-12-05-通过UIDocumentInteractionController预览和分享/index.html","hash":"82b472e37abaf9b7771fd51392c8eca885103cd7","modified":1460447740927},{"_id":"public/2015-11-20-详解苹果提供的UTI(统一类型标识符)/index.html","hash":"e125e744185ef641b26aa07443334760a60f62ed","modified":1460447740927},{"_id":"public/2015-11-25-iOS实现App之间的内容分享/index.html","hash":"29f50d6fed3c2e968ca90277ed62233249a75357","modified":1460447740927},{"_id":"public/2015-11-05-ZSNavigationFilterMenuView动画解析 --- 基于navigationBar的titleView创造/index.html","hash":"6d051603f96fd528e282ae84a911b5e83feefe9a","modified":1460447740927},{"_id":"public/2015-10-25-使用KVC自定义UISearchBar外观/index.html","hash":"d2544c3d213a74bc7756f4e5e76d87f7657d2f16","modified":1460447740928},{"_id":"public/2015-10-12-使用谓词(NSPredicate)来提高集合遍历与过滤查找的效率/index.html","hash":"7a9dd6b5904babed6c9c9f54878ce4da922aa7c5","modified":1460447740928},{"_id":"public/2015-09-27-\"Select All\"功能的设计/index.html","hash":"e3b0c85756108d1637bab6885e1e6b511a1c9416","modified":1460447740928},{"_id":"public/2015-09-06-NSObject的load和initialize方法/index.html","hash":"3891260ee92d4cfd22874174135ffedb44d461f7","modified":1460447740928},{"_id":"public/2015-09-18-使用Mockplus设计产品原型/index.html","hash":"6aa38e430817be794d68ee82b52412c047b42744","modified":1460447740928},{"_id":"public/2015-08-28-iOS 8使用UIAlertController/index.html","hash":"e118e6218c562271136cd401a34f58bcf5721ad3","modified":1460447740928},{"_id":"public/2015-08-22-UIResponder中的inputView与inputAccessoryView/index.html","hash":"b635ba1405984721083e9e7e86c07fbfdd40b463","modified":1460447740928},{"_id":"public/2015-08-20-内存管理之属性参数与变量关键字/index.html","hash":"ca938a0d83b4db51d25313cdc382dd9fc1a8a4d6","modified":1460447740929},{"_id":"public/2015-08-15-重写prepareForReuse来重用UITableViewCell/index.html","hash":"ebefdb4d853c7364f93ab1643b92645c5b37c25e","modified":1460447740929},{"_id":"public/2015-08-05-iOS多线程开发（五）GCD/index.html","hash":"1027062d081e1f4a7506544c856d67aebffa7a3d","modified":1460447740929},{"_id":"public/2015-08-04-iOS多线程开发（四）NSOperation和NSOperationQueue/index.html","hash":"8ae8e6463bfd043d5658828fe42b6c2a0c3e5aac","modified":1460447740929},{"_id":"public/2015-08-03-iOS多线程开发（三）线程安全/index.html","hash":"eb8c468eb4311a92572a77caa5e7d361fb4616a7","modified":1460447740929},{"_id":"public/2015-08-02-iOS多线程开发（二）使用NSThread/index.html","hash":"6b8be4974188de3180febec61868c222087c9e21","modified":1460447740929},{"_id":"public/2015-08-01-iOS多线程开发（一）多线程基础/index.html","hash":"268bd58a9e5013c9607e6e08bfc8281d1cb7d6b8","modified":1460447740929},{"_id":"public/2015-07-26-自动注释VVDocumenter-Xcode和插件管理Alcatraz/index.html","hash":"9ceff894350c331bf93015311c26f2254408e8cb","modified":1460447740929},{"_id":"public/2015-07-25-使用注释提高iOS开发效率/index.html","hash":"c4d4bfec95b8d7d1ba15d07916b7c8c263345fd5","modified":1460447740929},{"_id":"public/2015-07-15-Apple推送通知(四)silent APNS/index.html","hash":"b101b8c4860d201457b38054ed8323dc08ec93a3","modified":1460447740929},{"_id":"public/2015-07-14-Apple推送通知(三)开发/index.html","hash":"a732f7de1154de82d6b0ae4104eb5e8284453b28","modified":1460447740929},{"_id":"public/2015-07-13-Apple推送通知(二)准备/index.html","hash":"ccf8a16155e696695b4ad4a7452a0777c9581edc","modified":1460447740929},{"_id":"public/2015-07-12-Apple推送通知(一)原理/index.html","hash":"f3360958f8d98ad40a93659cc42517aedd44e078","modified":1460447740929},{"_id":"public/2015-07-08-扒一扒TestFlight的那些事/index.html","hash":"8b25ce65649fe5a91a980791ad2d02151568d72d","modified":1460447740929},{"_id":"public/2015-07-05-浅谈一次练手：GitHub和CocoaPods/index.html","hash":"15ece07d0ead268766d804b72a86958762fe2315","modified":1460447740929},{"_id":"public/2015-07-02-我的第一篇博客/index.html","hash":"8dc44598f068ecd1b62c4f1aa860280268ed0339","modified":1460447740929},{"_id":"public/index.html","hash":"f1759a663fbe46727057f72e92cd310b004ed58c","modified":1460447740929},{"_id":"public/page/2/index.html","hash":"478c7014c96f1436d7fc2573c1060748a52d375d","modified":1460447740929},{"_id":"public/page/3/index.html","hash":"87e7280ceeec890ca7616bb65d72966159253a61","modified":1460447740930},{"_id":"public/images/3953273590_704e3899d5_m.jpg","hash":"50258aa007b4a30d3e49c8d52ffb2fe78a0a47ff","modified":1460447740944},{"_id":"public/images/SelectAll_Button.gif","hash":"9c35816d91716c7bd5301c2d5c28eaf5071bcc21","modified":1460447740944},{"_id":"public/images/Mockplus.png","hash":"269eb0e91a8b697c9ef5ca2966236d901d4f9b68","modified":1460447740944},{"_id":"public/images/QuickLook.png","hash":"364266eebd6939c05a7949984f382b358d9bb163","modified":1460447740944},{"_id":"public/images/SelectAll_CheckBox.png","hash":"a7daef84101d4c454b8dba7e77c42f553041961f","modified":1460447740944},{"_id":"public/images/ZS.jpg","hash":"114182e4a343a9b69c6dd7d5a6434bf633ce4951","modified":1460447740944},{"_id":"public/images/abstract-1.jpg","hash":"d0715ea88f6d2b141fc61a26ebdc2bdae5e22daf","modified":1460447740944},{"_id":"public/images/abstract-10.jpg","hash":"a28c4d5b2d376a27b6cb110618ed5f5015db8b88","modified":1460447740944},{"_id":"public/images/abstract-3.jpg","hash":"f9cfd59619122ce6abd3c16773e2b94dd30e8a14","modified":1460447740944},{"_id":"public/images/abstract-6.jpg","hash":"5ed0c433cbbfa810f85fe44bac49a01abd722cba","modified":1460447740944},{"_id":"public/images/abstract-5.jpg","hash":"59e43d16c6c0e78a570b1c048a7e1ee6b2a66809","modified":1460447740945},{"_id":"public/images/apple-touch-icon-114x114-precomposed.png","hash":"6e2c0d534c20454c39007de22218de1bc00d1878","modified":1460447740945},{"_id":"public/images/apple-touch-icon-144x144-precomposed.png","hash":"0c98747abf27c7bf16c4ad9e6b006f692e770f1b","modified":1460447740945},{"_id":"public/images/apple-touch-icon-72x72-precomposed.png","hash":"4ff40f82de38b981e0a53c44b1207a2611ade4ae","modified":1460447740945},{"_id":"public/images/apple-touch-icon-precomposed.png","hash":"46910e121575121459e32b7df14ee1e2867c8a22","modified":1460447740945},{"_id":"public/images/logo.jpg","hash":"7c366bf6e137a4e1739571fb9589b57b742ce137","modified":1460447740945},{"_id":"public/images/abstract-4.jpg","hash":"ec72f4266c0b8b26c54acd3cf0592ffbd2b0cd83","modified":1460447740945},{"_id":"public/images/ps_neutral.png","hash":"a62481b2e72e47998037546955888b7aa7332f62","modified":1460447740945},{"_id":"public/images/abstract-7.jpg","hash":"461d49385ff51918bc8f951a64c4811a31a77170","modified":1460447740945},{"_id":"public/images/avatar.jpg","hash":"05774d6f52b114e54366b89ed1d86f1d8c3d5ddd","modified":1460447740945},{"_id":"public/images/triangular.png","hash":"bcb6d02ccbe45dece0f2153b99c33518a71666e4","modified":1460447740945},{"_id":"public/images/logo.png","hash":"f3b39964be627f84610c8dd085a53fe9451d1a4d","modified":1460447740945},{"_id":"public/images/witewall_3.png","hash":"0b93c5f29c37baa67d8561e8d66cc784c6bd51f6","modified":1460447740945},{"_id":"public/images/abstract-8.jpg","hash":"5927dc5eff774995feca29cbe2ab0a3c53f22130","modified":1460447740945},{"_id":"public/images/twitter-card-summary-large-image.jpg","hash":"cb7455a04bcf92f2de66e14a8c2ab913b62c74b5","modified":1460447740945},{"_id":"public/images/在info中添加DocumentTypes.png","hash":"64895983aeb322428fec4b487aa9147757690c7d","modified":1460447740945},{"_id":"public/images/展示俩个Button.png","hash":"e6e432822a965c2c4479b0ddbb2a8da268c721e7","modified":1460447740945},{"_id":"public/images/展示图标.png","hash":"591ebbe5f2f2290db504e4c42c342c5a3f7cac13","modified":1460447740945},{"_id":"public/images/展示UIActivityViewController.png","hash":"dd98a38991fc95aac2239048171fff13a448c6cd","modified":1460447740945},{"_id":"public/images/显示Button.png","hash":"e6d919605f88b58b4cbf89c62a903f8c1a0d37d2","modified":1460447740946},{"_id":"public/images/本人.jpg","hash":"a745f7eb05e619c0dff761516a5c09e822b63f98","modified":1460447740946},{"_id":"public/images/鹰.jpg","hash":"12c7d0d6a6f092a06293e01c2ade3121283ae0e6","modified":1460447740946},{"_id":"public/images/自定义UIActivity.png","hash":"d18145c0ce57fbce68d6267ac9a9b05389974474","modified":1460447740946},{"_id":"public/images/隐藏AirDrop.png","hash":"32ad9a56166f798a146257e7e2c1a5369360fa5d","modified":1460447740946},{"_id":"public/images/附加操作.png","hash":"f957a48448a34dd7ceeb4f91168290ba3d5f028c","modified":1460447740946},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1460447740946},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1460447740946},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1460447740946},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1460447740946},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1460447740946},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1460447740946},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1460447740946},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1460447740946},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1460447740946},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1460447740946},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1460447740946},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1460447740947},{"_id":"public/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1460447740947},{"_id":"public/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1460447740947},{"_id":"public/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1460447740947},{"_id":"public/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1460447740947},{"_id":"public/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1460447740947},{"_id":"public/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1460447740947},{"_id":"public/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1460447740947},{"_id":"public/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1460447740947},{"_id":"public/img/favicon.ico","hash":"60cfeac84391b878c7a7852435a5c8d0c8511e02","modified":1460447740947},{"_id":"public/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1460447740947},{"_id":"public/img/jacman.png","hash":"389b89d2fb4daae9a1d98c6255e51330cb61b9a5","modified":1460447740947},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1460447740947},{"_id":"public/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1460447740947},{"_id":"public/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1460447740947},{"_id":"public/img/logo.png","hash":"db7b1bbc5db0b983ae78b1a6c0b6c8a9d320266e","modified":1460447740947},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1460447740948},{"_id":"public/images/Silent-Push-Notifications-in-iOS1.png","hash":"ec82608d692f67b5014c9a3e449ebe12faf3dfb5","modified":1460447741693},{"_id":"public/images/PDF看不到图标.png","hash":"de9b666380702eb917f1c10a634eabf4c1751c1c","modified":1460447741694},{"_id":"public/images/abstract-2.jpg","hash":"8c427ec200839e10e871857fbc485cf8a0f89783","modified":1460447741697},{"_id":"public/images/abstract-12.jpg","hash":"1909308a3be803cb2a8884fee01544c374e0f671","modified":1460447741697},{"_id":"public/images/abstract-11.jpg","hash":"5530006198c8661d073c2abe6450c5281f2c1f9b","modified":1460447741697},{"_id":"public/images/打开图片看到图标.png","hash":"ef7d16851e6af9ffedb6f6891b7242ac7c21042b","modified":1460447741697},{"_id":"public/images/注册成功.png","hash":"b21953101c8bfd9aa6a90ad879a07ba9b6d8f631","modified":1460447741698},{"_id":"public/images/我的文件列表.png","hash":"b0d013cac38ec98cb0a00acfe2eca6a8930b4ceb","modified":1460447741698},{"_id":"public/images/直接预览.png","hash":"6e0b41ecb72c17ef4e47a4b8a447924b618114f6","modified":1460447741698},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1460447741698},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1460447741698},{"_id":"public/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1460447741698},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1460447741704},{"_id":"public/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1460447741704},{"_id":"public/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1460447741704},{"_id":"public/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1460447741704},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1460447741704},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1460447741704},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1460447741705},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1460447741705},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1460447741705},{"_id":"public/css/style.css","hash":"c26cefd3906392ae77a6ca75408c21082d27c336","modified":1460447741705},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1460447741705},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1460447741705},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1460447741705},{"_id":"public/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1460447741705},{"_id":"public/images/Three20.png","hash":"62137e205eee70113fe35f781d45a1a6b51d8071","modified":1460447741705},{"_id":"public/images/Alcatraz.png","hash":"4c2019baa182ef00e9f9a120d1f76af6056663b6","modified":1460447741705},{"_id":"public/images/显示图片.png","hash":"87f9db8bf6fb2e04ce189b8b136d44e1028bb5ba","modified":1460447741705},{"_id":"public/images/Three20_Advance.png","hash":"2be5f95606733f6cbdbc759544c74bf2415e86ae","modified":1460447741705},{"_id":"public/img/ZS.png","hash":"f3c5e91eed4d72389b90da0975ed1ed8142120be","modified":1460447741705},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1460447741716},{"_id":"public/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1460447741716},{"_id":"public/images/Animation_Title.gif","hash":"97106d459f871ac314e148efaa2bd2c6c2018b01","modified":1460447741764}],"Category":[{"name":"设计","_id":"cimx4v9t6000594sujm1bfnkx"},{"name":"iOS","_id":"cimx4v9tc000b94suatfjm3ye"},{"name":"Objective-C","_id":"cimx4v9tp000o94sucat6lqc7"},{"name":"开发心得","_id":"cimx4v9tw001294suo0550dey"},{"name":"多线程","_id":"cimx4v9u1001a94sur2973wcq"},{"name":"Xcode","_id":"cimx4v9uv002b94su0lixfwrz"}],"Data":[],"Page":[{"layout":"post","title":"About SeraZheng","comments":0,"toc":false,"_content":"# 郑少博的技术博客\n这是我的个人网站，也算是个博客网站，主要记录了我在生活和工作中的点点滴滴。虽然名为博客，自己当初只是把它当做一个做笔记的文案。文章中的记录可能会有歪曲事实，或者是分析不到位的情况，希望看到这点的朋友们，给个评论，或者是在Repository里面提个issue，我每天都会翻阅GitHub,如果会评论一定会及时回复。另外，本人也会把一些文章挑选出来发到简书，SegmentFault或者开发者头条上去。大家不管在哪里看到的文章，有疑问或者有建议的，欢迎在这里指正。生命不息，奋斗不止，希望我可以一直坚持着写下去！\n\n# 关于我\n{% img /images/本人.jpg %}\n\n* [简书](http://www.jianshu.com/users/a0be12563346/latest_articles)\n* [SegmentFault](http://segmentfault.com/u/shaobo)\n* [StackOverFlow](http://stackoverflow.com/users/5741944/serazheng)\n* [开发者头条](http://toutiao.io/u/169245/subjects)\n* [新浪微博](http://weibo.com/shaobozheng?is_all=1)\n\n\n# 岳飞——《满江红》\n\n### 怒发冲冠，凭栏处潇潇雨歇。\n\n### 抬望眼，仰天长啸，壮怀激烈。\n\n### 三十功名尘与土，\n\n### 八千里路云和月。\n\n### 莫等闲白了少年头，空悲切。\n\n### 靖康耻，犹未雪；\n\n### 臣子恨，何时灭！\n\n### 驾长车踏破贺兰山缺。\n\n### 壮志饥餐胡虏肉，\n\n### 笑谈渴饮匈奴血。\n\n### 待从头收拾旧山河，朝天阙。\n","source":"about/index.md","raw":"---\nlayout: post\ntitle: About SeraZheng\ncomments: false\ntoc: false\n---\n# 郑少博的技术博客\n这是我的个人网站，也算是个博客网站，主要记录了我在生活和工作中的点点滴滴。虽然名为博客，自己当初只是把它当做一个做笔记的文案。文章中的记录可能会有歪曲事实，或者是分析不到位的情况，希望看到这点的朋友们，给个评论，或者是在Repository里面提个issue，我每天都会翻阅GitHub,如果会评论一定会及时回复。另外，本人也会把一些文章挑选出来发到简书，SegmentFault或者开发者头条上去。大家不管在哪里看到的文章，有疑问或者有建议的，欢迎在这里指正。生命不息，奋斗不止，希望我可以一直坚持着写下去！\n\n# 关于我\n{% img /images/本人.jpg %}\n\n* [简书](http://www.jianshu.com/users/a0be12563346/latest_articles)\n* [SegmentFault](http://segmentfault.com/u/shaobo)\n* [StackOverFlow](http://stackoverflow.com/users/5741944/serazheng)\n* [开发者头条](http://toutiao.io/u/169245/subjects)\n* [新浪微博](http://weibo.com/shaobozheng?is_all=1)\n\n\n# 岳飞——《满江红》\n\n### 怒发冲冠，凭栏处潇潇雨歇。\n\n### 抬望眼，仰天长啸，壮怀激烈。\n\n### 三十功名尘与土，\n\n### 八千里路云和月。\n\n### 莫等闲白了少年头，空悲切。\n\n### 靖康耻，犹未雪；\n\n### 臣子恨，何时灭！\n\n### 驾长车踏破贺兰山缺。\n\n### 壮志饥餐胡虏肉，\n\n### 笑谈渴饮匈奴血。\n\n### 待从头收拾旧山河，朝天阙。\n","date":"2016-04-12T07:53:58.000Z","updated":"2016-04-12T06:37:52.000Z","path":"about/index.html","_id":"cimx4v9sz000194suw2sxr4pj","content":"<h1 id=\"郑少博的技术博客\"><a href=\"#郑少博的技术博客\" class=\"headerlink\" title=\"郑少博的技术博客\"></a>郑少博的技术博客</h1><p>这是我的个人网站，也算是个博客网站，主要记录了我在生活和工作中的点点滴滴。虽然名为博客，自己当初只是把它当做一个做笔记的文案。文章中的记录可能会有歪曲事实，或者是分析不到位的情况，希望看到这点的朋友们，给个评论，或者是在Repository里面提个issue，我每天都会翻阅GitHub,如果会评论一定会及时回复。另外，本人也会把一些文章挑选出来发到简书，SegmentFault或者开发者头条上去。大家不管在哪里看到的文章，有疑问或者有建议的，欢迎在这里指正。生命不息，奋斗不止，希望我可以一直坚持着写下去！</p>\n<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><img src=\"/images/本人.jpg\">\n<ul>\n<li><a href=\"http://www.jianshu.com/users/a0be12563346/latest_articles\" target=\"_blank\" rel=\"external\">简书</a></li>\n<li><a href=\"http://segmentfault.com/u/shaobo\" target=\"_blank\" rel=\"external\">SegmentFault</a></li>\n<li><a href=\"http://stackoverflow.com/users/5741944/serazheng\" target=\"_blank\" rel=\"external\">StackOverFlow</a></li>\n<li><a href=\"http://toutiao.io/u/169245/subjects\" target=\"_blank\" rel=\"external\">开发者头条</a></li>\n<li><a href=\"http://weibo.com/shaobozheng?is_all=1\" target=\"_blank\" rel=\"external\">新浪微博</a></li>\n</ul>\n<h1 id=\"岳飞——《满江红》\"><a href=\"#岳飞——《满江红》\" class=\"headerlink\" title=\"岳飞——《满江红》\"></a>岳飞——《满江红》</h1><h3 id=\"怒发冲冠，凭栏处潇潇雨歇。\"><a href=\"#怒发冲冠，凭栏处潇潇雨歇。\" class=\"headerlink\" title=\"怒发冲冠，凭栏处潇潇雨歇。\"></a>怒发冲冠，凭栏处潇潇雨歇。</h3><h3 id=\"抬望眼，仰天长啸，壮怀激烈。\"><a href=\"#抬望眼，仰天长啸，壮怀激烈。\" class=\"headerlink\" title=\"抬望眼，仰天长啸，壮怀激烈。\"></a>抬望眼，仰天长啸，壮怀激烈。</h3><h3 id=\"三十功名尘与土，\"><a href=\"#三十功名尘与土，\" class=\"headerlink\" title=\"三十功名尘与土，\"></a>三十功名尘与土，</h3><h3 id=\"八千里路云和月。\"><a href=\"#八千里路云和月。\" class=\"headerlink\" title=\"八千里路云和月。\"></a>八千里路云和月。</h3><h3 id=\"莫等闲白了少年头，空悲切。\"><a href=\"#莫等闲白了少年头，空悲切。\" class=\"headerlink\" title=\"莫等闲白了少年头，空悲切。\"></a>莫等闲白了少年头，空悲切。</h3><h3 id=\"靖康耻，犹未雪；\"><a href=\"#靖康耻，犹未雪；\" class=\"headerlink\" title=\"靖康耻，犹未雪；\"></a>靖康耻，犹未雪；</h3><h3 id=\"臣子恨，何时灭！\"><a href=\"#臣子恨，何时灭！\" class=\"headerlink\" title=\"臣子恨，何时灭！\"></a>臣子恨，何时灭！</h3><h3 id=\"驾长车踏破贺兰山缺。\"><a href=\"#驾长车踏破贺兰山缺。\" class=\"headerlink\" title=\"驾长车踏破贺兰山缺。\"></a>驾长车踏破贺兰山缺。</h3><h3 id=\"壮志饥餐胡虏肉，\"><a href=\"#壮志饥餐胡虏肉，\" class=\"headerlink\" title=\"壮志饥餐胡虏肉，\"></a>壮志饥餐胡虏肉，</h3><h3 id=\"笑谈渴饮匈奴血。\"><a href=\"#笑谈渴饮匈奴血。\" class=\"headerlink\" title=\"笑谈渴饮匈奴血。\"></a>笑谈渴饮匈奴血。</h3><h3 id=\"待从头收拾旧山河，朝天阙。\"><a href=\"#待从头收拾旧山河，朝天阙。\" class=\"headerlink\" title=\"待从头收拾旧山河，朝天阙。\"></a>待从头收拾旧山河，朝天阙。</h3>","excerpt":"","more":"<h1 id=\"郑少博的技术博客\"><a href=\"#郑少博的技术博客\" class=\"headerlink\" title=\"郑少博的技术博客\"></a>郑少博的技术博客</h1><p>这是我的个人网站，也算是个博客网站，主要记录了我在生活和工作中的点点滴滴。虽然名为博客，自己当初只是把它当做一个做笔记的文案。文章中的记录可能会有歪曲事实，或者是分析不到位的情况，希望看到这点的朋友们，给个评论，或者是在Repository里面提个issue，我每天都会翻阅GitHub,如果会评论一定会及时回复。另外，本人也会把一些文章挑选出来发到简书，SegmentFault或者开发者头条上去。大家不管在哪里看到的文章，有疑问或者有建议的，欢迎在这里指正。生命不息，奋斗不止，希望我可以一直坚持着写下去！</p>\n<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><img src=\"/images/本人.jpg\">\n<ul>\n<li><a href=\"http://www.jianshu.com/users/a0be12563346/latest_articles\">简书</a></li>\n<li><a href=\"http://segmentfault.com/u/shaobo\">SegmentFault</a></li>\n<li><a href=\"http://stackoverflow.com/users/5741944/serazheng\">StackOverFlow</a></li>\n<li><a href=\"http://toutiao.io/u/169245/subjects\">开发者头条</a></li>\n<li><a href=\"http://weibo.com/shaobozheng?is_all=1\">新浪微博</a></li>\n</ul>\n<h1 id=\"岳飞——《满江红》\"><a href=\"#岳飞——《满江红》\" class=\"headerlink\" title=\"岳飞——《满江红》\"></a>岳飞——《满江红》</h1><h3 id=\"怒发冲冠，凭栏处潇潇雨歇。\"><a href=\"#怒发冲冠，凭栏处潇潇雨歇。\" class=\"headerlink\" title=\"怒发冲冠，凭栏处潇潇雨歇。\"></a>怒发冲冠，凭栏处潇潇雨歇。</h3><h3 id=\"抬望眼，仰天长啸，壮怀激烈。\"><a href=\"#抬望眼，仰天长啸，壮怀激烈。\" class=\"headerlink\" title=\"抬望眼，仰天长啸，壮怀激烈。\"></a>抬望眼，仰天长啸，壮怀激烈。</h3><h3 id=\"三十功名尘与土，\"><a href=\"#三十功名尘与土，\" class=\"headerlink\" title=\"三十功名尘与土，\"></a>三十功名尘与土，</h3><h3 id=\"八千里路云和月。\"><a href=\"#八千里路云和月。\" class=\"headerlink\" title=\"八千里路云和月。\"></a>八千里路云和月。</h3><h3 id=\"莫等闲白了少年头，空悲切。\"><a href=\"#莫等闲白了少年头，空悲切。\" class=\"headerlink\" title=\"莫等闲白了少年头，空悲切。\"></a>莫等闲白了少年头，空悲切。</h3><h3 id=\"靖康耻，犹未雪；\"><a href=\"#靖康耻，犹未雪；\" class=\"headerlink\" title=\"靖康耻，犹未雪；\"></a>靖康耻，犹未雪；</h3><h3 id=\"臣子恨，何时灭！\"><a href=\"#臣子恨，何时灭！\" class=\"headerlink\" title=\"臣子恨，何时灭！\"></a>臣子恨，何时灭！</h3><h3 id=\"驾长车踏破贺兰山缺。\"><a href=\"#驾长车踏破贺兰山缺。\" class=\"headerlink\" title=\"驾长车踏破贺兰山缺。\"></a>驾长车踏破贺兰山缺。</h3><h3 id=\"壮志饥餐胡虏肉，\"><a href=\"#壮志饥餐胡虏肉，\" class=\"headerlink\" title=\"壮志饥餐胡虏肉，\"></a>壮志饥餐胡虏肉，</h3><h3 id=\"笑谈渴饮匈奴血。\"><a href=\"#笑谈渴饮匈奴血。\" class=\"headerlink\" title=\"笑谈渴饮匈奴血。\"></a>笑谈渴饮匈奴血。</h3><h3 id=\"待从头收拾旧山河，朝天阙。\"><a href=\"#待从头收拾旧山河，朝天阙。\" class=\"headerlink\" title=\"待从头收拾旧山河，朝天阙。\"></a>待从头收拾旧山河，朝天阙。</h3>"},{"layout":"categories","title":"Categories","_content":"","source":"categories/index.md","raw":"layout: categories\ntitle: categories\n---","date":"2016-04-12T07:53:58.000Z","updated":"2016-04-11T06:48:20.000Z","path":"categories/index.html","comments":1,"_id":"cimx4v9t2000394su6jz7pcvv","content":"","excerpt":"","more":""},{"layout":"tags","title":"Tags","_content":"","source":"tags/index.md","raw":"layout: tags\ntitle: tags\n---\n","date":"2016-04-12T07:53:58.000Z","updated":"2016-04-11T06:47:53.000Z","path":"tags/index.html","comments":1,"_id":"cimx4v9t8000794su1ig9f1os","content":"","excerpt":"","more":""}],"Post":[{"layout":"post","title":"Select All功能的设计","date":"2015-09-26T16:00:00.000Z","description":"介绍Select All功能的一些设计方式","_content":"\n# 前言\n在形形色色的APP设计中，`“Select All“`功能得细节设计尤为不同。移动端的设计精髓就在于将主要的功能完美得展示给用户，而不能给用户带来使用的复杂度和概念上得困惑。大多数的App将`\"Select All\"`这个feature与`分页功能`排斥展示，这就是细节上的体验，因而在大数据量的页面中，正常人并不会加入`\"Select All\"`这个feature。\n<!-- more -->\n# 按钮式设计\n在添加\"Select All\"这个feature到页面之后，就要考虑展示方式和逻辑。比如，一些app将”Select All“与”Deselect All“设计成了俩个相互转换的tab,例如下面这俩种，完全展示了\"Select All\"与\"Deselect All\"的直接操作与处理。\n{% img /images/SelectAll_Button.gif %}\n\n# Checkbox式设计\n同时也有其他的一些app,并没有展现\"Select All\"或者是\"Deselect All\"这样的字眼，而是通过形象地图标示例，指导用户操作，经典地就如使用checkbox，做到和web端\"Select All\"的效果。如下图所示：\n{% img /images/SelectAll_CheckBox.png %}\n\n# 总结\n就我个人而言，无论是哪种设计方式，都要结合自己项目的特点，发挥自己项目的优势，展现项目的风格，而最首要地就是要迎合客户的需求，因为不管你做的多么精美漂亮，如果用户感觉华而不实的话，那也不能算是过关的设计。个人作为一个开发人员，未入门的设计人员，只是浅谈一下细节设计，发表一些自己的感慨，无伤大雅。","source":"_posts/\"Select All\"功能的设计.md","raw":"---\nlayout: post\ntitle: Select All功能的设计\ndate: 2015-09-27\ndescription: \"介绍Select All功能的一些设计方式\"\ntags: [设计]\ncategories: [设计]\n---\n\n# 前言\n在形形色色的APP设计中，`“Select All“`功能得细节设计尤为不同。移动端的设计精髓就在于将主要的功能完美得展示给用户，而不能给用户带来使用的复杂度和概念上得困惑。大多数的App将`\"Select All\"`这个feature与`分页功能`排斥展示，这就是细节上的体验，因而在大数据量的页面中，正常人并不会加入`\"Select All\"`这个feature。\n<!-- more -->\n# 按钮式设计\n在添加\"Select All\"这个feature到页面之后，就要考虑展示方式和逻辑。比如，一些app将”Select All“与”Deselect All“设计成了俩个相互转换的tab,例如下面这俩种，完全展示了\"Select All\"与\"Deselect All\"的直接操作与处理。\n{% img /images/SelectAll_Button.gif %}\n\n# Checkbox式设计\n同时也有其他的一些app,并没有展现\"Select All\"或者是\"Deselect All\"这样的字眼，而是通过形象地图标示例，指导用户操作，经典地就如使用checkbox，做到和web端\"Select All\"的效果。如下图所示：\n{% img /images/SelectAll_CheckBox.png %}\n\n# 总结\n就我个人而言，无论是哪种设计方式，都要结合自己项目的特点，发挥自己项目的优势，展现项目的风格，而最首要地就是要迎合客户的需求，因为不管你做的多么精美漂亮，如果用户感觉华而不实的话，那也不能算是过关的设计。个人作为一个开发人员，未入门的设计人员，只是浅谈一下细节设计，发表一些自己的感慨，无伤大雅。","slug":"\"Select All\"功能的设计","published":1,"updated":"2016-04-12T06:50:30.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9su000094sul0moaoma","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在形形色色的APP设计中，<code>“Select All“</code>功能得细节设计尤为不同。移动端的设计精髓就在于将主要的功能完美得展示给用户，而不能给用户带来使用的复杂度和概念上得困惑。大多数的App将<code>&quot;Select All&quot;</code>这个feature与<code>分页功能</code>排斥展示，这就是细节上的体验，因而在大数据量的页面中，正常人并不会加入<code>&quot;Select All&quot;</code>这个feature。<br><a id=\"more\"></a></p>\n<h1 id=\"按钮式设计\"><a href=\"#按钮式设计\" class=\"headerlink\" title=\"按钮式设计\"></a>按钮式设计</h1><p>在添加”Select All”这个feature到页面之后，就要考虑展示方式和逻辑。比如，一些app将”Select All“与”Deselect All“设计成了俩个相互转换的tab,例如下面这俩种，完全展示了”Select All”与”Deselect All”的直接操作与处理。<br><img src=\"/images/SelectAll_Button.gif\"></p>\n<h1 id=\"Checkbox式设计\"><a href=\"#Checkbox式设计\" class=\"headerlink\" title=\"Checkbox式设计\"></a>Checkbox式设计</h1><p>同时也有其他的一些app,并没有展现”Select All”或者是”Deselect All”这样的字眼，而是通过形象地图标示例，指导用户操作，经典地就如使用checkbox，做到和web端”Select All”的效果。如下图所示：<br><img src=\"/images/SelectAll_CheckBox.png\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>就我个人而言，无论是哪种设计方式，都要结合自己项目的特点，发挥自己项目的优势，展现项目的风格，而最首要地就是要迎合客户的需求，因为不管你做的多么精美漂亮，如果用户感觉华而不实的话，那也不能算是过关的设计。个人作为一个开发人员，未入门的设计人员，只是浅谈一下细节设计，发表一些自己的感慨，无伤大雅。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在形形色色的APP设计中，<code>“Select All“</code>功能得细节设计尤为不同。移动端的设计精髓就在于将主要的功能完美得展示给用户，而不能给用户带来使用的复杂度和概念上得困惑。大多数的App将<code>&quot;Select All&quot;</code>这个feature与<code>分页功能</code>排斥展示，这就是细节上的体验，因而在大数据量的页面中，正常人并不会加入<code>&quot;Select All&quot;</code>这个feature。<br>","more":"</p>\n<h1 id=\"按钮式设计\"><a href=\"#按钮式设计\" class=\"headerlink\" title=\"按钮式设计\"></a>按钮式设计</h1><p>在添加”Select All”这个feature到页面之后，就要考虑展示方式和逻辑。比如，一些app将”Select All“与”Deselect All“设计成了俩个相互转换的tab,例如下面这俩种，完全展示了”Select All”与”Deselect All”的直接操作与处理。<br><img src=\"/images/SelectAll_Button.gif\"></p>\n<h1 id=\"Checkbox式设计\"><a href=\"#Checkbox式设计\" class=\"headerlink\" title=\"Checkbox式设计\"></a>Checkbox式设计</h1><p>同时也有其他的一些app,并没有展现”Select All”或者是”Deselect All”这样的字眼，而是通过形象地图标示例，指导用户操作，经典地就如使用checkbox，做到和web端”Select All”的效果。如下图所示：<br><img src=\"/images/SelectAll_CheckBox.png\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>就我个人而言，无论是哪种设计方式，都要结合自己项目的特点，发挥自己项目的优势，展现项目的风格，而最首要地就是要迎合客户的需求，因为不管你做的多么精美漂亮，如果用户感觉华而不实的话，那也不能算是过关的设计。个人作为一个开发人员，未入门的设计人员，只是浅谈一下细节设计，发表一些自己的感慨，无伤大雅。</p>"},{"layout":"post","title":"Apple推送通知(一)原理","date":"2015-07-11T16:00:00.000Z","_content":"\n# 前言　　\n最近刚刚给项目的app添加了苹果的推送服务`APNS（Apple Push Notification Service）`,在这里记录一下自己的经历和收获。和之前一样，先给大家推荐一篇我认为非常棒的来自RayWenderlich上面的博客[Apple Push Notification Services in iOS 6 Tutorial](http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1)，APNS的相关开发，我大都是跟着这篇博客在学习。（这里也可以权当是一篇翻译。。。。哈哈哈。。。。）\n<!-- more -->\n# APNS原理\n借用一下该博客的原理图，在这里做一下解释，这个原理图形象具体地描述了`APNS`的工作流程。\n\n![APNS流程图](http://6567812.s21i-6.faiusr.com/2/ABUIABACGAAgjtn8rQUo573olQIw0wM49AM.jpg)\n\n首先app必须拿到设备的`deviceToken`，这个是设备的唯一标识，然后app把`APNS`返回的设备的`deviceToken`发送注册到自己的server上，当你有想要接收的消息时，server就会把你想要的消息经由`APNS`转发到设备上。\n \n# 前期条件\n根据上面的流程，我们可以知道：首先为了确保开发和测试APNS，开发项目必须具有一下几个条件：\n\n1. 一台装有iOS系统、可以连接外网的设备（APNS是simulator无法测试到的一项特性，上面的流程图可以参证）；\n2. 一个开发者账号（有必要的签名文件和证书）；\n3. 一台可以连接外网的服务器（或代理服务器）。","source":"_posts/Apple推送通知(一)原理.md","raw":"---\nlayout: post\ntitle: Apple推送通知(一)原理\ndate: 2015-07-12\ntags: [APNS]\ncategories: [iOS]\n---\n\n# 前言　　\n最近刚刚给项目的app添加了苹果的推送服务`APNS（Apple Push Notification Service）`,在这里记录一下自己的经历和收获。和之前一样，先给大家推荐一篇我认为非常棒的来自RayWenderlich上面的博客[Apple Push Notification Services in iOS 6 Tutorial](http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1)，APNS的相关开发，我大都是跟着这篇博客在学习。（这里也可以权当是一篇翻译。。。。哈哈哈。。。。）\n<!-- more -->\n# APNS原理\n借用一下该博客的原理图，在这里做一下解释，这个原理图形象具体地描述了`APNS`的工作流程。\n\n![APNS流程图](http://6567812.s21i-6.faiusr.com/2/ABUIABACGAAgjtn8rQUo573olQIw0wM49AM.jpg)\n\n首先app必须拿到设备的`deviceToken`，这个是设备的唯一标识，然后app把`APNS`返回的设备的`deviceToken`发送注册到自己的server上，当你有想要接收的消息时，server就会把你想要的消息经由`APNS`转发到设备上。\n \n# 前期条件\n根据上面的流程，我们可以知道：首先为了确保开发和测试APNS，开发项目必须具有一下几个条件：\n\n1. 一台装有iOS系统、可以连接外网的设备（APNS是simulator无法测试到的一项特性，上面的流程图可以参证）；\n2. 一个开发者账号（有必要的签名文件和证书）；\n3. 一台可以连接外网的服务器（或代理服务器）。","slug":"Apple推送通知(一)原理","published":1,"updated":"2016-04-12T06:43:26.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9t0000294su80oi2pcj","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>最近刚刚给项目的app添加了苹果的推送服务<code>APNS（Apple Push Notification Service）</code>,在这里记录一下自己的经历和收获。和之前一样，先给大家推荐一篇我认为非常棒的来自RayWenderlich上面的博客<a href=\"http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1\" target=\"_blank\" rel=\"external\">Apple Push Notification Services in iOS 6 Tutorial</a>，APNS的相关开发，我大都是跟着这篇博客在学习。（这里也可以权当是一篇翻译。。。。哈哈哈。。。。）<br><a id=\"more\"></a></p>\n<h1 id=\"APNS原理\"><a href=\"#APNS原理\" class=\"headerlink\" title=\"APNS原理\"></a>APNS原理</h1><p>借用一下该博客的原理图，在这里做一下解释，这个原理图形象具体地描述了<code>APNS</code>的工作流程。</p>\n<p><img src=\"http://6567812.s21i-6.faiusr.com/2/ABUIABACGAAgjtn8rQUo573olQIw0wM49AM.jpg\" alt=\"APNS流程图\"></p>\n<p>首先app必须拿到设备的<code>deviceToken</code>，这个是设备的唯一标识，然后app把<code>APNS</code>返回的设备的<code>deviceToken</code>发送注册到自己的server上，当你有想要接收的消息时，server就会把你想要的消息经由<code>APNS</code>转发到设备上。</p>\n<h1 id=\"前期条件\"><a href=\"#前期条件\" class=\"headerlink\" title=\"前期条件\"></a>前期条件</h1><p>根据上面的流程，我们可以知道：首先为了确保开发和测试APNS，开发项目必须具有一下几个条件：</p>\n<ol>\n<li>一台装有iOS系统、可以连接外网的设备（APNS是simulator无法测试到的一项特性，上面的流程图可以参证）；</li>\n<li>一个开发者账号（有必要的签名文件和证书）；</li>\n<li>一台可以连接外网的服务器（或代理服务器）。</li>\n</ol>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>最近刚刚给项目的app添加了苹果的推送服务<code>APNS（Apple Push Notification Service）</code>,在这里记录一下自己的经历和收获。和之前一样，先给大家推荐一篇我认为非常棒的来自RayWenderlich上面的博客<a href=\"http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1\">Apple Push Notification Services in iOS 6 Tutorial</a>，APNS的相关开发，我大都是跟着这篇博客在学习。（这里也可以权当是一篇翻译。。。。哈哈哈。。。。）<br>","more":"</p>\n<h1 id=\"APNS原理\"><a href=\"#APNS原理\" class=\"headerlink\" title=\"APNS原理\"></a>APNS原理</h1><p>借用一下该博客的原理图，在这里做一下解释，这个原理图形象具体地描述了<code>APNS</code>的工作流程。</p>\n<p><img src=\"http://6567812.s21i-6.faiusr.com/2/ABUIABACGAAgjtn8rQUo573olQIw0wM49AM.jpg\" alt=\"APNS流程图\"></p>\n<p>首先app必须拿到设备的<code>deviceToken</code>，这个是设备的唯一标识，然后app把<code>APNS</code>返回的设备的<code>deviceToken</code>发送注册到自己的server上，当你有想要接收的消息时，server就会把你想要的消息经由<code>APNS</code>转发到设备上。</p>\n<h1 id=\"前期条件\"><a href=\"#前期条件\" class=\"headerlink\" title=\"前期条件\"></a>前期条件</h1><p>根据上面的流程，我们可以知道：首先为了确保开发和测试APNS，开发项目必须具有一下几个条件：</p>\n<ol>\n<li>一台装有iOS系统、可以连接外网的设备（APNS是simulator无法测试到的一项特性，上面的流程图可以参证）；</li>\n<li>一个开发者账号（有必要的签名文件和证书）；</li>\n<li>一台可以连接外网的服务器（或代理服务器）。</li>\n</ol>"},{"layout":"post","title":"Apple推送通知(三)开发","date":"2015-07-13T16:00:00.000Z","_content":"\n# 前言　　\n经过了前面的准备，我们在这一篇中终于是要开始接触代码了，首先我是一个`Objective-c`语言的支持者，所以下面会使用`Objective-c`语言来组织代码。\n\n# Json数据\n我们想要收到的消息是以JSON格式提供的，类似于下面这样:\n{% codeblock lang:json %}\n{\n   \"aps\":{\n       \"alert\": \"Hello, world!\",\n       \"sound\": \"default\"\n       \"badge\": \"2\"\n   }\n}\n{% endcodeblock %}\n<!-- more -->\n# 注册deviceToken\n首先我们需要在我们的项目中添加注册设备的`deviceToken`的方法：这一点在iOS 7和iOS 8中略有差异。在iOS 8以后官方SDK中新增加了一个类`UIUserNotificationSettings`，将`APNS`注册设备的设置封装了起来，并提供了更好的支持。\n\n在iOS 8以下的SDK中，我们使用下面的注册方式：\n\n{% codeblock lang:objc %} \n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary \t*)launchOptions {\n    \n   \t[application registerForRemoteNotificationTypes:(UIRemoteNotificationTypeAlert |UIRemoteNotificationTypeBadge |UIRemoteNotificationTypeSound)];\n}\n{% endcodeblock %}\t\n\n但是在iOS 8以后的SDK中，就需要使用下面的注册方式：\n\n{% codeblock objc %}\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n\tif ([application respondsToSelector:@selector(registerUserNotificationSettings:)]) { // iOS version >= 8.x\n        UIUserNotificationSettings *notificationSettings = [UIUserNotificationSettingssettingsForTypes:(UIUserNotificationTypeAlert | UIUserNotificationTypeSound | UIUserNotificationTypeBadge) categories:nil];\n        [application registerUserNotificationSettings:notificationSettings];\n        [application registerForRemoteNotifications];\n    }\n}\n{% endcodeblock %}\n\n# 获取deviceToken\n当app运行以后，就可以在下面的方法中接收到`APNS`返回的设备的`deviceToken`：我们就可以在下面的方法中，把接收到的`deviceToken`发送注册到自己的Server上（需要Server端提供api）\n\n{% codeblock lang:objc%}\n-(void)application:(UIApplication*)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken{\n  \tNSLog(@\"My token is: %@\", deviceToken);   \n}\n{% endcodeblock %}\n\n\n{% codeblock lang:objc %}\n-(void)application:(UIApplication*)application didFailToRegisterForRemoteNotificationsWithError:(NSError*)error    {\n  \tNSLog(@\"Failed to get token, error: %@\", error);    \n}\n{% endcodeblock %}\n\n# 点击通知\n当`APNS`消息推送过来的时候，通过点击消息就可以触发下面的方法，在iOS 7和iOS 8不同的SDK中也会不同，iOS 8之前是：\n\n{% codeblock lang:objc %}\n-(void)application:(UIApplication*)application didReceiveRemoteNotification:(NSDictionary*)userInfo    {\n   \tNSLog(@\"Received notification: %@\", userInfo);    \n}\n{% endcodeblock %}\n\n而在iOS 8之后的SDK中是：\n\n{% codeblock lang:objc %}\n-(void)application:(UIApplication*)application didReceiveRemoteNotification:(NSDictionary*)userInfo fetchComplet    ionHandler:(void (^)\t\t(UIBackgroundFetchResult))completionHandler{\n    NSLog(@\"Received notification: %@\", userInfo);    \n}\n{% endcodeblock %}\n\n我们通过在上面的回调方法中加入自己的逻辑，就可以很好的通过Apple推送通知来增强用户体验。","source":"_posts/Apple推送通知(三)开发.md","raw":"---\nlayout: post\ntitle: Apple推送通知(三)开发\ndate: 2015-07-14\ntags: [APNS]\ncategories: [iOS]\n---\n\n# 前言　　\n经过了前面的准备，我们在这一篇中终于是要开始接触代码了，首先我是一个`Objective-c`语言的支持者，所以下面会使用`Objective-c`语言来组织代码。\n\n# Json数据\n我们想要收到的消息是以JSON格式提供的，类似于下面这样:\n{% codeblock lang:json %}\n{\n   \"aps\":{\n       \"alert\": \"Hello, world!\",\n       \"sound\": \"default\"\n       \"badge\": \"2\"\n   }\n}\n{% endcodeblock %}\n<!-- more -->\n# 注册deviceToken\n首先我们需要在我们的项目中添加注册设备的`deviceToken`的方法：这一点在iOS 7和iOS 8中略有差异。在iOS 8以后官方SDK中新增加了一个类`UIUserNotificationSettings`，将`APNS`注册设备的设置封装了起来，并提供了更好的支持。\n\n在iOS 8以下的SDK中，我们使用下面的注册方式：\n\n{% codeblock lang:objc %} \n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary \t*)launchOptions {\n    \n   \t[application registerForRemoteNotificationTypes:(UIRemoteNotificationTypeAlert |UIRemoteNotificationTypeBadge |UIRemoteNotificationTypeSound)];\n}\n{% endcodeblock %}\t\n\n但是在iOS 8以后的SDK中，就需要使用下面的注册方式：\n\n{% codeblock objc %}\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n\tif ([application respondsToSelector:@selector(registerUserNotificationSettings:)]) { // iOS version >= 8.x\n        UIUserNotificationSettings *notificationSettings = [UIUserNotificationSettingssettingsForTypes:(UIUserNotificationTypeAlert | UIUserNotificationTypeSound | UIUserNotificationTypeBadge) categories:nil];\n        [application registerUserNotificationSettings:notificationSettings];\n        [application registerForRemoteNotifications];\n    }\n}\n{% endcodeblock %}\n\n# 获取deviceToken\n当app运行以后，就可以在下面的方法中接收到`APNS`返回的设备的`deviceToken`：我们就可以在下面的方法中，把接收到的`deviceToken`发送注册到自己的Server上（需要Server端提供api）\n\n{% codeblock lang:objc%}\n-(void)application:(UIApplication*)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken{\n  \tNSLog(@\"My token is: %@\", deviceToken);   \n}\n{% endcodeblock %}\n\n\n{% codeblock lang:objc %}\n-(void)application:(UIApplication*)application didFailToRegisterForRemoteNotificationsWithError:(NSError*)error    {\n  \tNSLog(@\"Failed to get token, error: %@\", error);    \n}\n{% endcodeblock %}\n\n# 点击通知\n当`APNS`消息推送过来的时候，通过点击消息就可以触发下面的方法，在iOS 7和iOS 8不同的SDK中也会不同，iOS 8之前是：\n\n{% codeblock lang:objc %}\n-(void)application:(UIApplication*)application didReceiveRemoteNotification:(NSDictionary*)userInfo    {\n   \tNSLog(@\"Received notification: %@\", userInfo);    \n}\n{% endcodeblock %}\n\n而在iOS 8之后的SDK中是：\n\n{% codeblock lang:objc %}\n-(void)application:(UIApplication*)application didReceiveRemoteNotification:(NSDictionary*)userInfo fetchComplet    ionHandler:(void (^)\t\t(UIBackgroundFetchResult))completionHandler{\n    NSLog(@\"Received notification: %@\", userInfo);    \n}\n{% endcodeblock %}\n\n我们通过在上面的回调方法中加入自己的逻辑，就可以很好的通过Apple推送通知来增强用户体验。","slug":"Apple推送通知(三)开发","published":1,"updated":"2016-04-12T06:44:24.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9t7000694suoh1j33pg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>经过了前面的准备，我们在这一篇中终于是要开始接触代码了，首先我是一个<code>Objective-c</code>语言的支持者，所以下面会使用<code>Objective-c</code>语言来组织代码。</p>\n<h1 id=\"Json数据\"><a href=\"#Json数据\" class=\"headerlink\" title=\"Json数据\"></a>Json数据</h1><p>我们想要收到的消息是以JSON格式提供的，类似于下面这样:<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">       <span class=\"attr\">\"alert\"</span>: <span class=\"string\">\"Hello, world!\"</span>,</span><br><span class=\"line\">       <span class=\"attr\">\"sound\"</span>: <span class=\"string\">\"default\"</span></span><br><span class=\"line\">       <span class=\"string\">\"badge\"</span>: <span class=\"string\">\"2\"</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><a id=\"more\"></a></p>\n<h1 id=\"注册deviceToken\"><a href=\"#注册deviceToken\" class=\"headerlink\" title=\"注册deviceToken\"></a>注册deviceToken</h1><p>首先我们需要在我们的项目中添加注册设备的<code>deviceToken</code>的方法：这一点在iOS 7和iOS 8中略有差异。在iOS 8以后官方SDK中新增加了一个类<code>UIUserNotificationSettings</code>，将<code>APNS</code>注册设备的设置封装了起来，并提供了更好的支持。</p>\n<p>在iOS 8以下的SDK中，我们使用下面的注册方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> \t*)launchOptions &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   \t[application registerForRemoteNotificationTypes:(<span class=\"built_in\">UIRemoteNotificationTypeAlert</span> |<span class=\"built_in\">UIRemoteNotificationTypeBadge</span> |<span class=\"built_in\">UIRemoteNotificationTypeSound</span>)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>    \n<p>但是在iOS 8以后的SDK中，就需要使用下面的注册方式：</p>\n<figure class=\"highlight plain\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class=\"line\">\tif ([application respondsToSelector:@selector(registerUserNotificationSettings:)]) &#123; // iOS version &gt;= 8.x</span><br><span class=\"line\">        UIUserNotificationSettings *notificationSettings = [UIUserNotificationSettingssettingsForTypes:(UIUserNotificationTypeAlert | UIUserNotificationTypeSound | UIUserNotificationTypeBadge) categories:nil];</span><br><span class=\"line\">        [application registerUserNotificationSettings:notificationSettings];</span><br><span class=\"line\">        [application registerForRemoteNotifications];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"获取deviceToken\"><a href=\"#获取deviceToken\" class=\"headerlink\" title=\"获取deviceToken\"></a>获取deviceToken</h1><p>当app运行以后，就可以在下面的方法中接收到<code>APNS</code>返回的设备的<code>deviceToken</code>：我们就可以在下面的方法中，把接收到的<code>deviceToken</code>发送注册到自己的Server上（需要Server端提供api）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span>*)application didRegisterForRemoteNotificationsWithDeviceToken:(<span class=\"built_in\">NSData</span>*)deviceToken&#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"My token is: %@\"</span>, deviceToken);   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span>*)application didFailToRegisterForRemoteNotificationsWithError:(<span class=\"built_in\">NSError</span>*)error    &#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Failed to get token, error: %@\"</span>, error);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"点击通知\"><a href=\"#点击通知\" class=\"headerlink\" title=\"点击通知\"></a>点击通知</h1><p>当<code>APNS</code>消息推送过来的时候，通过点击消息就可以触发下面的方法，在iOS 7和iOS 8不同的SDK中也会不同，iOS 8之前是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span>*)application didReceiveRemoteNotification:(<span class=\"built_in\">NSDictionary</span>*)userInfo    &#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Received notification: %@\"</span>, userInfo);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而在iOS 8之后的SDK中是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span>*)application didReceiveRemoteNotification:(<span class=\"built_in\">NSDictionary</span>*)userInfo fetchComplet    ionHandler:(<span class=\"keyword\">void</span> (^)\t\t(<span class=\"built_in\">UIBackgroundFetchResult</span>))completionHandler&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Received notification: %@\"</span>, userInfo);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们通过在上面的回调方法中加入自己的逻辑，就可以很好的通过Apple推送通知来增强用户体验。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>经过了前面的准备，我们在这一篇中终于是要开始接触代码了，首先我是一个<code>Objective-c</code>语言的支持者，所以下面会使用<code>Objective-c</code>语言来组织代码。</p>\n<h1 id=\"Json数据\"><a href=\"#Json数据\" class=\"headerlink\" title=\"Json数据\"></a>Json数据</h1><p>我们想要收到的消息是以JSON格式提供的，类似于下面这样:<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">       <span class=\"attr\">\"alert\"</span>: <span class=\"string\">\"Hello, world!\"</span>,</span><br><span class=\"line\">       <span class=\"attr\">\"sound\"</span>: <span class=\"string\">\"default\"</span></span><br><span class=\"line\">       <span class=\"string\">\"badge\"</span>: <span class=\"string\">\"2\"</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>","more":"</p>\n<h1 id=\"注册deviceToken\"><a href=\"#注册deviceToken\" class=\"headerlink\" title=\"注册deviceToken\"></a>注册deviceToken</h1><p>首先我们需要在我们的项目中添加注册设备的<code>deviceToken</code>的方法：这一点在iOS 7和iOS 8中略有差异。在iOS 8以后官方SDK中新增加了一个类<code>UIUserNotificationSettings</code>，将<code>APNS</code>注册设备的设置封装了起来，并提供了更好的支持。</p>\n<p>在iOS 8以下的SDK中，我们使用下面的注册方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> \t*)launchOptions &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   \t[application registerForRemoteNotificationTypes:(<span class=\"built_in\">UIRemoteNotificationTypeAlert</span> |<span class=\"built_in\">UIRemoteNotificationTypeBadge</span> |<span class=\"built_in\">UIRemoteNotificationTypeSound</span>)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>    \n<p>但是在iOS 8以后的SDK中，就需要使用下面的注册方式：</p>\n<figure class=\"highlight plain\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class=\"line\">\tif ([application respondsToSelector:@selector(registerUserNotificationSettings:)]) &#123; // iOS version &gt;= 8.x</span><br><span class=\"line\">        UIUserNotificationSettings *notificationSettings = [UIUserNotificationSettingssettingsForTypes:(UIUserNotificationTypeAlert | UIUserNotificationTypeSound | UIUserNotificationTypeBadge) categories:nil];</span><br><span class=\"line\">        [application registerUserNotificationSettings:notificationSettings];</span><br><span class=\"line\">        [application registerForRemoteNotifications];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"获取deviceToken\"><a href=\"#获取deviceToken\" class=\"headerlink\" title=\"获取deviceToken\"></a>获取deviceToken</h1><p>当app运行以后，就可以在下面的方法中接收到<code>APNS</code>返回的设备的<code>deviceToken</code>：我们就可以在下面的方法中，把接收到的<code>deviceToken</code>发送注册到自己的Server上（需要Server端提供api）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span>*)application didRegisterForRemoteNotificationsWithDeviceToken:(<span class=\"built_in\">NSData</span>*)deviceToken&#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"My token is: %@\"</span>, deviceToken);   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span>*)application didFailToRegisterForRemoteNotificationsWithError:(<span class=\"built_in\">NSError</span>*)error    &#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Failed to get token, error: %@\"</span>, error);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"点击通知\"><a href=\"#点击通知\" class=\"headerlink\" title=\"点击通知\"></a>点击通知</h1><p>当<code>APNS</code>消息推送过来的时候，通过点击消息就可以触发下面的方法，在iOS 7和iOS 8不同的SDK中也会不同，iOS 8之前是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span>*)application didReceiveRemoteNotification:(<span class=\"built_in\">NSDictionary</span>*)userInfo    &#123;</span><br><span class=\"line\">   \t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Received notification: %@\"</span>, userInfo);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而在iOS 8之后的SDK中是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span>*)application didReceiveRemoteNotification:(<span class=\"built_in\">NSDictionary</span>*)userInfo fetchComplet    ionHandler:(<span class=\"keyword\">void</span> (^)\t\t(<span class=\"built_in\">UIBackgroundFetchResult</span>))completionHandler&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Received notification: %@\"</span>, userInfo);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们通过在上面的回调方法中加入自己的逻辑，就可以很好的通过Apple推送通知来增强用户体验。</p>"},{"layout":"post","title":"NSObject的load和initialize方法","date":"2015-09-05T16:00:00.000Z","description":"介绍load方法与initialize方法的异同","_content":"\n# 前言\n之前在利用`runtime`给自己的class的category动态添加属性方法中，用到了load方法，于是就研究了一下load和initialize俩个方法的异同。在这我也先推荐一篇个人认为总结比较好的一篇博客:[三石·道：NSObject的load和initialize方法](http://www.molotang.com/articles/1929.html)。\n<!-- more -->\n# 触发阶段\nload方法是app在编译阶段就会调用的方法，我们在这里可以做一些额外的初始化工作。而initialize方法是在当前的class第一次调用alloc，才会触发的，有且仅会调用一次。在“三石·道”的这篇博客中也详细地阐述了关于使用load和initialize方法的方式和优缺点，这里也就不在赘述。我推荐这篇博客最关键的一点是它给出了苹果开源地load和initialize方法的源代码，正适合我们加以更深地研究。\n\n# 继承\n每一个class都包含一个load和initialize方法，而子类并不会掩盖父类的load和initialize方法。关于这俩个方法在父类与子类的使用方式的异同上，三石·道：NSObject的load和initialize方法这篇博客也作了非常详细地说明。总体而言，子类的load和initialize不必显式调用父类的load和initialize，而父类的load和initialize方法也会被系统调用。而且子类的load和initialize方法调用顺序在父类之后，这一点与传统的其他方法重写有明显区别。\n\n# Category\n除了父类与子类的关系，三石·道：NSObject的load和initialize方法这篇博客中也尤为提出了在class的category中使用load方法，我也正是借鉴了这点加以使用。类的category中定义的load方法会在类以及所有父类子类的load方法调用完之后才会被调用。","source":"_posts/NSObject的load和initialize方法.md","raw":"---\nlayout: post\ntitle: NSObject的load和initialize方法\ndate: 2015-09-06\ndescription: \"介绍load方法与initialize方法的异同\"\ntags: [OC基础]\ncategories: [Objective-C]\n---\n\n# 前言\n之前在利用`runtime`给自己的class的category动态添加属性方法中，用到了load方法，于是就研究了一下load和initialize俩个方法的异同。在这我也先推荐一篇个人认为总结比较好的一篇博客:[三石·道：NSObject的load和initialize方法](http://www.molotang.com/articles/1929.html)。\n<!-- more -->\n# 触发阶段\nload方法是app在编译阶段就会调用的方法，我们在这里可以做一些额外的初始化工作。而initialize方法是在当前的class第一次调用alloc，才会触发的，有且仅会调用一次。在“三石·道”的这篇博客中也详细地阐述了关于使用load和initialize方法的方式和优缺点，这里也就不在赘述。我推荐这篇博客最关键的一点是它给出了苹果开源地load和initialize方法的源代码，正适合我们加以更深地研究。\n\n# 继承\n每一个class都包含一个load和initialize方法，而子类并不会掩盖父类的load和initialize方法。关于这俩个方法在父类与子类的使用方式的异同上，三石·道：NSObject的load和initialize方法这篇博客也作了非常详细地说明。总体而言，子类的load和initialize不必显式调用父类的load和initialize，而父类的load和initialize方法也会被系统调用。而且子类的load和initialize方法调用顺序在父类之后，这一点与传统的其他方法重写有明显区别。\n\n# Category\n除了父类与子类的关系，三石·道：NSObject的load和initialize方法这篇博客中也尤为提出了在class的category中使用load方法，我也正是借鉴了这点加以使用。类的category中定义的load方法会在类以及所有父类子类的load方法调用完之后才会被调用。","slug":"NSObject的load和initialize方法","published":1,"updated":"2016-04-12T06:49:50.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9t8000894suzklrssc8","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>之前在利用<code>runtime</code>给自己的class的category动态添加属性方法中，用到了load方法，于是就研究了一下load和initialize俩个方法的异同。在这我也先推荐一篇个人认为总结比较好的一篇博客:<a href=\"http://www.molotang.com/articles/1929.html\" target=\"_blank\" rel=\"external\">三石·道：NSObject的load和initialize方法</a>。<br><a id=\"more\"></a></p>\n<h1 id=\"触发阶段\"><a href=\"#触发阶段\" class=\"headerlink\" title=\"触发阶段\"></a>触发阶段</h1><p>load方法是app在编译阶段就会调用的方法，我们在这里可以做一些额外的初始化工作。而initialize方法是在当前的class第一次调用alloc，才会触发的，有且仅会调用一次。在“三石·道”的这篇博客中也详细地阐述了关于使用load和initialize方法的方式和优缺点，这里也就不在赘述。我推荐这篇博客最关键的一点是它给出了苹果开源地load和initialize方法的源代码，正适合我们加以更深地研究。</p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>每一个class都包含一个load和initialize方法，而子类并不会掩盖父类的load和initialize方法。关于这俩个方法在父类与子类的使用方式的异同上，三石·道：NSObject的load和initialize方法这篇博客也作了非常详细地说明。总体而言，子类的load和initialize不必显式调用父类的load和initialize，而父类的load和initialize方法也会被系统调用。而且子类的load和initialize方法调用顺序在父类之后，这一点与传统的其他方法重写有明显区别。</p>\n<h1 id=\"Category\"><a href=\"#Category\" class=\"headerlink\" title=\"Category\"></a>Category</h1><p>除了父类与子类的关系，三石·道：NSObject的load和initialize方法这篇博客中也尤为提出了在class的category中使用load方法，我也正是借鉴了这点加以使用。类的category中定义的load方法会在类以及所有父类子类的load方法调用完之后才会被调用。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>之前在利用<code>runtime</code>给自己的class的category动态添加属性方法中，用到了load方法，于是就研究了一下load和initialize俩个方法的异同。在这我也先推荐一篇个人认为总结比较好的一篇博客:<a href=\"http://www.molotang.com/articles/1929.html\">三石·道：NSObject的load和initialize方法</a>。<br>","more":"</p>\n<h1 id=\"触发阶段\"><a href=\"#触发阶段\" class=\"headerlink\" title=\"触发阶段\"></a>触发阶段</h1><p>load方法是app在编译阶段就会调用的方法，我们在这里可以做一些额外的初始化工作。而initialize方法是在当前的class第一次调用alloc，才会触发的，有且仅会调用一次。在“三石·道”的这篇博客中也详细地阐述了关于使用load和initialize方法的方式和优缺点，这里也就不在赘述。我推荐这篇博客最关键的一点是它给出了苹果开源地load和initialize方法的源代码，正适合我们加以更深地研究。</p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>每一个class都包含一个load和initialize方法，而子类并不会掩盖父类的load和initialize方法。关于这俩个方法在父类与子类的使用方式的异同上，三石·道：NSObject的load和initialize方法这篇博客也作了非常详细地说明。总体而言，子类的load和initialize不必显式调用父类的load和initialize，而父类的load和initialize方法也会被系统调用。而且子类的load和initialize方法调用顺序在父类之后，这一点与传统的其他方法重写有明显区别。</p>\n<h1 id=\"Category\"><a href=\"#Category\" class=\"headerlink\" title=\"Category\"></a>Category</h1><p>除了父类与子类的关系，三石·道：NSObject的load和initialize方法这篇博客中也尤为提出了在class的category中使用load方法，我也正是借鉴了这点加以使用。类的category中定义的load方法会在类以及所有父类子类的load方法调用完之后才会被调用。</p>"},{"layout":"post","title":"Apple推送通知(二)准备","date":"2015-07-12T16:00:00.000Z","_content":"\n# 前言　　\n在上一章节中，我们谈到了Apple推送通知的原理流程和必要的三个条件，由于我所从事的主要是iOS客户端的开发，所以关于Server端的就不在这里赘述，在[Apple Push Notification Services in iOS 6 Tutorial](http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1)这篇博客的第二部分也给了一个具体的实例参考；而且按照惯例呢，我也推荐给朋友们一个用Node JS编写的后台应用[Push Server](https://github.com/jazzychad/PushServer)。我们在这一篇主要讲一下如何利用`Apple　ID`生成`签名文件`和`证书`。\n<!-- more --> \n# Apple ID\n如果没有`Apple ID`的朋友呢，可以通过注册`Apple ID`拥有自己的一个`Apple ID`,操作流程详情见[怎么注册Apple ID](https://appleid.apple.com/cn/)。如果在企业中，企业具有企业开发者账号和团队关系可以添加自己的`Apple　ID`来获取创建证书的权利，如果是个人开发者，那么只能花99刀注册成为个人开发者，在这里我就假设你已经拥有了一个具有团队关系、可以使用的`Apple ID`。\n \n# 证书与签名\n证书是分俩种，一种是安装在Server端的，一种是随app安装设备中的，而俩种证书都是区分`Development`和`Distribution`俩种版本的。\n\n`Development`版本的证书对应真机测试的app，而`Distribution`版本的证书对应已经发布Apple Store上线的app。关于制作俩种证书和生成签名文件的流程，[Apple Push Notification Services in iOS 6 Tutorial](http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1)这篇博客中已经给出了详细的图形展示。\n>我在这里着重点出的就是，我们安装在Server端的证书和签名文件和随app安装在设备中的必须是一致。","source":"_posts/Apple推送通知(二)准备.md","raw":"---\nlayout: post\ntitle: Apple推送通知(二)准备\ndate: 2015-07-13\ntags: [APNS]\ncategories: [iOS]\n---\n\n# 前言　　\n在上一章节中，我们谈到了Apple推送通知的原理流程和必要的三个条件，由于我所从事的主要是iOS客户端的开发，所以关于Server端的就不在这里赘述，在[Apple Push Notification Services in iOS 6 Tutorial](http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1)这篇博客的第二部分也给了一个具体的实例参考；而且按照惯例呢，我也推荐给朋友们一个用Node JS编写的后台应用[Push Server](https://github.com/jazzychad/PushServer)。我们在这一篇主要讲一下如何利用`Apple　ID`生成`签名文件`和`证书`。\n<!-- more --> \n# Apple ID\n如果没有`Apple ID`的朋友呢，可以通过注册`Apple ID`拥有自己的一个`Apple ID`,操作流程详情见[怎么注册Apple ID](https://appleid.apple.com/cn/)。如果在企业中，企业具有企业开发者账号和团队关系可以添加自己的`Apple　ID`来获取创建证书的权利，如果是个人开发者，那么只能花99刀注册成为个人开发者，在这里我就假设你已经拥有了一个具有团队关系、可以使用的`Apple ID`。\n \n# 证书与签名\n证书是分俩种，一种是安装在Server端的，一种是随app安装设备中的，而俩种证书都是区分`Development`和`Distribution`俩种版本的。\n\n`Development`版本的证书对应真机测试的app，而`Distribution`版本的证书对应已经发布Apple Store上线的app。关于制作俩种证书和生成签名文件的流程，[Apple Push Notification Services in iOS 6 Tutorial](http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1)这篇博客中已经给出了详细的图形展示。\n>我在这里着重点出的就是，我们安装在Server端的证书和签名文件和随app安装在设备中的必须是一致。","slug":"Apple推送通知(二)准备","published":1,"updated":"2016-04-12T06:43:54.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9ta000a94sudzqu3zuk","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>在上一章节中，我们谈到了Apple推送通知的原理流程和必要的三个条件，由于我所从事的主要是iOS客户端的开发，所以关于Server端的就不在这里赘述，在<a href=\"http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1\" target=\"_blank\" rel=\"external\">Apple Push Notification Services in iOS 6 Tutorial</a>这篇博客的第二部分也给了一个具体的实例参考；而且按照惯例呢，我也推荐给朋友们一个用Node JS编写的后台应用<a href=\"https://github.com/jazzychad/PushServer\" target=\"_blank\" rel=\"external\">Push Server</a>。我们在这一篇主要讲一下如何利用<code>Apple　ID</code>生成<code>签名文件</code>和<code>证书</code>。<br><a id=\"more\"></a> </p>\n<h1 id=\"Apple-ID\"><a href=\"#Apple-ID\" class=\"headerlink\" title=\"Apple ID\"></a>Apple ID</h1><p>如果没有<code>Apple ID</code>的朋友呢，可以通过注册<code>Apple ID</code>拥有自己的一个<code>Apple ID</code>,操作流程详情见<a href=\"https://appleid.apple.com/cn/\" target=\"_blank\" rel=\"external\">怎么注册Apple ID</a>。如果在企业中，企业具有企业开发者账号和团队关系可以添加自己的<code>Apple　ID</code>来获取创建证书的权利，如果是个人开发者，那么只能花99刀注册成为个人开发者，在这里我就假设你已经拥有了一个具有团队关系、可以使用的<code>Apple ID</code>。</p>\n<h1 id=\"证书与签名\"><a href=\"#证书与签名\" class=\"headerlink\" title=\"证书与签名\"></a>证书与签名</h1><p>证书是分俩种，一种是安装在Server端的，一种是随app安装设备中的，而俩种证书都是区分<code>Development</code>和<code>Distribution</code>俩种版本的。</p>\n<p><code>Development</code>版本的证书对应真机测试的app，而<code>Distribution</code>版本的证书对应已经发布Apple Store上线的app。关于制作俩种证书和生成签名文件的流程，<a href=\"http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1\" target=\"_blank\" rel=\"external\">Apple Push Notification Services in iOS 6 Tutorial</a>这篇博客中已经给出了详细的图形展示。</p>\n<blockquote>\n<p>我在这里着重点出的就是，我们安装在Server端的证书和签名文件和随app安装在设备中的必须是一致。</p>\n</blockquote>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>在上一章节中，我们谈到了Apple推送通知的原理流程和必要的三个条件，由于我所从事的主要是iOS客户端的开发，所以关于Server端的就不在这里赘述，在<a href=\"http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1\">Apple Push Notification Services in iOS 6 Tutorial</a>这篇博客的第二部分也给了一个具体的实例参考；而且按照惯例呢，我也推荐给朋友们一个用Node JS编写的后台应用<a href=\"https://github.com/jazzychad/PushServer\">Push Server</a>。我们在这一篇主要讲一下如何利用<code>Apple　ID</code>生成<code>签名文件</code>和<code>证书</code>。<br>","more":"</p>\n<h1 id=\"Apple-ID\"><a href=\"#Apple-ID\" class=\"headerlink\" title=\"Apple ID\"></a>Apple ID</h1><p>如果没有<code>Apple ID</code>的朋友呢，可以通过注册<code>Apple ID</code>拥有自己的一个<code>Apple ID</code>,操作流程详情见<a href=\"https://appleid.apple.com/cn/\">怎么注册Apple ID</a>。如果在企业中，企业具有企业开发者账号和团队关系可以添加自己的<code>Apple　ID</code>来获取创建证书的权利，如果是个人开发者，那么只能花99刀注册成为个人开发者，在这里我就假设你已经拥有了一个具有团队关系、可以使用的<code>Apple ID</code>。</p>\n<h1 id=\"证书与签名\"><a href=\"#证书与签名\" class=\"headerlink\" title=\"证书与签名\"></a>证书与签名</h1><p>证书是分俩种，一种是安装在Server端的，一种是随app安装设备中的，而俩种证书都是区分<code>Development</code>和<code>Distribution</code>俩种版本的。</p>\n<p><code>Development</code>版本的证书对应真机测试的app，而<code>Distribution</code>版本的证书对应已经发布Apple Store上线的app。关于制作俩种证书和生成签名文件的流程，<a href=\"http://www.raywenderlich.com/32960/apple-push-notification-services-in-ios-6-tutorial-part-1\">Apple Push Notification Services in iOS 6 Tutorial</a>这篇博客中已经给出了详细的图形展示。</p>\n<blockquote>\n<p>我在这里着重点出的就是，我们安装在Server端的证书和签名文件和随app安装在设备中的必须是一致。</p>\n</blockquote>"},{"layout":"post","title":"Apple推送通知(四)silent APNS","date":"2015-07-14T16:00:00.000Z","_content":"\n# 前言　　\n我在上一篇文章中介绍了传统的APNS推送的原理和配置，以及调用的方法。使用传统的APNS推送最大的限制就是字节数的限制，payload最大不能超过256 bytes。而有时往往我们需要更多的信息推送，这时我们就需要用到`silent APNS`\n\n# 简介\n`silent APNS`是iOS 7新加的一个非常好的特性，和以往传统的APNS最大的不同是，当一个`silent APNS`推送到设备时，iOS系统并不会用弹出框提示内容，也不会听到声音，看到图标上的badge，用户不会知道任何事情。而`silent APNS`与传统的APNS相同的是，当推送到设备时，如果App处于激活状态则会调用到相同的系统方法，来让App获取到推送的信息，然后我们可以在App中发起HTTP请求，获取我们想要的数据，之后再展示给用户。\n<!-- more -->\n# 设置\n`silent APNS`和传统的APNS对于证书，签名的设置都是一样的。我们需要在Xcode设置UIBackgroundModes.\n\n{% codeblock lang:xml%}\n<key>UIBackgroundModes</key>\n<array>\n    <string>remote-notification</string>\n</array>\n{% endcodeblock %}\n    \nXcode设置图：\n{% img /images/Silent-Push-Notifications-in-iOS1.png %}\n\n# Json数据\n我们在传统的APNS中想要收到的消息是以JSON格式提供的，类似于下面这样:\n{% codeblock lang:json %}\n{\n   \"aps\":{\n       \"alert\": \"Hello, world!\",\n       \"sound\": \"default\"\n       \"badge\": \"2\"\n   }\n}\n{% endcodeblock %}\n\n而在`silent APNS`中我们需要设置推送的payload为下面的JSON格式\n{% codeblock lang:json %}\n{\n   \"aps\":{\n       content-available: 1\n       \"alert\": {...}\n   }\n}\n{% endcodeblock %}\n\n# 注册deviceToken\n我们在上一节中已经清楚讲了在我们的项目中添加注册设备的`deviceToken`，获取`deviceToken`的方法，而关于`silent APNS`最大的不同之处是我们需要注册的类型不同.\n\n在传统的APNS中，我们使用注册`UIRemoteNotificationTypeAlert`, `UIRemoteNotificationTypeBadge`, `UIRemoteNotificationTypeSound`\n{% codeblock lang:objc %} \n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary \t*)launchOptions {\n    \n   \t[application registerForRemoteNotificationTypes:(UIRemoteNotificationTypeAlert |UIRemoteNotificationTypeBadge |UIRemoteNotificationTypeSound)];\n}\n{% endcodeblock %}\t\n\n而在`silent APNS`中，我们需要多注册一个`UIRemoteNotificationTypeNewsstandContentAvailability`类型\n\n{% codeblock lang:objc %}\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n\t[[UIApplication sharedApplication] registerForRemoteNotificationTypes:\n                               (UIRemoteNotificationTypeNewsstandContentAvailability|\n                                            UIRemoteNotificationTypeBadge |\n                                            UIRemoteNotificationTypeSound |\n                                            UIRemoteNotificationTypeAlert)];\n}\n{% endcodeblock %}\n\n# 推送调用\n当`APNS`消息推送过来的时候，传统的APNS会直接使用声音、弹出框等提示用户，通过点击消息就可以触发下面的方法，而在`silent APNS`中,当推送到达设备时，如果App处于激活状态，则会自动调用下面的方法：\n\n{% codeblock lang:objc %}\n-(void)application:(UIApplication*)application didReceiveRemoteNotification:(NSDictionary*)userInfo fetchComplet    ionHandler:(void (^)\t\t(UIBackgroundFetchResult))completionHandler{\n    NSLog(@\"Received notification: %@\", userInfo);    \n}\n{% endcodeblock %}\n\n我们在`silent APNS`中需要做的就是通过在上面的回调方法中加入自己的逻辑，譬如根据推送过来的信息发起HTTP请求，获取更多想要展示的数据，然后再利用`localNotification`或者是其他手段将信息展示给用户，就可以很好的通过Apple推送通知来增强用户体验。","source":"_posts/Apple推送通知(四)silent APNS.md","raw":"---\nlayout: post\ntitle: Apple推送通知(四)silent APNS\ndate: 2015-07-15\ntags: [APNS]\ncategories: [iOS]\n---\n\n# 前言　　\n我在上一篇文章中介绍了传统的APNS推送的原理和配置，以及调用的方法。使用传统的APNS推送最大的限制就是字节数的限制，payload最大不能超过256 bytes。而有时往往我们需要更多的信息推送，这时我们就需要用到`silent APNS`\n\n# 简介\n`silent APNS`是iOS 7新加的一个非常好的特性，和以往传统的APNS最大的不同是，当一个`silent APNS`推送到设备时，iOS系统并不会用弹出框提示内容，也不会听到声音，看到图标上的badge，用户不会知道任何事情。而`silent APNS`与传统的APNS相同的是，当推送到设备时，如果App处于激活状态则会调用到相同的系统方法，来让App获取到推送的信息，然后我们可以在App中发起HTTP请求，获取我们想要的数据，之后再展示给用户。\n<!-- more -->\n# 设置\n`silent APNS`和传统的APNS对于证书，签名的设置都是一样的。我们需要在Xcode设置UIBackgroundModes.\n\n{% codeblock lang:xml%}\n<key>UIBackgroundModes</key>\n<array>\n    <string>remote-notification</string>\n</array>\n{% endcodeblock %}\n    \nXcode设置图：\n{% img /images/Silent-Push-Notifications-in-iOS1.png %}\n\n# Json数据\n我们在传统的APNS中想要收到的消息是以JSON格式提供的，类似于下面这样:\n{% codeblock lang:json %}\n{\n   \"aps\":{\n       \"alert\": \"Hello, world!\",\n       \"sound\": \"default\"\n       \"badge\": \"2\"\n   }\n}\n{% endcodeblock %}\n\n而在`silent APNS`中我们需要设置推送的payload为下面的JSON格式\n{% codeblock lang:json %}\n{\n   \"aps\":{\n       content-available: 1\n       \"alert\": {...}\n   }\n}\n{% endcodeblock %}\n\n# 注册deviceToken\n我们在上一节中已经清楚讲了在我们的项目中添加注册设备的`deviceToken`，获取`deviceToken`的方法，而关于`silent APNS`最大的不同之处是我们需要注册的类型不同.\n\n在传统的APNS中，我们使用注册`UIRemoteNotificationTypeAlert`, `UIRemoteNotificationTypeBadge`, `UIRemoteNotificationTypeSound`\n{% codeblock lang:objc %} \n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary \t*)launchOptions {\n    \n   \t[application registerForRemoteNotificationTypes:(UIRemoteNotificationTypeAlert |UIRemoteNotificationTypeBadge |UIRemoteNotificationTypeSound)];\n}\n{% endcodeblock %}\t\n\n而在`silent APNS`中，我们需要多注册一个`UIRemoteNotificationTypeNewsstandContentAvailability`类型\n\n{% codeblock lang:objc %}\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n\t[[UIApplication sharedApplication] registerForRemoteNotificationTypes:\n                               (UIRemoteNotificationTypeNewsstandContentAvailability|\n                                            UIRemoteNotificationTypeBadge |\n                                            UIRemoteNotificationTypeSound |\n                                            UIRemoteNotificationTypeAlert)];\n}\n{% endcodeblock %}\n\n# 推送调用\n当`APNS`消息推送过来的时候，传统的APNS会直接使用声音、弹出框等提示用户，通过点击消息就可以触发下面的方法，而在`silent APNS`中,当推送到达设备时，如果App处于激活状态，则会自动调用下面的方法：\n\n{% codeblock lang:objc %}\n-(void)application:(UIApplication*)application didReceiveRemoteNotification:(NSDictionary*)userInfo fetchComplet    ionHandler:(void (^)\t\t(UIBackgroundFetchResult))completionHandler{\n    NSLog(@\"Received notification: %@\", userInfo);    \n}\n{% endcodeblock %}\n\n我们在`silent APNS`中需要做的就是通过在上面的回调方法中加入自己的逻辑，譬如根据推送过来的信息发起HTTP请求，获取更多想要展示的数据，然后再利用`localNotification`或者是其他手段将信息展示给用户，就可以很好的通过Apple推送通知来增强用户体验。","slug":"Apple推送通知(四)silent APNS","published":1,"updated":"2016-04-12T06:45:18.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9te000d94suhlknby6x","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>我在上一篇文章中介绍了传统的APNS推送的原理和配置，以及调用的方法。使用传统的APNS推送最大的限制就是字节数的限制，payload最大不能超过256 bytes。而有时往往我们需要更多的信息推送，这时我们就需要用到<code>silent APNS</code></p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><code>silent APNS</code>是iOS 7新加的一个非常好的特性，和以往传统的APNS最大的不同是，当一个<code>silent APNS</code>推送到设备时，iOS系统并不会用弹出框提示内容，也不会听到声音，看到图标上的badge，用户不会知道任何事情。而<code>silent APNS</code>与传统的APNS相同的是，当推送到设备时，如果App处于激活状态则会调用到相同的系统方法，来让App获取到推送的信息，然后我们可以在App中发起HTTP请求，获取我们想要的数据，之后再展示给用户。<br><a id=\"more\"></a></p>\n<h1 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h1><p><code>silent APNS</code>和传统的APNS对于证书，签名的设置都是一样的。我们需要在Xcode设置UIBackgroundModes.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UIBackgroundModes<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>remote-notification<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Xcode设置图：<br><img src=\"/images/Silent-Push-Notifications-in-iOS1.png\"></p>\n<h1 id=\"Json数据\"><a href=\"#Json数据\" class=\"headerlink\" title=\"Json数据\"></a>Json数据</h1><p>我们在传统的APNS中想要收到的消息是以JSON格式提供的，类似于下面这样:<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">       <span class=\"attr\">\"alert\"</span>: <span class=\"string\">\"Hello, world!\"</span>,</span><br><span class=\"line\">       <span class=\"attr\">\"sound\"</span>: <span class=\"string\">\"default\"</span></span><br><span class=\"line\">       <span class=\"string\">\"badge\"</span>: <span class=\"string\">\"2\"</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而在<code>silent APNS</code>中我们需要设置推送的payload为下面的JSON格式<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   \"aps\":&#123;</span><br><span class=\"line\">       content-available: 1</span><br><span class=\"line\">       \"alert\": &#123;...&#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"注册deviceToken\"><a href=\"#注册deviceToken\" class=\"headerlink\" title=\"注册deviceToken\"></a>注册deviceToken</h1><p>我们在上一节中已经清楚讲了在我们的项目中添加注册设备的<code>deviceToken</code>，获取<code>deviceToken</code>的方法，而关于<code>silent APNS</code>最大的不同之处是我们需要注册的类型不同.</p>\n<p>在传统的APNS中，我们使用注册<code>UIRemoteNotificationTypeAlert</code>, <code>UIRemoteNotificationTypeBadge</code>, <code>UIRemoteNotificationTypeSound</code><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> \t*)launchOptions &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   \t[application registerForRemoteNotificationTypes:(<span class=\"built_in\">UIRemoteNotificationTypeAlert</span> |<span class=\"built_in\">UIRemoteNotificationTypeBadge</span> |<span class=\"built_in\">UIRemoteNotificationTypeSound</span>)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>    </p>\n<p>而在<code>silent APNS</code>中，我们需要多注册一个<code>UIRemoteNotificationTypeNewsstandContentAvailability</code>类型</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">\t[[<span class=\"built_in\">UIApplication</span> sharedApplication] registerForRemoteNotificationTypes:</span><br><span class=\"line\">                               (<span class=\"built_in\">UIRemoteNotificationTypeNewsstandContentAvailability</span>|</span><br><span class=\"line\">                                            <span class=\"built_in\">UIRemoteNotificationTypeBadge</span> |</span><br><span class=\"line\">                                            <span class=\"built_in\">UIRemoteNotificationTypeSound</span> |</span><br><span class=\"line\">                                            <span class=\"built_in\">UIRemoteNotificationTypeAlert</span>)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"推送调用\"><a href=\"#推送调用\" class=\"headerlink\" title=\"推送调用\"></a>推送调用</h1><p>当<code>APNS</code>消息推送过来的时候，传统的APNS会直接使用声音、弹出框等提示用户，通过点击消息就可以触发下面的方法，而在<code>silent APNS</code>中,当推送到达设备时，如果App处于激活状态，则会自动调用下面的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span>*)application didReceiveRemoteNotification:(<span class=\"built_in\">NSDictionary</span>*)userInfo fetchComplet    ionHandler:(<span class=\"keyword\">void</span> (^)\t\t(<span class=\"built_in\">UIBackgroundFetchResult</span>))completionHandler&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Received notification: %@\"</span>, userInfo);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在<code>silent APNS</code>中需要做的就是通过在上面的回调方法中加入自己的逻辑，譬如根据推送过来的信息发起HTTP请求，获取更多想要展示的数据，然后再利用<code>localNotification</code>或者是其他手段将信息展示给用户，就可以很好的通过Apple推送通知来增强用户体验。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>我在上一篇文章中介绍了传统的APNS推送的原理和配置，以及调用的方法。使用传统的APNS推送最大的限制就是字节数的限制，payload最大不能超过256 bytes。而有时往往我们需要更多的信息推送，这时我们就需要用到<code>silent APNS</code></p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><code>silent APNS</code>是iOS 7新加的一个非常好的特性，和以往传统的APNS最大的不同是，当一个<code>silent APNS</code>推送到设备时，iOS系统并不会用弹出框提示内容，也不会听到声音，看到图标上的badge，用户不会知道任何事情。而<code>silent APNS</code>与传统的APNS相同的是，当推送到设备时，如果App处于激活状态则会调用到相同的系统方法，来让App获取到推送的信息，然后我们可以在App中发起HTTP请求，获取我们想要的数据，之后再展示给用户。<br>","more":"</p>\n<h1 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h1><p><code>silent APNS</code>和传统的APNS对于证书，签名的设置都是一样的。我们需要在Xcode设置UIBackgroundModes.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UIBackgroundModes<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>remote-notification<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Xcode设置图：<br><img src=\"/images/Silent-Push-Notifications-in-iOS1.png\"></p>\n<h1 id=\"Json数据\"><a href=\"#Json数据\" class=\"headerlink\" title=\"Json数据\"></a>Json数据</h1><p>我们在传统的APNS中想要收到的消息是以JSON格式提供的，类似于下面这样:<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">       <span class=\"attr\">\"alert\"</span>: <span class=\"string\">\"Hello, world!\"</span>,</span><br><span class=\"line\">       <span class=\"attr\">\"sound\"</span>: <span class=\"string\">\"default\"</span></span><br><span class=\"line\">       <span class=\"string\">\"badge\"</span>: <span class=\"string\">\"2\"</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而在<code>silent APNS</code>中我们需要设置推送的payload为下面的JSON格式<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   \"aps\":&#123;</span><br><span class=\"line\">       content-available: 1</span><br><span class=\"line\">       \"alert\": &#123;...&#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"注册deviceToken\"><a href=\"#注册deviceToken\" class=\"headerlink\" title=\"注册deviceToken\"></a>注册deviceToken</h1><p>我们在上一节中已经清楚讲了在我们的项目中添加注册设备的<code>deviceToken</code>，获取<code>deviceToken</code>的方法，而关于<code>silent APNS</code>最大的不同之处是我们需要注册的类型不同.</p>\n<p>在传统的APNS中，我们使用注册<code>UIRemoteNotificationTypeAlert</code>, <code>UIRemoteNotificationTypeBadge</code>, <code>UIRemoteNotificationTypeSound</code><br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> \t*)launchOptions &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   \t[application registerForRemoteNotificationTypes:(<span class=\"built_in\">UIRemoteNotificationTypeAlert</span> |<span class=\"built_in\">UIRemoteNotificationTypeBadge</span> |<span class=\"built_in\">UIRemoteNotificationTypeSound</span>)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>    </p>\n<p>而在<code>silent APNS</code>中，我们需要多注册一个<code>UIRemoteNotificationTypeNewsstandContentAvailability</code>类型</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">\t[[<span class=\"built_in\">UIApplication</span> sharedApplication] registerForRemoteNotificationTypes:</span><br><span class=\"line\">                               (<span class=\"built_in\">UIRemoteNotificationTypeNewsstandContentAvailability</span>|</span><br><span class=\"line\">                                            <span class=\"built_in\">UIRemoteNotificationTypeBadge</span> |</span><br><span class=\"line\">                                            <span class=\"built_in\">UIRemoteNotificationTypeSound</span> |</span><br><span class=\"line\">                                            <span class=\"built_in\">UIRemoteNotificationTypeAlert</span>)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"推送调用\"><a href=\"#推送调用\" class=\"headerlink\" title=\"推送调用\"></a>推送调用</h1><p>当<code>APNS</code>消息推送过来的时候，传统的APNS会直接使用声音、弹出框等提示用户，通过点击消息就可以触发下面的方法，而在<code>silent APNS</code>中,当推送到达设备时，如果App处于激活状态，则会自动调用下面的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span>*)application didReceiveRemoteNotification:(<span class=\"built_in\">NSDictionary</span>*)userInfo fetchComplet    ionHandler:(<span class=\"keyword\">void</span> (^)\t\t(<span class=\"built_in\">UIBackgroundFetchResult</span>))completionHandler&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Received notification: %@\"</span>, userInfo);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在<code>silent APNS</code>中需要做的就是通过在上面的回调方法中加入自己的逻辑，譬如根据推送过来的信息发起HTTP请求，获取更多想要展示的数据，然后再利用<code>localNotification</code>或者是其他手段将信息展示给用户，就可以很好的通过Apple推送通知来增强用户体验。</p>"},{"layout":"post","title":"UIResponder中的inputView与inputAccessoryView","date":"2015-08-21T16:00:00.000Z","description":"描述使用inputAccessoryView完成自己的需求","_content":"\n# 前言\n最近刚给app添加了类似QQ中“@”消息人的功能，其中主要是重写了`UIResponder`中的`inputAccessoryView`这个成员属性。关于`inputView`和`inputAccessoryView`的介绍和使用，我首先推荐俩篇个人认为很不错的辅助文档：[开发者文档----Custom Views for Data Input](https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html)和[博客----UITextField docked like iOS Messenger](http://derpturkey.com/uitextfield-docked-like-ios-messenger/)。\n<!-- more -->\n# 属性介绍\n`inputView`和`inputAccessoryView`是在`UIResponder`中定义的俩个`readonly`的属性。而且所有的UIKit中的控件都继承自`UIResponder`，定义这俩个属性，是为开发者改变系统键盘的视图提供便利。苹果SDK中提供了`UITextView`和`UITextField`俩种editor，而且都重定义了`inputView`和`inputAccessoryView`俩个属性为`readwrite`。\n\n此外，我们也可以在自己定义的UIView的子类中，重定义这俩个属性。按照官方文档的说法，当`inputView不`是nil,而且inputView所属的UIView成为第一响应者时，系统就不会显示出键盘，而是显示我们自定义的`inputView`的值；当`inputAccessoryView`不是nil,而且`inputAccessoryView`所属的UIView成为第一响应者时，系统会显示键盘，并且在键盘的顶部显示出我们定义的`inputAccessoryView`。\n\n# 触发显示\n当我们点击一个UIView时，它就成为了第一响应者，我们还可以调用`becomeFirstResponder`让视图控件成为第一响应者。而在我们重定义`inputView`和`inputAccessoryView`的UIView中，我们也需要重写`canBecomeFirstResponder`这个方法，并且返回true，这样当我们的UIView成为第一响应者时，`inputAccessoryView`和`inputView`才会自动显示出来。\n\n# 自定义显示\n苹果SDK在iOS7中提供了`UIInputView`这个控件，并且在iOS8中提供了`UIInputViewController`这个视图控制器。这俩个是开发者可以很好地用来显示我们自定义的`inputView`和`inputAccessoryView`。`UIInputView`提供了`UIInputViewStyleDefault`和`UIInputViewStyleKeyboard`俩种显示形式，第二种会自动设置背景为系统键盘的背景。","source":"_posts/UIResponder中的inputView与inputAccessoryView.md","raw":"---\nlayout: post\ntitle: UIResponder中的inputView与inputAccessoryView\ndate: 2015-08-22\ndescription: \"描述使用inputAccessoryView完成自己的需求\"\ntags: [UIKit]\ncategories: [iOS]\n---\n\n# 前言\n最近刚给app添加了类似QQ中“@”消息人的功能，其中主要是重写了`UIResponder`中的`inputAccessoryView`这个成员属性。关于`inputView`和`inputAccessoryView`的介绍和使用，我首先推荐俩篇个人认为很不错的辅助文档：[开发者文档----Custom Views for Data Input](https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html)和[博客----UITextField docked like iOS Messenger](http://derpturkey.com/uitextfield-docked-like-ios-messenger/)。\n<!-- more -->\n# 属性介绍\n`inputView`和`inputAccessoryView`是在`UIResponder`中定义的俩个`readonly`的属性。而且所有的UIKit中的控件都继承自`UIResponder`，定义这俩个属性，是为开发者改变系统键盘的视图提供便利。苹果SDK中提供了`UITextView`和`UITextField`俩种editor，而且都重定义了`inputView`和`inputAccessoryView`俩个属性为`readwrite`。\n\n此外，我们也可以在自己定义的UIView的子类中，重定义这俩个属性。按照官方文档的说法，当`inputView不`是nil,而且inputView所属的UIView成为第一响应者时，系统就不会显示出键盘，而是显示我们自定义的`inputView`的值；当`inputAccessoryView`不是nil,而且`inputAccessoryView`所属的UIView成为第一响应者时，系统会显示键盘，并且在键盘的顶部显示出我们定义的`inputAccessoryView`。\n\n# 触发显示\n当我们点击一个UIView时，它就成为了第一响应者，我们还可以调用`becomeFirstResponder`让视图控件成为第一响应者。而在我们重定义`inputView`和`inputAccessoryView`的UIView中，我们也需要重写`canBecomeFirstResponder`这个方法，并且返回true，这样当我们的UIView成为第一响应者时，`inputAccessoryView`和`inputView`才会自动显示出来。\n\n# 自定义显示\n苹果SDK在iOS7中提供了`UIInputView`这个控件，并且在iOS8中提供了`UIInputViewController`这个视图控制器。这俩个是开发者可以很好地用来显示我们自定义的`inputView`和`inputAccessoryView`。`UIInputView`提供了`UIInputViewStyleDefault`和`UIInputViewStyleKeyboard`俩种显示形式，第二种会自动设置背景为系统键盘的背景。","slug":"UIResponder中的inputView与inputAccessoryView","published":1,"updated":"2016-04-12T06:49:10.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9tg000f94suzd843xgq","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近刚给app添加了类似QQ中“@”消息人的功能，其中主要是重写了<code>UIResponder</code>中的<code>inputAccessoryView</code>这个成员属性。关于<code>inputView</code>和<code>inputAccessoryView</code>的介绍和使用，我首先推荐俩篇个人认为很不错的辅助文档：<a href=\"https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html\" target=\"_blank\" rel=\"external\">开发者文档—-Custom Views for Data Input</a>和<a href=\"http://derpturkey.com/uitextfield-docked-like-ios-messenger/\" target=\"_blank\" rel=\"external\">博客—-UITextField docked like iOS Messenger</a>。<br><a id=\"more\"></a></p>\n<h1 id=\"属性介绍\"><a href=\"#属性介绍\" class=\"headerlink\" title=\"属性介绍\"></a>属性介绍</h1><p><code>inputView</code>和<code>inputAccessoryView</code>是在<code>UIResponder</code>中定义的俩个<code>readonly</code>的属性。而且所有的UIKit中的控件都继承自<code>UIResponder</code>，定义这俩个属性，是为开发者改变系统键盘的视图提供便利。苹果SDK中提供了<code>UITextView</code>和<code>UITextField</code>俩种editor，而且都重定义了<code>inputView</code>和<code>inputAccessoryView</code>俩个属性为<code>readwrite</code>。</p>\n<p>此外，我们也可以在自己定义的UIView的子类中，重定义这俩个属性。按照官方文档的说法，当<code>inputView不</code>是nil,而且inputView所属的UIView成为第一响应者时，系统就不会显示出键盘，而是显示我们自定义的<code>inputView</code>的值；当<code>inputAccessoryView</code>不是nil,而且<code>inputAccessoryView</code>所属的UIView成为第一响应者时，系统会显示键盘，并且在键盘的顶部显示出我们定义的<code>inputAccessoryView</code>。</p>\n<h1 id=\"触发显示\"><a href=\"#触发显示\" class=\"headerlink\" title=\"触发显示\"></a>触发显示</h1><p>当我们点击一个UIView时，它就成为了第一响应者，我们还可以调用<code>becomeFirstResponder</code>让视图控件成为第一响应者。而在我们重定义<code>inputView</code>和<code>inputAccessoryView</code>的UIView中，我们也需要重写<code>canBecomeFirstResponder</code>这个方法，并且返回true，这样当我们的UIView成为第一响应者时，<code>inputAccessoryView</code>和<code>inputView</code>才会自动显示出来。</p>\n<h1 id=\"自定义显示\"><a href=\"#自定义显示\" class=\"headerlink\" title=\"自定义显示\"></a>自定义显示</h1><p>苹果SDK在iOS7中提供了<code>UIInputView</code>这个控件，并且在iOS8中提供了<code>UIInputViewController</code>这个视图控制器。这俩个是开发者可以很好地用来显示我们自定义的<code>inputView</code>和<code>inputAccessoryView</code>。<code>UIInputView</code>提供了<code>UIInputViewStyleDefault</code>和<code>UIInputViewStyleKeyboard</code>俩种显示形式，第二种会自动设置背景为系统键盘的背景。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近刚给app添加了类似QQ中“@”消息人的功能，其中主要是重写了<code>UIResponder</code>中的<code>inputAccessoryView</code>这个成员属性。关于<code>inputView</code>和<code>inputAccessoryView</code>的介绍和使用，我首先推荐俩篇个人认为很不错的辅助文档：<a href=\"https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html\">开发者文档—-Custom Views for Data Input</a>和<a href=\"http://derpturkey.com/uitextfield-docked-like-ios-messenger/\">博客—-UITextField docked like iOS Messenger</a>。<br>","more":"</p>\n<h1 id=\"属性介绍\"><a href=\"#属性介绍\" class=\"headerlink\" title=\"属性介绍\"></a>属性介绍</h1><p><code>inputView</code>和<code>inputAccessoryView</code>是在<code>UIResponder</code>中定义的俩个<code>readonly</code>的属性。而且所有的UIKit中的控件都继承自<code>UIResponder</code>，定义这俩个属性，是为开发者改变系统键盘的视图提供便利。苹果SDK中提供了<code>UITextView</code>和<code>UITextField</code>俩种editor，而且都重定义了<code>inputView</code>和<code>inputAccessoryView</code>俩个属性为<code>readwrite</code>。</p>\n<p>此外，我们也可以在自己定义的UIView的子类中，重定义这俩个属性。按照官方文档的说法，当<code>inputView不</code>是nil,而且inputView所属的UIView成为第一响应者时，系统就不会显示出键盘，而是显示我们自定义的<code>inputView</code>的值；当<code>inputAccessoryView</code>不是nil,而且<code>inputAccessoryView</code>所属的UIView成为第一响应者时，系统会显示键盘，并且在键盘的顶部显示出我们定义的<code>inputAccessoryView</code>。</p>\n<h1 id=\"触发显示\"><a href=\"#触发显示\" class=\"headerlink\" title=\"触发显示\"></a>触发显示</h1><p>当我们点击一个UIView时，它就成为了第一响应者，我们还可以调用<code>becomeFirstResponder</code>让视图控件成为第一响应者。而在我们重定义<code>inputView</code>和<code>inputAccessoryView</code>的UIView中，我们也需要重写<code>canBecomeFirstResponder</code>这个方法，并且返回true，这样当我们的UIView成为第一响应者时，<code>inputAccessoryView</code>和<code>inputView</code>才会自动显示出来。</p>\n<h1 id=\"自定义显示\"><a href=\"#自定义显示\" class=\"headerlink\" title=\"自定义显示\"></a>自定义显示</h1><p>苹果SDK在iOS7中提供了<code>UIInputView</code>这个控件，并且在iOS8中提供了<code>UIInputViewController</code>这个视图控制器。这俩个是开发者可以很好地用来显示我们自定义的<code>inputView</code>和<code>inputAccessoryView</code>。<code>UIInputView</code>提供了<code>UIInputViewStyleDefault</code>和<code>UIInputViewStyleKeyboard</code>俩种显示形式，第二种会自动设置背景为系统键盘的背景。</p>"},{"layout":"post","title":"iOS 8使用UIAlertController","date":"2015-08-27T16:00:00.000Z","description":"介绍UIAlertController的概念和使用注意","_content":"\n# 前言\n`UIAlertController`是iOS　8之后提供的一个继承自`UIViewController`的视图控制器，主要是修改了`UIAlertView`和`UIActionSheet`的显示以及处理逻辑，摒弃了旧形式，提供了更加强大的操作方法。它将`UIAlertView`和`UIActionSheet`整合到一起，并且添加了对`block`的支持。本篇文章我们就具体讲一下`UIAlertControlelr`的使用。\n<!-- more -->\n# 介绍\n`UIAlertController`作为`UIViewController`的子类，因此显示工作需要我们提供，而不像之前的`UIAlertView`和`UIActionSheet`单独作为一个视图,提供了显示的方法。`UIAlertController`提供了俩种形式:\n{% codeblock lang:objc %}\nUIAlertControllerStyleActionSheet\nUIAlertControllerStyleAlert\n{% endcodeblock %}\n上面这俩种形式，就应对了我们之前使用的`UIAlertView`和`UIActionSheet`。\n\n# UIAlertAction\n在`UIAlertController`中，一个事件就叫一个`UIAlertAction`的实例，这里面就是添加对block机制的支持。而`UIAlertController`就是通过添加`UIAlertAction`的实例来添加操作的。下面是添加方法：\n{% codeblock lang:objc %}\n- (void)addAction:(UIAlertAction *)action;\n{% endcodeblock %}\n\n而每一个`UIAlertAction`代表了一个操作，比如`Cancel`操作等。一个`UIAlertAction`有`title`,`style`属性，`style`属性是`UIAlertControllerStyle`类型的，这决定着是添加一个`UIAlertView`的操作，还是`UIActionSheet`的操作。实例初始化方法如下：\n{% codeblock lang:objc %}\n+ (instancetype)actionWithTitle:(nullable NSString *)title style:(UIAlertActionStyle)style handler:(void (^ __nullable)(UIAlertAction *action))handler;\n{% endcodeblock %}\n\n\n# 展示\n谈到`UIAlertController`的展示之前，我们必须先说一下`UIPresentationController`。`UIAlertController`与传统的`UIAlertView`,`UIActionSheet`最大不同之处在于，在大宽屏幕上是以`UIPopoverViewController`来显示的，首先推荐一篇比较全面的博客：[iOS8新特性 UIPresentationController](http://www.15yan.com/story/jlkJnPmVGzc/)。\n\n`UIPresentationController`主要是为开发者不用再手动计算视图的位置以及适配各种分辨率的屏幕而设计。在iOS 8以后，系统会自动匹配各种宽度的屏幕，而`UIPresentationController`就是提供了适配的一些操作。在`iPad`等大宽屏幕设备上，如果使用了`UIAlertController`，那么系统就会以`popoverPresentationController`的形式将视图弹出，所以此时，我们必须设置`popoverPresentationController`的`sourceView`，`sourceRect`或者是`barButtonItem`，这样系统才会根据我们的设置弹出popover视图。使用方法如下：\n{% codeblock lang:objc %}\n\n UIPopoverPresentationController *popover = alertController.popoverPresentationController;\n if (popover) {\n     popover.barButtonItem = self.navigationItem.rightBarButtonItem;\n }\n\n [self presentViewController:alertController animated:YEScompletion:^{\n     \n }];\n{% endcodeblock %}","source":"_posts/iOS 8使用UIAlertController.md","raw":"---\nlayout: post\ntitle: iOS 8使用UIAlertController\ndate: 2015-08-28\ndescription: \"介绍UIAlertController的概念和使用注意\"\ntags: [UIKit]\ncategories: [iOS]\n---\n\n# 前言\n`UIAlertController`是iOS　8之后提供的一个继承自`UIViewController`的视图控制器，主要是修改了`UIAlertView`和`UIActionSheet`的显示以及处理逻辑，摒弃了旧形式，提供了更加强大的操作方法。它将`UIAlertView`和`UIActionSheet`整合到一起，并且添加了对`block`的支持。本篇文章我们就具体讲一下`UIAlertControlelr`的使用。\n<!-- more -->\n# 介绍\n`UIAlertController`作为`UIViewController`的子类，因此显示工作需要我们提供，而不像之前的`UIAlertView`和`UIActionSheet`单独作为一个视图,提供了显示的方法。`UIAlertController`提供了俩种形式:\n{% codeblock lang:objc %}\nUIAlertControllerStyleActionSheet\nUIAlertControllerStyleAlert\n{% endcodeblock %}\n上面这俩种形式，就应对了我们之前使用的`UIAlertView`和`UIActionSheet`。\n\n# UIAlertAction\n在`UIAlertController`中，一个事件就叫一个`UIAlertAction`的实例，这里面就是添加对block机制的支持。而`UIAlertController`就是通过添加`UIAlertAction`的实例来添加操作的。下面是添加方法：\n{% codeblock lang:objc %}\n- (void)addAction:(UIAlertAction *)action;\n{% endcodeblock %}\n\n而每一个`UIAlertAction`代表了一个操作，比如`Cancel`操作等。一个`UIAlertAction`有`title`,`style`属性，`style`属性是`UIAlertControllerStyle`类型的，这决定着是添加一个`UIAlertView`的操作，还是`UIActionSheet`的操作。实例初始化方法如下：\n{% codeblock lang:objc %}\n+ (instancetype)actionWithTitle:(nullable NSString *)title style:(UIAlertActionStyle)style handler:(void (^ __nullable)(UIAlertAction *action))handler;\n{% endcodeblock %}\n\n\n# 展示\n谈到`UIAlertController`的展示之前，我们必须先说一下`UIPresentationController`。`UIAlertController`与传统的`UIAlertView`,`UIActionSheet`最大不同之处在于，在大宽屏幕上是以`UIPopoverViewController`来显示的，首先推荐一篇比较全面的博客：[iOS8新特性 UIPresentationController](http://www.15yan.com/story/jlkJnPmVGzc/)。\n\n`UIPresentationController`主要是为开发者不用再手动计算视图的位置以及适配各种分辨率的屏幕而设计。在iOS 8以后，系统会自动匹配各种宽度的屏幕，而`UIPresentationController`就是提供了适配的一些操作。在`iPad`等大宽屏幕设备上，如果使用了`UIAlertController`，那么系统就会以`popoverPresentationController`的形式将视图弹出，所以此时，我们必须设置`popoverPresentationController`的`sourceView`，`sourceRect`或者是`barButtonItem`，这样系统才会根据我们的设置弹出popover视图。使用方法如下：\n{% codeblock lang:objc %}\n\n UIPopoverPresentationController *popover = alertController.popoverPresentationController;\n if (popover) {\n     popover.barButtonItem = self.navigationItem.rightBarButtonItem;\n }\n\n [self presentViewController:alertController animated:YEScompletion:^{\n     \n }];\n{% endcodeblock %}","slug":"iOS 8使用UIAlertController","published":1,"updated":"2016-04-12T06:49:31.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9tl000j94su8qd6fesq","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p><code>UIAlertController</code>是iOS　8之后提供的一个继承自<code>UIViewController</code>的视图控制器，主要是修改了<code>UIAlertView</code>和<code>UIActionSheet</code>的显示以及处理逻辑，摒弃了旧形式，提供了更加强大的操作方法。它将<code>UIAlertView</code>和<code>UIActionSheet</code>整合到一起，并且添加了对<code>block</code>的支持。本篇文章我们就具体讲一下<code>UIAlertControlelr</code>的使用。<br><a id=\"more\"></a></p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><code>UIAlertController</code>作为<code>UIViewController</code>的子类，因此显示工作需要我们提供，而不像之前的<code>UIAlertView</code>和<code>UIActionSheet</code>单独作为一个视图,提供了显示的方法。<code>UIAlertController</code>提供了俩种形式:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIAlertControllerStyleActionSheet</span></span><br><span class=\"line\"><span class=\"built_in\">UIAlertControllerStyleAlert</span></span><br></pre></td></tr></table></figure><br>上面这俩种形式，就应对了我们之前使用的<code>UIAlertView</code>和<code>UIActionSheet</code>。</p>\n<h1 id=\"UIAlertAction\"><a href=\"#UIAlertAction\" class=\"headerlink\" title=\"UIAlertAction\"></a>UIAlertAction</h1><p>在<code>UIAlertController</code>中，一个事件就叫一个<code>UIAlertAction</code>的实例，这里面就是添加对block机制的支持。而<code>UIAlertController</code>就是通过添加<code>UIAlertAction</code>的实例来添加操作的。下面是添加方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)addAction:(<span class=\"built_in\">UIAlertAction</span> *)action;</span><br></pre></td></tr></table></figure></p>\n<p>而每一个<code>UIAlertAction</code>代表了一个操作，比如<code>Cancel</code>操作等。一个<code>UIAlertAction</code>有<code>title</code>,<code>style</code>属性，<code>style</code>属性是<code>UIAlertControllerStyle</code>类型的，这决定着是添加一个<code>UIAlertView</code>的操作，还是<code>UIActionSheet</code>的操作。实例初始化方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)actionWithTitle:(nullable <span class=\"built_in\">NSString</span> *)title style:(<span class=\"built_in\">UIAlertActionStyle</span>)style handler:(<span class=\"keyword\">void</span> (^ __nullable)(<span class=\"built_in\">UIAlertAction</span> *action))handler;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"展示\"><a href=\"#展示\" class=\"headerlink\" title=\"展示\"></a>展示</h1><p>谈到<code>UIAlertController</code>的展示之前，我们必须先说一下<code>UIPresentationController</code>。<code>UIAlertController</code>与传统的<code>UIAlertView</code>,<code>UIActionSheet</code>最大不同之处在于，在大宽屏幕上是以<code>UIPopoverViewController</code>来显示的，首先推荐一篇比较全面的博客：<a href=\"http://www.15yan.com/story/jlkJnPmVGzc/\" target=\"_blank\" rel=\"external\">iOS8新特性 UIPresentationController</a>。</p>\n<p><code>UIPresentationController</code>主要是为开发者不用再手动计算视图的位置以及适配各种分辨率的屏幕而设计。在iOS 8以后，系统会自动匹配各种宽度的屏幕，而<code>UIPresentationController</code>就是提供了适配的一些操作。在<code>iPad</code>等大宽屏幕设备上，如果使用了<code>UIAlertController</code>，那么系统就会以<code>popoverPresentationController</code>的形式将视图弹出，所以此时，我们必须设置<code>popoverPresentationController</code>的<code>sourceView</code>，<code>sourceRect</code>或者是<code>barButtonItem</code>，这样系统才会根据我们的设置弹出popover视图。使用方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIPopoverPresentationController</span> *popover = alertController.popoverPresentationController;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (popover) &#123;</span><br><span class=\"line\">    popover.barButtonItem = <span class=\"keyword\">self</span>.navigationItem.rightBarButtonItem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">self</span> presentViewController:alertController animated:YEScompletion:^&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p><code>UIAlertController</code>是iOS　8之后提供的一个继承自<code>UIViewController</code>的视图控制器，主要是修改了<code>UIAlertView</code>和<code>UIActionSheet</code>的显示以及处理逻辑，摒弃了旧形式，提供了更加强大的操作方法。它将<code>UIAlertView</code>和<code>UIActionSheet</code>整合到一起，并且添加了对<code>block</code>的支持。本篇文章我们就具体讲一下<code>UIAlertControlelr</code>的使用。<br>","more":"</p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><code>UIAlertController</code>作为<code>UIViewController</code>的子类，因此显示工作需要我们提供，而不像之前的<code>UIAlertView</code>和<code>UIActionSheet</code>单独作为一个视图,提供了显示的方法。<code>UIAlertController</code>提供了俩种形式:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIAlertControllerStyleActionSheet</span></span><br><span class=\"line\"><span class=\"built_in\">UIAlertControllerStyleAlert</span></span><br></pre></td></tr></table></figure><br>上面这俩种形式，就应对了我们之前使用的<code>UIAlertView</code>和<code>UIActionSheet</code>。</p>\n<h1 id=\"UIAlertAction\"><a href=\"#UIAlertAction\" class=\"headerlink\" title=\"UIAlertAction\"></a>UIAlertAction</h1><p>在<code>UIAlertController</code>中，一个事件就叫一个<code>UIAlertAction</code>的实例，这里面就是添加对block机制的支持。而<code>UIAlertController</code>就是通过添加<code>UIAlertAction</code>的实例来添加操作的。下面是添加方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)addAction:(<span class=\"built_in\">UIAlertAction</span> *)action;</span><br></pre></td></tr></table></figure></p>\n<p>而每一个<code>UIAlertAction</code>代表了一个操作，比如<code>Cancel</code>操作等。一个<code>UIAlertAction</code>有<code>title</code>,<code>style</code>属性，<code>style</code>属性是<code>UIAlertControllerStyle</code>类型的，这决定着是添加一个<code>UIAlertView</code>的操作，还是<code>UIActionSheet</code>的操作。实例初始化方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)actionWithTitle:(nullable <span class=\"built_in\">NSString</span> *)title style:(<span class=\"built_in\">UIAlertActionStyle</span>)style handler:(<span class=\"keyword\">void</span> (^ __nullable)(<span class=\"built_in\">UIAlertAction</span> *action))handler;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"展示\"><a href=\"#展示\" class=\"headerlink\" title=\"展示\"></a>展示</h1><p>谈到<code>UIAlertController</code>的展示之前，我们必须先说一下<code>UIPresentationController</code>。<code>UIAlertController</code>与传统的<code>UIAlertView</code>,<code>UIActionSheet</code>最大不同之处在于，在大宽屏幕上是以<code>UIPopoverViewController</code>来显示的，首先推荐一篇比较全面的博客：<a href=\"http://www.15yan.com/story/jlkJnPmVGzc/\">iOS8新特性 UIPresentationController</a>。</p>\n<p><code>UIPresentationController</code>主要是为开发者不用再手动计算视图的位置以及适配各种分辨率的屏幕而设计。在iOS 8以后，系统会自动匹配各种宽度的屏幕，而<code>UIPresentationController</code>就是提供了适配的一些操作。在<code>iPad</code>等大宽屏幕设备上，如果使用了<code>UIAlertController</code>，那么系统就会以<code>popoverPresentationController</code>的形式将视图弹出，所以此时，我们必须设置<code>popoverPresentationController</code>的<code>sourceView</code>，<code>sourceRect</code>或者是<code>barButtonItem</code>，这样系统才会根据我们的设置弹出popover视图。使用方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIPopoverPresentationController</span> *popover = alertController.popoverPresentationController;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (popover) &#123;</span><br><span class=\"line\">    popover.barButtonItem = <span class=\"keyword\">self</span>.navigationItem.rightBarButtonItem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">self</span> presentViewController:alertController animated:YEScompletion:^&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>"},{"layout":"post","title":"UIViewController解耦---浅析Three20架构","date":"2016-01-12T16:00:00.000Z","description":"根据经典的MVC、MVVM架构解析Three20中的架构模式","_content":"\n# 前言\n\nThree20是一款由Facebook开源的框架，由大神[Joe Hewitt](https://en.wikipedia.org/wiki/Joe_Hewitt_(programmer))创建，曾经风靡一时，被无数开发者观阅。Three20主要提供了UI模块、Network模块以及相关的一些工具。Three20自开源之初就褒贬不一，有人称赞它强大的UI工具，也有人在诟病Three20各个模块之间的耦合度太高，而且更多人在抱怨Three20极少的开发文档，我想这些大概也是Three20在苹果发布iOS6之后就停止了更新维护的原因吧。大神[Joe Hewitt](https://en.wikipedia.org/wiki/Joe_Hewitt_(programmer))创建的在Github上的源码早已删除，目前只有少数人在GitHub上为自己的项目维护。而我也是有幸在某个项目中见识到了曾经耳闻，却未目睹的Three20框架，因此才有了这篇文章。\n<!-- more -->\n# 架构\n\n最近大家都在讨论MVC、MVVM以及MVP三种在移动端开发中常用到的架构模式，究竟是哪种架构最强大，最适合移动开发者使用。这里笔者也阐述一下个人意见，有句方言叫“树挪死，人挪活”，个人认为，架构是死的，开发者是活的，我们不需要局限于哪一种架构的模式之下，看到大家都在用MVVM，于是花大成本将MVC架构模式的老项目重构成了MVVM架构，这种重构个人看来其实并没有意义。更多的架构话题就不想在这里讨论了，笔者推荐几篇大神们关于架构的见解。\n\n* [被误解的 MVC 和被神化的 MVVM](http://blog.devtang.com/blog/2015/11/02/mvc-and-mvvm/)\n\n    这是一篇被早已被翻烂了的文章，起码我个人反复阅读了数次，由家喻户晓的**[唐巧](http://blog.devtang.com)**大神编写。\n\n* [iOS 架构模式--解密 MVC，MVP，MVVM以及VIPER架构](http://www.cocoachina.com/ios/20160108/14916.html)\n\n    最近在Cocoa China上发表的一篇译文，笔者之前看过俩次原文，讲的比较形象。\n\n* [MVC，MVP 和 MVVM 的图示](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)\n\n    大神**[阮一峰](http://www.ruanyifeng.com/about.html)**的博文，以图形展示的方式使得各层结构更加清晰明了。\n\n* [猿题库 iOS 客户端架构设计](http://gracelancy.com/blog/2016/01/06/ape-ios-arch-design/)\n\n    `猿题库 iOS客户端`开发者**[蓝晨钰](http://gracelancy.com/about/)**的博文，以实际项目`猿题库`详解了架构设计\n\n# UIViewController瘦身\n\n架构模式并不是限制思维，相反应该是发散思维，我们并不应该为了架构而架构，架构应该是服务于我们的代码逻辑，打造更具有扩展性和健壮的代码结构。就比如，大多数开发者都会遇到一个同样的问题，随着项目一天天的壮大，功能越来越多，需求越来越多，而我们的UIViewController也变得越来越臃肿。在上面推荐的博文中，笔者们都或多或少的阐述了如何打造更轻量级的UIViewController，大都列举了一些共性策略:\n\n* 将一个界面中的数据获取抽象成一个类，这里面细分一下，包括了网络请求和数据库缓存，我们可以针对这俩点再次封装成俩个类。\n\n* 将一个界面中的数据处理逻辑抽象成一个类，这里面包含了各种数据转换和算法逻辑，比如数据检索，数据遍历等。\n\n* 将一个界面中数据传递到UIView视图的过程抽象成一个模型类，这里面就包含了对应到UIView视图的每一个数据的传递，比如icon图标，title标题，comment评论内容等。\n\n* 将一个界面中所有展示的UIView视图的添加和渲染抽象成一个类，这里包含了添加控件，自定义动画等。这个对视图的封装仍然可以细分，每一个自定义控件都可以单独封装，因为这样可以完美的在其他的UIViewController达到复用的目的。\n\n而完成了上述抽象之后，就会发现我们需要在UIViewController中完成的工作仅仅是处理视图交互逻辑和数据传递逻辑，这样我们的UIViewController就比较容易维护了。\n\n# Three20架构\n\n每一种框架的兴起和衰落都有其相应的时势和必然性。虽然Three20饱受诟病，早已跌落神坛，但是它的存在是有一定道理的。虽然它在模块之间的耦合度较高，但是个人认为它对UIViewController的抽象和封装也是一个非常好的借鉴。在这里以Three20中对`TTTableViewController`的解耦为例，先上图看一下`TTTableViewController`包含的模块：\n\n{% img /images/Three20.png %}\n\n这里根据上面的结构图具体地解释一下解耦的设计方式。**`TTTableViewController`**的设计遵从了经典的**`MVC`**模式，**`TTModel`**负责数据的获取和处理逻辑，**`TTTableView`**负责视图展示,**`TTTableViewController`**负责**`TTModel`**与**`TTTableView`**之间的通信逻辑和界面的控件添加渲染。而**`TTTableViewController`**在顺应了**`MVC`**模式的前提下，也做了一些扩展，它将**`TTTableViewDatasource`**接收数据传递的逻辑抽象出来封装成了**`TTTableItem`**。而**`TTTableItem`**就是关联**`TTModel`**传递数据的过程，因而我们也可以把这一层称作是**`MVVM`**架构模式中的**`ViewModel`**\n\n根据上面的图示，我们可以看到获取数据的逻辑都在**`TTModel`**中，而且界面控件添加和动画渲染这些逻辑仍然都在**`TTTableViewController`**中，因此我根据大神们的一些建议，对项目中的Three20进行了一下强化，先上图看一下增加的结构：\n\n{% img /images/Three20_Advance.png %}\n\n可以清晰地看到，我将**`TTModel`**中处理缓存数据的逻辑抽象出来，单独放在了**`TTCacheModel`**中，此外还将**`TTTableViewController`**中添加控件和渲染动画的逻辑抽象出来，放到了**`TTViewRender`**中，这样**`TTTableViewController`**就只关心界面交互以及**`TTModel`**和**`TTTableItem`**之间的数据传递逻辑。","source":"_posts/UIViewController解耦---浅析Three20架构.md","raw":"---\nlayout: post\ntitle: UIViewController解耦---浅析Three20架构\ndate: 2016-01-13\ndescription: \"根据经典的MVC、MVVM架构解析Three20中的架构模式\"\ntags: [架构]\ncategories: [开发心得]\n---\n\n# 前言\n\nThree20是一款由Facebook开源的框架，由大神[Joe Hewitt](https://en.wikipedia.org/wiki/Joe_Hewitt_(programmer))创建，曾经风靡一时，被无数开发者观阅。Three20主要提供了UI模块、Network模块以及相关的一些工具。Three20自开源之初就褒贬不一，有人称赞它强大的UI工具，也有人在诟病Three20各个模块之间的耦合度太高，而且更多人在抱怨Three20极少的开发文档，我想这些大概也是Three20在苹果发布iOS6之后就停止了更新维护的原因吧。大神[Joe Hewitt](https://en.wikipedia.org/wiki/Joe_Hewitt_(programmer))创建的在Github上的源码早已删除，目前只有少数人在GitHub上为自己的项目维护。而我也是有幸在某个项目中见识到了曾经耳闻，却未目睹的Three20框架，因此才有了这篇文章。\n<!-- more -->\n# 架构\n\n最近大家都在讨论MVC、MVVM以及MVP三种在移动端开发中常用到的架构模式，究竟是哪种架构最强大，最适合移动开发者使用。这里笔者也阐述一下个人意见，有句方言叫“树挪死，人挪活”，个人认为，架构是死的，开发者是活的，我们不需要局限于哪一种架构的模式之下，看到大家都在用MVVM，于是花大成本将MVC架构模式的老项目重构成了MVVM架构，这种重构个人看来其实并没有意义。更多的架构话题就不想在这里讨论了，笔者推荐几篇大神们关于架构的见解。\n\n* [被误解的 MVC 和被神化的 MVVM](http://blog.devtang.com/blog/2015/11/02/mvc-and-mvvm/)\n\n    这是一篇被早已被翻烂了的文章，起码我个人反复阅读了数次，由家喻户晓的**[唐巧](http://blog.devtang.com)**大神编写。\n\n* [iOS 架构模式--解密 MVC，MVP，MVVM以及VIPER架构](http://www.cocoachina.com/ios/20160108/14916.html)\n\n    最近在Cocoa China上发表的一篇译文，笔者之前看过俩次原文，讲的比较形象。\n\n* [MVC，MVP 和 MVVM 的图示](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)\n\n    大神**[阮一峰](http://www.ruanyifeng.com/about.html)**的博文，以图形展示的方式使得各层结构更加清晰明了。\n\n* [猿题库 iOS 客户端架构设计](http://gracelancy.com/blog/2016/01/06/ape-ios-arch-design/)\n\n    `猿题库 iOS客户端`开发者**[蓝晨钰](http://gracelancy.com/about/)**的博文，以实际项目`猿题库`详解了架构设计\n\n# UIViewController瘦身\n\n架构模式并不是限制思维，相反应该是发散思维，我们并不应该为了架构而架构，架构应该是服务于我们的代码逻辑，打造更具有扩展性和健壮的代码结构。就比如，大多数开发者都会遇到一个同样的问题，随着项目一天天的壮大，功能越来越多，需求越来越多，而我们的UIViewController也变得越来越臃肿。在上面推荐的博文中，笔者们都或多或少的阐述了如何打造更轻量级的UIViewController，大都列举了一些共性策略:\n\n* 将一个界面中的数据获取抽象成一个类，这里面细分一下，包括了网络请求和数据库缓存，我们可以针对这俩点再次封装成俩个类。\n\n* 将一个界面中的数据处理逻辑抽象成一个类，这里面包含了各种数据转换和算法逻辑，比如数据检索，数据遍历等。\n\n* 将一个界面中数据传递到UIView视图的过程抽象成一个模型类，这里面就包含了对应到UIView视图的每一个数据的传递，比如icon图标，title标题，comment评论内容等。\n\n* 将一个界面中所有展示的UIView视图的添加和渲染抽象成一个类，这里包含了添加控件，自定义动画等。这个对视图的封装仍然可以细分，每一个自定义控件都可以单独封装，因为这样可以完美的在其他的UIViewController达到复用的目的。\n\n而完成了上述抽象之后，就会发现我们需要在UIViewController中完成的工作仅仅是处理视图交互逻辑和数据传递逻辑，这样我们的UIViewController就比较容易维护了。\n\n# Three20架构\n\n每一种框架的兴起和衰落都有其相应的时势和必然性。虽然Three20饱受诟病，早已跌落神坛，但是它的存在是有一定道理的。虽然它在模块之间的耦合度较高，但是个人认为它对UIViewController的抽象和封装也是一个非常好的借鉴。在这里以Three20中对`TTTableViewController`的解耦为例，先上图看一下`TTTableViewController`包含的模块：\n\n{% img /images/Three20.png %}\n\n这里根据上面的结构图具体地解释一下解耦的设计方式。**`TTTableViewController`**的设计遵从了经典的**`MVC`**模式，**`TTModel`**负责数据的获取和处理逻辑，**`TTTableView`**负责视图展示,**`TTTableViewController`**负责**`TTModel`**与**`TTTableView`**之间的通信逻辑和界面的控件添加渲染。而**`TTTableViewController`**在顺应了**`MVC`**模式的前提下，也做了一些扩展，它将**`TTTableViewDatasource`**接收数据传递的逻辑抽象出来封装成了**`TTTableItem`**。而**`TTTableItem`**就是关联**`TTModel`**传递数据的过程，因而我们也可以把这一层称作是**`MVVM`**架构模式中的**`ViewModel`**\n\n根据上面的图示，我们可以看到获取数据的逻辑都在**`TTModel`**中，而且界面控件添加和动画渲染这些逻辑仍然都在**`TTTableViewController`**中，因此我根据大神们的一些建议，对项目中的Three20进行了一下强化，先上图看一下增加的结构：\n\n{% img /images/Three20_Advance.png %}\n\n可以清晰地看到，我将**`TTModel`**中处理缓存数据的逻辑抽象出来，单独放在了**`TTCacheModel`**中，此外还将**`TTTableViewController`**中添加控件和渲染动画的逻辑抽象出来，放到了**`TTViewRender`**中，这样**`TTTableViewController`**就只关心界面交互以及**`TTModel`**和**`TTTableItem`**之间的数据传递逻辑。","slug":"UIViewController解耦---浅析Three20架构","published":1,"updated":"2016-04-12T06:53:45.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9tn000m94su9f0sem98","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Three20是一款由Facebook开源的框架，由大神<a href=\"https://en.wikipedia.org/wiki/Joe_Hewitt_(programmer\" target=\"_blank\" rel=\"external\">Joe Hewitt</a>)创建，曾经风靡一时，被无数开发者观阅。Three20主要提供了UI模块、Network模块以及相关的一些工具。Three20自开源之初就褒贬不一，有人称赞它强大的UI工具，也有人在诟病Three20各个模块之间的耦合度太高，而且更多人在抱怨Three20极少的开发文档，我想这些大概也是Three20在苹果发布iOS6之后就停止了更新维护的原因吧。大神<a href=\"https://en.wikipedia.org/wiki/Joe_Hewitt_(programmer\" target=\"_blank\" rel=\"external\">Joe Hewitt</a>)创建的在Github上的源码早已删除，目前只有少数人在GitHub上为自己的项目维护。而我也是有幸在某个项目中见识到了曾经耳闻，却未目睹的Three20框架，因此才有了这篇文章。<br><a id=\"more\"></a></p>\n<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><p>最近大家都在讨论MVC、MVVM以及MVP三种在移动端开发中常用到的架构模式，究竟是哪种架构最强大，最适合移动开发者使用。这里笔者也阐述一下个人意见，有句方言叫“树挪死，人挪活”，个人认为，架构是死的，开发者是活的，我们不需要局限于哪一种架构的模式之下，看到大家都在用MVVM，于是花大成本将MVC架构模式的老项目重构成了MVVM架构，这种重构个人看来其实并没有意义。更多的架构话题就不想在这里讨论了，笔者推荐几篇大神们关于架构的见解。</p>\n<ul>\n<li><p><a href=\"http://blog.devtang.com/blog/2015/11/02/mvc-and-mvvm/\" target=\"_blank\" rel=\"external\">被误解的 MVC 和被神化的 MVVM</a></p>\n<p>  这是一篇被早已被翻烂了的文章，起码我个人反复阅读了数次，由家喻户晓的<strong><a href=\"http://blog.devtang.com\" target=\"_blank\" rel=\"external\">唐巧</a></strong>大神编写。</p>\n</li>\n<li><p><a href=\"http://www.cocoachina.com/ios/20160108/14916.html\" target=\"_blank\" rel=\"external\">iOS 架构模式–解密 MVC，MVP，MVVM以及VIPER架构</a></p>\n<p>  最近在Cocoa China上发表的一篇译文，笔者之前看过俩次原文，讲的比较形象。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\" target=\"_blank\" rel=\"external\">MVC，MVP 和 MVVM 的图示</a></p>\n<p>  大神<strong><a href=\"http://www.ruanyifeng.com/about.html\" target=\"_blank\" rel=\"external\">阮一峰</a></strong>的博文，以图形展示的方式使得各层结构更加清晰明了。</p>\n</li>\n<li><p><a href=\"http://gracelancy.com/blog/2016/01/06/ape-ios-arch-design/\" target=\"_blank\" rel=\"external\">猿题库 iOS 客户端架构设计</a></p>\n<p>  <code>猿题库 iOS客户端</code>开发者<strong><a href=\"http://gracelancy.com/about/\" target=\"_blank\" rel=\"external\">蓝晨钰</a></strong>的博文，以实际项目<code>猿题库</code>详解了架构设计</p>\n</li>\n</ul>\n<h1 id=\"UIViewController瘦身\"><a href=\"#UIViewController瘦身\" class=\"headerlink\" title=\"UIViewController瘦身\"></a>UIViewController瘦身</h1><p>架构模式并不是限制思维，相反应该是发散思维，我们并不应该为了架构而架构，架构应该是服务于我们的代码逻辑，打造更具有扩展性和健壮的代码结构。就比如，大多数开发者都会遇到一个同样的问题，随着项目一天天的壮大，功能越来越多，需求越来越多，而我们的UIViewController也变得越来越臃肿。在上面推荐的博文中，笔者们都或多或少的阐述了如何打造更轻量级的UIViewController，大都列举了一些共性策略:</p>\n<ul>\n<li><p>将一个界面中的数据获取抽象成一个类，这里面细分一下，包括了网络请求和数据库缓存，我们可以针对这俩点再次封装成俩个类。</p>\n</li>\n<li><p>将一个界面中的数据处理逻辑抽象成一个类，这里面包含了各种数据转换和算法逻辑，比如数据检索，数据遍历等。</p>\n</li>\n<li><p>将一个界面中数据传递到UIView视图的过程抽象成一个模型类，这里面就包含了对应到UIView视图的每一个数据的传递，比如icon图标，title标题，comment评论内容等。</p>\n</li>\n<li><p>将一个界面中所有展示的UIView视图的添加和渲染抽象成一个类，这里包含了添加控件，自定义动画等。这个对视图的封装仍然可以细分，每一个自定义控件都可以单独封装，因为这样可以完美的在其他的UIViewController达到复用的目的。</p>\n</li>\n</ul>\n<p>而完成了上述抽象之后，就会发现我们需要在UIViewController中完成的工作仅仅是处理视图交互逻辑和数据传递逻辑，这样我们的UIViewController就比较容易维护了。</p>\n<h1 id=\"Three20架构\"><a href=\"#Three20架构\" class=\"headerlink\" title=\"Three20架构\"></a>Three20架构</h1><p>每一种框架的兴起和衰落都有其相应的时势和必然性。虽然Three20饱受诟病，早已跌落神坛，但是它的存在是有一定道理的。虽然它在模块之间的耦合度较高，但是个人认为它对UIViewController的抽象和封装也是一个非常好的借鉴。在这里以Three20中对<code>TTTableViewController</code>的解耦为例，先上图看一下<code>TTTableViewController</code>包含的模块：</p>\n<img src=\"/images/Three20.png\">\n<p>这里根据上面的结构图具体地解释一下解耦的设计方式。<strong><code>TTTableViewController</code></strong>的设计遵从了经典的<strong><code>MVC</code></strong>模式，<strong><code>TTModel</code></strong>负责数据的获取和处理逻辑，<strong><code>TTTableView</code></strong>负责视图展示,<strong><code>TTTableViewController</code></strong>负责<strong><code>TTModel</code></strong>与<strong><code>TTTableView</code></strong>之间的通信逻辑和界面的控件添加渲染。而<strong><code>TTTableViewController</code></strong>在顺应了<strong><code>MVC</code></strong>模式的前提下，也做了一些扩展，它将<strong><code>TTTableViewDatasource</code></strong>接收数据传递的逻辑抽象出来封装成了<strong><code>TTTableItem</code></strong>。而<strong><code>TTTableItem</code></strong>就是关联<strong><code>TTModel</code></strong>传递数据的过程，因而我们也可以把这一层称作是<strong><code>MVVM</code></strong>架构模式中的<strong><code>ViewModel</code></strong></p>\n<p>根据上面的图示，我们可以看到获取数据的逻辑都在<strong><code>TTModel</code></strong>中，而且界面控件添加和动画渲染这些逻辑仍然都在<strong><code>TTTableViewController</code></strong>中，因此我根据大神们的一些建议，对项目中的Three20进行了一下强化，先上图看一下增加的结构：</p>\n<img src=\"/images/Three20_Advance.png\">\n<p>可以清晰地看到，我将<strong><code>TTModel</code></strong>中处理缓存数据的逻辑抽象出来，单独放在了<strong><code>TTCacheModel</code></strong>中，此外还将<strong><code>TTTableViewController</code></strong>中添加控件和渲染动画的逻辑抽象出来，放到了<strong><code>TTViewRender</code></strong>中，这样<strong><code>TTTableViewController</code></strong>就只关心界面交互以及<strong><code>TTModel</code></strong>和<strong><code>TTTableItem</code></strong>之间的数据传递逻辑。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Three20是一款由Facebook开源的框架，由大神<a href=\"https://en.wikipedia.org/wiki/Joe_Hewitt_(programmer\">Joe Hewitt</a>)创建，曾经风靡一时，被无数开发者观阅。Three20主要提供了UI模块、Network模块以及相关的一些工具。Three20自开源之初就褒贬不一，有人称赞它强大的UI工具，也有人在诟病Three20各个模块之间的耦合度太高，而且更多人在抱怨Three20极少的开发文档，我想这些大概也是Three20在苹果发布iOS6之后就停止了更新维护的原因吧。大神<a href=\"https://en.wikipedia.org/wiki/Joe_Hewitt_(programmer\">Joe Hewitt</a>)创建的在Github上的源码早已删除，目前只有少数人在GitHub上为自己的项目维护。而我也是有幸在某个项目中见识到了曾经耳闻，却未目睹的Three20框架，因此才有了这篇文章。<br>","more":"</p>\n<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><p>最近大家都在讨论MVC、MVVM以及MVP三种在移动端开发中常用到的架构模式，究竟是哪种架构最强大，最适合移动开发者使用。这里笔者也阐述一下个人意见，有句方言叫“树挪死，人挪活”，个人认为，架构是死的，开发者是活的，我们不需要局限于哪一种架构的模式之下，看到大家都在用MVVM，于是花大成本将MVC架构模式的老项目重构成了MVVM架构，这种重构个人看来其实并没有意义。更多的架构话题就不想在这里讨论了，笔者推荐几篇大神们关于架构的见解。</p>\n<ul>\n<li><p><a href=\"http://blog.devtang.com/blog/2015/11/02/mvc-and-mvvm/\">被误解的 MVC 和被神化的 MVVM</a></p>\n<p>  这是一篇被早已被翻烂了的文章，起码我个人反复阅读了数次，由家喻户晓的<strong><a href=\"http://blog.devtang.com\">唐巧</a></strong>大神编写。</p>\n</li>\n<li><p><a href=\"http://www.cocoachina.com/ios/20160108/14916.html\">iOS 架构模式–解密 MVC，MVP，MVVM以及VIPER架构</a></p>\n<p>  最近在Cocoa China上发表的一篇译文，笔者之前看过俩次原文，讲的比较形象。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\">MVC，MVP 和 MVVM 的图示</a></p>\n<p>  大神<strong><a href=\"http://www.ruanyifeng.com/about.html\">阮一峰</a></strong>的博文，以图形展示的方式使得各层结构更加清晰明了。</p>\n</li>\n<li><p><a href=\"http://gracelancy.com/blog/2016/01/06/ape-ios-arch-design/\">猿题库 iOS 客户端架构设计</a></p>\n<p>  <code>猿题库 iOS客户端</code>开发者<strong><a href=\"http://gracelancy.com/about/\">蓝晨钰</a></strong>的博文，以实际项目<code>猿题库</code>详解了架构设计</p>\n</li>\n</ul>\n<h1 id=\"UIViewController瘦身\"><a href=\"#UIViewController瘦身\" class=\"headerlink\" title=\"UIViewController瘦身\"></a>UIViewController瘦身</h1><p>架构模式并不是限制思维，相反应该是发散思维，我们并不应该为了架构而架构，架构应该是服务于我们的代码逻辑，打造更具有扩展性和健壮的代码结构。就比如，大多数开发者都会遇到一个同样的问题，随着项目一天天的壮大，功能越来越多，需求越来越多，而我们的UIViewController也变得越来越臃肿。在上面推荐的博文中，笔者们都或多或少的阐述了如何打造更轻量级的UIViewController，大都列举了一些共性策略:</p>\n<ul>\n<li><p>将一个界面中的数据获取抽象成一个类，这里面细分一下，包括了网络请求和数据库缓存，我们可以针对这俩点再次封装成俩个类。</p>\n</li>\n<li><p>将一个界面中的数据处理逻辑抽象成一个类，这里面包含了各种数据转换和算法逻辑，比如数据检索，数据遍历等。</p>\n</li>\n<li><p>将一个界面中数据传递到UIView视图的过程抽象成一个模型类，这里面就包含了对应到UIView视图的每一个数据的传递，比如icon图标，title标题，comment评论内容等。</p>\n</li>\n<li><p>将一个界面中所有展示的UIView视图的添加和渲染抽象成一个类，这里包含了添加控件，自定义动画等。这个对视图的封装仍然可以细分，每一个自定义控件都可以单独封装，因为这样可以完美的在其他的UIViewController达到复用的目的。</p>\n</li>\n</ul>\n<p>而完成了上述抽象之后，就会发现我们需要在UIViewController中完成的工作仅仅是处理视图交互逻辑和数据传递逻辑，这样我们的UIViewController就比较容易维护了。</p>\n<h1 id=\"Three20架构\"><a href=\"#Three20架构\" class=\"headerlink\" title=\"Three20架构\"></a>Three20架构</h1><p>每一种框架的兴起和衰落都有其相应的时势和必然性。虽然Three20饱受诟病，早已跌落神坛，但是它的存在是有一定道理的。虽然它在模块之间的耦合度较高，但是个人认为它对UIViewController的抽象和封装也是一个非常好的借鉴。在这里以Three20中对<code>TTTableViewController</code>的解耦为例，先上图看一下<code>TTTableViewController</code>包含的模块：</p>\n<img src=\"/images/Three20.png\">\n<p>这里根据上面的结构图具体地解释一下解耦的设计方式。<strong><code>TTTableViewController</code></strong>的设计遵从了经典的<strong><code>MVC</code></strong>模式，<strong><code>TTModel</code></strong>负责数据的获取和处理逻辑，<strong><code>TTTableView</code></strong>负责视图展示,<strong><code>TTTableViewController</code></strong>负责<strong><code>TTModel</code></strong>与<strong><code>TTTableView</code></strong>之间的通信逻辑和界面的控件添加渲染。而<strong><code>TTTableViewController</code></strong>在顺应了<strong><code>MVC</code></strong>模式的前提下，也做了一些扩展，它将<strong><code>TTTableViewDatasource</code></strong>接收数据传递的逻辑抽象出来封装成了<strong><code>TTTableItem</code></strong>。而<strong><code>TTTableItem</code></strong>就是关联<strong><code>TTModel</code></strong>传递数据的过程，因而我们也可以把这一层称作是<strong><code>MVVM</code></strong>架构模式中的<strong><code>ViewModel</code></strong></p>\n<p>根据上面的图示，我们可以看到获取数据的逻辑都在<strong><code>TTModel</code></strong>中，而且界面控件添加和动画渲染这些逻辑仍然都在<strong><code>TTTableViewController</code></strong>中，因此我根据大神们的一些建议，对项目中的Three20进行了一下强化，先上图看一下增加的结构：</p>\n<img src=\"/images/Three20_Advance.png\">\n<p>可以清晰地看到，我将<strong><code>TTModel</code></strong>中处理缓存数据的逻辑抽象出来，单独放在了<strong><code>TTCacheModel</code></strong>中，此外还将<strong><code>TTTableViewController</code></strong>中添加控件和渲染动画的逻辑抽象出来，放到了<strong><code>TTViewRender</code></strong>中，这样<strong><code>TTTableViewController</code></strong>就只关心界面交互以及<strong><code>TTModel</code></strong>和<strong><code>TTTableItem</code></strong>之间的数据传递逻辑。</p>"},{"layout":"post","title":"ZSNavigationFilterMenuView动画解析 --- 基于navigationBar的titleView创造","date":"2015-11-04T16:00:00.000Z","description":"简单项目的动画解析","_content":"\n# 前言\n之前学习了一些绘图的方式和动画的制作，于是简单地制作了一个下拉列表，我把它定位于navigationBar的titleView主要是因为基于新浪微博的Groups分组，新创的一种类似于UIActionSheet的展现方式，至于用法方面，在GitHub上可以完全看到：[SeraZheng的ZSNavigationFilterMenuView](https://github.com/SeraZheng/ZSNavigationFilterMenuView)。\n<!-- more -->\n这篇文章，主要是想写一些我在制作过程中用到的一些知识，还有一些想法和感受。先上图，下面是一个没有使用icon的简单效果，具体效果可以去GitHub看。\n{% img /images/Animation_Title.gif %}\n\n# 设计思路\n首先，我自定义的ZSNavigationFilterMenuView是继承自UIButton的，这样我可以直接设置title和icon，免去了大部分的工作，所以在使用我自定义的ZSNavigationFilterMenuView的时候，一些UIButton的属性及方法都可以直接使用，很方便根据自己不同的需求定制个性化内容。\n\n我使用了tableView作为主要的展示，这样有利于我定制自己的内容，同时也很方便后期的扩展。上图中的图标，都是我使用CoreGraphics画出来，以达到一些练手的目的，但是在真正的开发中，还是要直接使用现成的图片，这样可以提升很大的性能。而关于我选择的展示动画，主要是没有什么设计上的灵感，在Dribble和Capptivate上搜着一些相关内容，并没有很大的启发，因此这里暂时决定了俩种简单动画。\n\n# 动画\n\n## 1.UIView\n\n其他的内容都是一些简单的内容，这里主要讲一下，我制作动画时使用到的一些知识。Apple在SDK中为我们封装好了一些直接使用的API，可以达到我们想要的简单动画的效果。其中我们可以直接使用UIView的动画，主要有三种方式。\n\n第一种最基础的方式就是使用UIView 的扩展UIViewAnimation提供的方法：\n{% codeblock lang:objc %}\n[UIView beginAnimations:@\"_bodyView\" context:nil];\n\n[UIView setAnimationDuration:0.5]; //设置动画延时\n\n[UIView setAnimationRepeatCount:1]; //设置动画重复次数\n\n[UIView setAnimationCurve:UIViewAnimationCurveLinear]; //设置动画曲线\n\n[UIView setAnimationDelay:0.f]; //设置动画延迟\n\n[UIView setAnimationRepeatAutoreverses:YES]; //设置动画重复时以动画形式从终点回到起点\n\n[_bodyView setBackgroundColor:ZSSTYLEVAR(bodyViewHighlightedColor)];\n\n[_bodyView.layer setBorderWidth:0.f];\n\n[UIView commitAnimations];\n{% endcodeblock %}\n\n第二种比较简单的使用方式就是使用UIView的扩展UIViewAnimationWithBlocks提供的方法：\n{% codeblock lang:objc %}\n[UIView animateWithDuration:0.5 delay:0.f options:UIViewAnimationOptionAutoreverse animations:^(){\n\n           [_bodyView setBackgroundColor:ZSSTYLEVAR(bodyViewHighlightedColor)];\n\n           [_bodyView.layer setBorderWidth:0.f];\n\n} completion:NULL];\n{% endcodeblock %}\n\n第三种就是使用UIView的扩展UIViewKeyframeAnimations提供的创建关键帧动画的方法：\n{% codeblock lang:objc %}\n[UIView animateKeyframesWithDuration:0.5 delay:0.f options:UIViewKeyframeAnimationOptionAutoreverse | UIViewKeyframeAnimationOptionCalculationModeLinear animations:^(){\n\n          [_bodyView setBackgroundColor:ZSSTYLEVAR(bodyViewHighlightedColor)];\n\n          [_bodyView.layer setBorderWidth:0.f];\n\n} completion:NULL];\n{% endcodeblock %}\n\n关于上面三种的使用方式是大同小异，个人倾向于简单的动画使用block的方式，因为这不仅减少了我们的代码量，而且可读性也比较好。UIView的扩展UIViewAnimationWithBlocks提供了其他一些让我们可以直接创建动画效果的方法，比如可以直接创建弹簧动画效果，而我在展现tableView时，使用到的也是这种效果。\n\n## 2.CoreAnimation\n\n底层的实现动画的方式，就是利用QuartzCore框架，通过CAAnimation来达到我们想要的动画效果。QuartzCore框架也比较简单，主要提供了关于CALayer,CAAnimation的个性化定制的使用方法。\n{% codeblock lang:objc %}\nCGPoint viewPosition = self.contentView.layer.position;\n\n_shakeAnimation = [CABasicAnimation animationWithKeyPath:@\"position\"];\n\n[_shakeAnimation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionDefault]]; //设置动画曲线效果\n\n[_shakeAnimation setFromValue:[NSValue valueWithCGPoint:CGPointMake(viewPosition.x - 10, viewPosition.y)]]; //设置起始值\n\n[_shakeAnimation setToValue:[NSValue valueWithCGPoint:CGPointMake(viewPosition.x + 10, viewPosition.y)]]; //设置终点值\n\n[_shakeAnimation setAutoreverses:YES]; //设置以动画方式回到起始值\n\n[_shakeAnimation setRepeatCount:2]; //设置动画重复次数\n\n[_shakeAnimation setDuration:0.05]; //设置动画时间\n\n[self.contentView.layer addAnimation:_shakeAnimation]; //添加动画到layer\n{% endcodeblock %}\n关于动画基础和动画原理，我推荐一篇非常棒的博客：[objc系列译文（12.1）：动画解释](http://blog.jobbole.com/69111/)。\n\n# 贝塞尔曲线\n谈到动画，不得不说的就是贝塞尔曲线，堪称是制作精美动画效果的基础法则。苹果给我们提供了一个非常好的使用贝塞尔曲线的封装：UIBezierPath。而关于UIBezierPath的基础使用，我推荐一篇比较详细的博客：[标哥的技术博客--UIBezierPath精讲](http://www.henishuo.com/uibezierpath-draw/)。\n\n# 反馈\n关于动画的基础原理甚至是贝塞尔曲线得原理及使用，我们都可以在维基百科上搜到很好的教程。想学习的朋友可以自行查阅。关于项目中的动画的设计效果，暂时没有什么灵感，如果在Dribble和Capptivate上找到了动画效果和灵感，会及时的更新项目和这篇文章，也希望如大家有什么好的动画效果和其他方面的建议，可以多多评论给我！","source":"_posts/ZSNavigationFilterMenuView动画解析 --- 基于navigationBar的titleView创造.md","raw":"---\nlayout: post\ntitle: ZSNavigationFilterMenuView动画解析 --- 基于navigationBar的titleView创造\ndate: 2015-11-05\ndescription: \"简单项目的动画解析\"\ntags: [CoreAnimation]\ncategories: [iOS]\n---\n\n# 前言\n之前学习了一些绘图的方式和动画的制作，于是简单地制作了一个下拉列表，我把它定位于navigationBar的titleView主要是因为基于新浪微博的Groups分组，新创的一种类似于UIActionSheet的展现方式，至于用法方面，在GitHub上可以完全看到：[SeraZheng的ZSNavigationFilterMenuView](https://github.com/SeraZheng/ZSNavigationFilterMenuView)。\n<!-- more -->\n这篇文章，主要是想写一些我在制作过程中用到的一些知识，还有一些想法和感受。先上图，下面是一个没有使用icon的简单效果，具体效果可以去GitHub看。\n{% img /images/Animation_Title.gif %}\n\n# 设计思路\n首先，我自定义的ZSNavigationFilterMenuView是继承自UIButton的，这样我可以直接设置title和icon，免去了大部分的工作，所以在使用我自定义的ZSNavigationFilterMenuView的时候，一些UIButton的属性及方法都可以直接使用，很方便根据自己不同的需求定制个性化内容。\n\n我使用了tableView作为主要的展示，这样有利于我定制自己的内容，同时也很方便后期的扩展。上图中的图标，都是我使用CoreGraphics画出来，以达到一些练手的目的，但是在真正的开发中，还是要直接使用现成的图片，这样可以提升很大的性能。而关于我选择的展示动画，主要是没有什么设计上的灵感，在Dribble和Capptivate上搜着一些相关内容，并没有很大的启发，因此这里暂时决定了俩种简单动画。\n\n# 动画\n\n## 1.UIView\n\n其他的内容都是一些简单的内容，这里主要讲一下，我制作动画时使用到的一些知识。Apple在SDK中为我们封装好了一些直接使用的API，可以达到我们想要的简单动画的效果。其中我们可以直接使用UIView的动画，主要有三种方式。\n\n第一种最基础的方式就是使用UIView 的扩展UIViewAnimation提供的方法：\n{% codeblock lang:objc %}\n[UIView beginAnimations:@\"_bodyView\" context:nil];\n\n[UIView setAnimationDuration:0.5]; //设置动画延时\n\n[UIView setAnimationRepeatCount:1]; //设置动画重复次数\n\n[UIView setAnimationCurve:UIViewAnimationCurveLinear]; //设置动画曲线\n\n[UIView setAnimationDelay:0.f]; //设置动画延迟\n\n[UIView setAnimationRepeatAutoreverses:YES]; //设置动画重复时以动画形式从终点回到起点\n\n[_bodyView setBackgroundColor:ZSSTYLEVAR(bodyViewHighlightedColor)];\n\n[_bodyView.layer setBorderWidth:0.f];\n\n[UIView commitAnimations];\n{% endcodeblock %}\n\n第二种比较简单的使用方式就是使用UIView的扩展UIViewAnimationWithBlocks提供的方法：\n{% codeblock lang:objc %}\n[UIView animateWithDuration:0.5 delay:0.f options:UIViewAnimationOptionAutoreverse animations:^(){\n\n           [_bodyView setBackgroundColor:ZSSTYLEVAR(bodyViewHighlightedColor)];\n\n           [_bodyView.layer setBorderWidth:0.f];\n\n} completion:NULL];\n{% endcodeblock %}\n\n第三种就是使用UIView的扩展UIViewKeyframeAnimations提供的创建关键帧动画的方法：\n{% codeblock lang:objc %}\n[UIView animateKeyframesWithDuration:0.5 delay:0.f options:UIViewKeyframeAnimationOptionAutoreverse | UIViewKeyframeAnimationOptionCalculationModeLinear animations:^(){\n\n          [_bodyView setBackgroundColor:ZSSTYLEVAR(bodyViewHighlightedColor)];\n\n          [_bodyView.layer setBorderWidth:0.f];\n\n} completion:NULL];\n{% endcodeblock %}\n\n关于上面三种的使用方式是大同小异，个人倾向于简单的动画使用block的方式，因为这不仅减少了我们的代码量，而且可读性也比较好。UIView的扩展UIViewAnimationWithBlocks提供了其他一些让我们可以直接创建动画效果的方法，比如可以直接创建弹簧动画效果，而我在展现tableView时，使用到的也是这种效果。\n\n## 2.CoreAnimation\n\n底层的实现动画的方式，就是利用QuartzCore框架，通过CAAnimation来达到我们想要的动画效果。QuartzCore框架也比较简单，主要提供了关于CALayer,CAAnimation的个性化定制的使用方法。\n{% codeblock lang:objc %}\nCGPoint viewPosition = self.contentView.layer.position;\n\n_shakeAnimation = [CABasicAnimation animationWithKeyPath:@\"position\"];\n\n[_shakeAnimation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionDefault]]; //设置动画曲线效果\n\n[_shakeAnimation setFromValue:[NSValue valueWithCGPoint:CGPointMake(viewPosition.x - 10, viewPosition.y)]]; //设置起始值\n\n[_shakeAnimation setToValue:[NSValue valueWithCGPoint:CGPointMake(viewPosition.x + 10, viewPosition.y)]]; //设置终点值\n\n[_shakeAnimation setAutoreverses:YES]; //设置以动画方式回到起始值\n\n[_shakeAnimation setRepeatCount:2]; //设置动画重复次数\n\n[_shakeAnimation setDuration:0.05]; //设置动画时间\n\n[self.contentView.layer addAnimation:_shakeAnimation]; //添加动画到layer\n{% endcodeblock %}\n关于动画基础和动画原理，我推荐一篇非常棒的博客：[objc系列译文（12.1）：动画解释](http://blog.jobbole.com/69111/)。\n\n# 贝塞尔曲线\n谈到动画，不得不说的就是贝塞尔曲线，堪称是制作精美动画效果的基础法则。苹果给我们提供了一个非常好的使用贝塞尔曲线的封装：UIBezierPath。而关于UIBezierPath的基础使用，我推荐一篇比较详细的博客：[标哥的技术博客--UIBezierPath精讲](http://www.henishuo.com/uibezierpath-draw/)。\n\n# 反馈\n关于动画的基础原理甚至是贝塞尔曲线得原理及使用，我们都可以在维基百科上搜到很好的教程。想学习的朋友可以自行查阅。关于项目中的动画的设计效果，暂时没有什么灵感，如果在Dribble和Capptivate上找到了动画效果和灵感，会及时的更新项目和这篇文章，也希望如大家有什么好的动画效果和其他方面的建议，可以多多评论给我！","slug":"ZSNavigationFilterMenuView动画解析 --- 基于navigationBar的titleView创造","published":1,"updated":"2016-04-12T06:51:38.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9tp000r94su6d4loa3w","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>之前学习了一些绘图的方式和动画的制作，于是简单地制作了一个下拉列表，我把它定位于navigationBar的titleView主要是因为基于新浪微博的Groups分组，新创的一种类似于UIActionSheet的展现方式，至于用法方面，在GitHub上可以完全看到：<a href=\"https://github.com/SeraZheng/ZSNavigationFilterMenuView\" target=\"_blank\" rel=\"external\">SeraZheng的ZSNavigationFilterMenuView</a>。<br><a id=\"more\"></a><br>这篇文章，主要是想写一些我在制作过程中用到的一些知识，还有一些想法和感受。先上图，下面是一个没有使用icon的简单效果，具体效果可以去GitHub看。<br><img src=\"/images/Animation_Title.gif\"></p>\n<h1 id=\"设计思路\"><a href=\"#设计思路\" class=\"headerlink\" title=\"设计思路\"></a>设计思路</h1><p>首先，我自定义的ZSNavigationFilterMenuView是继承自UIButton的，这样我可以直接设置title和icon，免去了大部分的工作，所以在使用我自定义的ZSNavigationFilterMenuView的时候，一些UIButton的属性及方法都可以直接使用，很方便根据自己不同的需求定制个性化内容。</p>\n<p>我使用了tableView作为主要的展示，这样有利于我定制自己的内容，同时也很方便后期的扩展。上图中的图标，都是我使用CoreGraphics画出来，以达到一些练手的目的，但是在真正的开发中，还是要直接使用现成的图片，这样可以提升很大的性能。而关于我选择的展示动画，主要是没有什么设计上的灵感，在Dribble和Capptivate上搜着一些相关内容，并没有很大的启发，因此这里暂时决定了俩种简单动画。</p>\n<h1 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h1><h2 id=\"1-UIView\"><a href=\"#1-UIView\" class=\"headerlink\" title=\"1.UIView\"></a>1.UIView</h2><p>其他的内容都是一些简单的内容，这里主要讲一下，我制作动画时使用到的一些知识。Apple在SDK中为我们封装好了一些直接使用的API，可以达到我们想要的简单动画的效果。其中我们可以直接使用UIView的动画，主要有三种方式。</p>\n<p>第一种最基础的方式就是使用UIView 的扩展UIViewAnimation提供的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIView</span> beginAnimations:<span class=\"string\">@\"_bodyView\"</span> context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"built_in\">UIView</span> setAnimationDuration:<span class=\"number\">0.5</span>]; <span class=\"comment\">//设置动画延时</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"built_in\">UIView</span> setAnimationRepeatCount:<span class=\"number\">1</span>]; <span class=\"comment\">//设置动画重复次数</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"built_in\">UIView</span> setAnimationCurve:<span class=\"built_in\">UIViewAnimationCurveLinear</span>]; <span class=\"comment\">//设置动画曲线</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"built_in\">UIView</span> setAnimationDelay:<span class=\"number\">0.</span>f]; <span class=\"comment\">//设置动画延迟</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"built_in\">UIView</span> setAnimationRepeatAutoreverses:<span class=\"literal\">YES</span>]; <span class=\"comment\">//设置动画重复时以动画形式从终点回到起点</span></span><br><span class=\"line\"></span><br><span class=\"line\">[_bodyView setBackgroundColor:ZSSTYLEVAR(bodyViewHighlightedColor)];</span><br><span class=\"line\"></span><br><span class=\"line\">[_bodyView.layer setBorderWidth:<span class=\"number\">0.</span>f];</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"built_in\">UIView</span> commitAnimations];</span><br></pre></td></tr></table></figure></p>\n<p>第二种比较简单的使用方式就是使用UIView的扩展UIViewAnimationWithBlocks提供的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">0.5</span> delay:<span class=\"number\">0.</span>f options:<span class=\"built_in\">UIViewAnimationOptionAutoreverse</span> animations:^()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           [_bodyView setBackgroundColor:ZSSTYLEVAR(bodyViewHighlightedColor)];</span><br><span class=\"line\"></span><br><span class=\"line\">           [_bodyView.layer setBorderWidth:<span class=\"number\">0.</span>f];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; completion:<span class=\"literal\">NULL</span>];</span><br></pre></td></tr></table></figure></p>\n<p>第三种就是使用UIView的扩展UIViewKeyframeAnimations提供的创建关键帧动画的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIView</span> animateKeyframesWithDuration:<span class=\"number\">0.5</span> delay:<span class=\"number\">0.</span>f options:<span class=\"built_in\">UIViewKeyframeAnimationOptionAutoreverse</span> | <span class=\"built_in\">UIViewKeyframeAnimationOptionCalculationModeLinear</span> animations:^()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          [_bodyView setBackgroundColor:ZSSTYLEVAR(bodyViewHighlightedColor)];</span><br><span class=\"line\"></span><br><span class=\"line\">          [_bodyView.layer setBorderWidth:<span class=\"number\">0.</span>f];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; completion:<span class=\"literal\">NULL</span>];</span><br></pre></td></tr></table></figure></p>\n<p>关于上面三种的使用方式是大同小异，个人倾向于简单的动画使用block的方式，因为这不仅减少了我们的代码量，而且可读性也比较好。UIView的扩展UIViewAnimationWithBlocks提供了其他一些让我们可以直接创建动画效果的方法，比如可以直接创建弹簧动画效果，而我在展现tableView时，使用到的也是这种效果。</p>\n<h2 id=\"2-CoreAnimation\"><a href=\"#2-CoreAnimation\" class=\"headerlink\" title=\"2.CoreAnimation\"></a>2.CoreAnimation</h2><p>底层的实现动画的方式，就是利用QuartzCore框架，通过CAAnimation来达到我们想要的动画效果。QuartzCore框架也比较简单，主要提供了关于CALayer,CAAnimation的个性化定制的使用方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGPoint</span> viewPosition = <span class=\"keyword\">self</span>.contentView.layer.position;</span><br><span class=\"line\"></span><br><span class=\"line\">_shakeAnimation = [<span class=\"built_in\">CABasicAnimation</span> animationWithKeyPath:<span class=\"string\">@\"position\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[_shakeAnimation setTimingFunction:[<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:k<span class=\"built_in\">CAMediaTimingFunctionDefault</span>]]; <span class=\"comment\">//设置动画曲线效果</span></span><br><span class=\"line\"></span><br><span class=\"line\">[_shakeAnimation setFromValue:[<span class=\"built_in\">NSValue</span> valueWith<span class=\"built_in\">CGPoint</span>:<span class=\"built_in\">CGPointMake</span>(viewPosition.x - <span class=\"number\">10</span>, viewPosition.y)]]; <span class=\"comment\">//设置起始值</span></span><br><span class=\"line\"></span><br><span class=\"line\">[_shakeAnimation setToValue:[<span class=\"built_in\">NSValue</span> valueWith<span class=\"built_in\">CGPoint</span>:<span class=\"built_in\">CGPointMake</span>(viewPosition.x + <span class=\"number\">10</span>, viewPosition.y)]]; <span class=\"comment\">//设置终点值</span></span><br><span class=\"line\"></span><br><span class=\"line\">[_shakeAnimation setAutoreverses:<span class=\"literal\">YES</span>]; <span class=\"comment\">//设置以动画方式回到起始值</span></span><br><span class=\"line\"></span><br><span class=\"line\">[_shakeAnimation setRepeatCount:<span class=\"number\">2</span>]; <span class=\"comment\">//设置动画重复次数</span></span><br><span class=\"line\"></span><br><span class=\"line\">[_shakeAnimation setDuration:<span class=\"number\">0.05</span>]; <span class=\"comment\">//设置动画时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.contentView.layer addAnimation:_shakeAnimation]; <span class=\"comment\">//添加动画到layer</span></span><br></pre></td></tr></table></figure><br>关于动画基础和动画原理，我推荐一篇非常棒的博客：<a href=\"http://blog.jobbole.com/69111/\" target=\"_blank\" rel=\"external\">objc系列译文（12.1）：动画解释</a>。</p>\n<h1 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h1><p>谈到动画，不得不说的就是贝塞尔曲线，堪称是制作精美动画效果的基础法则。苹果给我们提供了一个非常好的使用贝塞尔曲线的封装：UIBezierPath。而关于UIBezierPath的基础使用，我推荐一篇比较详细的博客：<a href=\"http://www.henishuo.com/uibezierpath-draw/\" target=\"_blank\" rel=\"external\">标哥的技术博客–UIBezierPath精讲</a>。</p>\n<h1 id=\"反馈\"><a href=\"#反馈\" class=\"headerlink\" title=\"反馈\"></a>反馈</h1><p>关于动画的基础原理甚至是贝塞尔曲线得原理及使用，我们都可以在维基百科上搜到很好的教程。想学习的朋友可以自行查阅。关于项目中的动画的设计效果，暂时没有什么灵感，如果在Dribble和Capptivate上找到了动画效果和灵感，会及时的更新项目和这篇文章，也希望如大家有什么好的动画效果和其他方面的建议，可以多多评论给我！</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>之前学习了一些绘图的方式和动画的制作，于是简单地制作了一个下拉列表，我把它定位于navigationBar的titleView主要是因为基于新浪微博的Groups分组，新创的一种类似于UIActionSheet的展现方式，至于用法方面，在GitHub上可以完全看到：<a href=\"https://github.com/SeraZheng/ZSNavigationFilterMenuView\">SeraZheng的ZSNavigationFilterMenuView</a>。<br>","more":"<br>这篇文章，主要是想写一些我在制作过程中用到的一些知识，还有一些想法和感受。先上图，下面是一个没有使用icon的简单效果，具体效果可以去GitHub看。<br><img src=\"/images/Animation_Title.gif\"></p>\n<h1 id=\"设计思路\"><a href=\"#设计思路\" class=\"headerlink\" title=\"设计思路\"></a>设计思路</h1><p>首先，我自定义的ZSNavigationFilterMenuView是继承自UIButton的，这样我可以直接设置title和icon，免去了大部分的工作，所以在使用我自定义的ZSNavigationFilterMenuView的时候，一些UIButton的属性及方法都可以直接使用，很方便根据自己不同的需求定制个性化内容。</p>\n<p>我使用了tableView作为主要的展示，这样有利于我定制自己的内容，同时也很方便后期的扩展。上图中的图标，都是我使用CoreGraphics画出来，以达到一些练手的目的，但是在真正的开发中，还是要直接使用现成的图片，这样可以提升很大的性能。而关于我选择的展示动画，主要是没有什么设计上的灵感，在Dribble和Capptivate上搜着一些相关内容，并没有很大的启发，因此这里暂时决定了俩种简单动画。</p>\n<h1 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h1><h2 id=\"1-UIView\"><a href=\"#1-UIView\" class=\"headerlink\" title=\"1.UIView\"></a>1.UIView</h2><p>其他的内容都是一些简单的内容，这里主要讲一下，我制作动画时使用到的一些知识。Apple在SDK中为我们封装好了一些直接使用的API，可以达到我们想要的简单动画的效果。其中我们可以直接使用UIView的动画，主要有三种方式。</p>\n<p>第一种最基础的方式就是使用UIView 的扩展UIViewAnimation提供的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIView</span> beginAnimations:<span class=\"string\">@\"_bodyView\"</span> context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"built_in\">UIView</span> setAnimationDuration:<span class=\"number\">0.5</span>]; <span class=\"comment\">//设置动画延时</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"built_in\">UIView</span> setAnimationRepeatCount:<span class=\"number\">1</span>]; <span class=\"comment\">//设置动画重复次数</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"built_in\">UIView</span> setAnimationCurve:<span class=\"built_in\">UIViewAnimationCurveLinear</span>]; <span class=\"comment\">//设置动画曲线</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"built_in\">UIView</span> setAnimationDelay:<span class=\"number\">0.</span>f]; <span class=\"comment\">//设置动画延迟</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"built_in\">UIView</span> setAnimationRepeatAutoreverses:<span class=\"literal\">YES</span>]; <span class=\"comment\">//设置动画重复时以动画形式从终点回到起点</span></span><br><span class=\"line\"></span><br><span class=\"line\">[_bodyView setBackgroundColor:ZSSTYLEVAR(bodyViewHighlightedColor)];</span><br><span class=\"line\"></span><br><span class=\"line\">[_bodyView.layer setBorderWidth:<span class=\"number\">0.</span>f];</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"built_in\">UIView</span> commitAnimations];</span><br></pre></td></tr></table></figure></p>\n<p>第二种比较简单的使用方式就是使用UIView的扩展UIViewAnimationWithBlocks提供的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">0.5</span> delay:<span class=\"number\">0.</span>f options:<span class=\"built_in\">UIViewAnimationOptionAutoreverse</span> animations:^()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           [_bodyView setBackgroundColor:ZSSTYLEVAR(bodyViewHighlightedColor)];</span><br><span class=\"line\"></span><br><span class=\"line\">           [_bodyView.layer setBorderWidth:<span class=\"number\">0.</span>f];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; completion:<span class=\"literal\">NULL</span>];</span><br></pre></td></tr></table></figure></p>\n<p>第三种就是使用UIView的扩展UIViewKeyframeAnimations提供的创建关键帧动画的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">UIView</span> animateKeyframesWithDuration:<span class=\"number\">0.5</span> delay:<span class=\"number\">0.</span>f options:<span class=\"built_in\">UIViewKeyframeAnimationOptionAutoreverse</span> | <span class=\"built_in\">UIViewKeyframeAnimationOptionCalculationModeLinear</span> animations:^()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          [_bodyView setBackgroundColor:ZSSTYLEVAR(bodyViewHighlightedColor)];</span><br><span class=\"line\"></span><br><span class=\"line\">          [_bodyView.layer setBorderWidth:<span class=\"number\">0.</span>f];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; completion:<span class=\"literal\">NULL</span>];</span><br></pre></td></tr></table></figure></p>\n<p>关于上面三种的使用方式是大同小异，个人倾向于简单的动画使用block的方式，因为这不仅减少了我们的代码量，而且可读性也比较好。UIView的扩展UIViewAnimationWithBlocks提供了其他一些让我们可以直接创建动画效果的方法，比如可以直接创建弹簧动画效果，而我在展现tableView时，使用到的也是这种效果。</p>\n<h2 id=\"2-CoreAnimation\"><a href=\"#2-CoreAnimation\" class=\"headerlink\" title=\"2.CoreAnimation\"></a>2.CoreAnimation</h2><p>底层的实现动画的方式，就是利用QuartzCore框架，通过CAAnimation来达到我们想要的动画效果。QuartzCore框架也比较简单，主要提供了关于CALayer,CAAnimation的个性化定制的使用方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CGPoint</span> viewPosition = <span class=\"keyword\">self</span>.contentView.layer.position;</span><br><span class=\"line\"></span><br><span class=\"line\">_shakeAnimation = [<span class=\"built_in\">CABasicAnimation</span> animationWithKeyPath:<span class=\"string\">@\"position\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[_shakeAnimation setTimingFunction:[<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:k<span class=\"built_in\">CAMediaTimingFunctionDefault</span>]]; <span class=\"comment\">//设置动画曲线效果</span></span><br><span class=\"line\"></span><br><span class=\"line\">[_shakeAnimation setFromValue:[<span class=\"built_in\">NSValue</span> valueWith<span class=\"built_in\">CGPoint</span>:<span class=\"built_in\">CGPointMake</span>(viewPosition.x - <span class=\"number\">10</span>, viewPosition.y)]]; <span class=\"comment\">//设置起始值</span></span><br><span class=\"line\"></span><br><span class=\"line\">[_shakeAnimation setToValue:[<span class=\"built_in\">NSValue</span> valueWith<span class=\"built_in\">CGPoint</span>:<span class=\"built_in\">CGPointMake</span>(viewPosition.x + <span class=\"number\">10</span>, viewPosition.y)]]; <span class=\"comment\">//设置终点值</span></span><br><span class=\"line\"></span><br><span class=\"line\">[_shakeAnimation setAutoreverses:<span class=\"literal\">YES</span>]; <span class=\"comment\">//设置以动画方式回到起始值</span></span><br><span class=\"line\"></span><br><span class=\"line\">[_shakeAnimation setRepeatCount:<span class=\"number\">2</span>]; <span class=\"comment\">//设置动画重复次数</span></span><br><span class=\"line\"></span><br><span class=\"line\">[_shakeAnimation setDuration:<span class=\"number\">0.05</span>]; <span class=\"comment\">//设置动画时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.contentView.layer addAnimation:_shakeAnimation]; <span class=\"comment\">//添加动画到layer</span></span><br></pre></td></tr></table></figure><br>关于动画基础和动画原理，我推荐一篇非常棒的博客：<a href=\"http://blog.jobbole.com/69111/\">objc系列译文（12.1）：动画解释</a>。</p>\n<h1 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h1><p>谈到动画，不得不说的就是贝塞尔曲线，堪称是制作精美动画效果的基础法则。苹果给我们提供了一个非常好的使用贝塞尔曲线的封装：UIBezierPath。而关于UIBezierPath的基础使用，我推荐一篇比较详细的博客：<a href=\"http://www.henishuo.com/uibezierpath-draw/\">标哥的技术博客–UIBezierPath精讲</a>。</p>\n<h1 id=\"反馈\"><a href=\"#反馈\" class=\"headerlink\" title=\"反馈\"></a>反馈</h1><p>关于动画的基础原理甚至是贝塞尔曲线得原理及使用，我们都可以在维基百科上搜到很好的教程。想学习的朋友可以自行查阅。关于项目中的动画的设计效果，暂时没有什么灵感，如果在Dribble和Capptivate上找到了动画效果和灵感，会及时的更新项目和这篇文章，也希望如大家有什么好的动画效果和其他方面的建议，可以多多评论给我！</p>"},{"layout":"post","title":"iOS多线程开发（一）多线程基础","date":"2015-07-31T16:00:00.000Z","_content":"\n# 前言　　\n前段时间给项目添加了图片的传送与下载的功能，由于当时工期紧凑，并没有理会性能问题。闲暇之余，想起来给项目优化一下性能，于是决定研究一下多线程技术。\n\n>`多线程`，引用百度百科上面的话，就是指从软件或硬件上实现多个线程`并发执行`的技术。使用多线程的优点就在于可以把占据时间长得任务放在后台线程中去执行，避免影响主线程的运行，避免出现用户长时间等待操作，可以极好地提高程序的性能。\n<!-- more -->\n# iOS中的多线程\n在iOS开发中，有三种使用多线程开发的技术： `NSThread`、`NSOperation`和`GCD`。这三种多线程技术`抽象度`依次是越来越高，而抽象程度越高，使用起来越简单。我会在后面的文章中具体地讲述每一种多线程技术。\n\n# 进程与线程\n简单地说，`进程`是一个正在运行的程序的`实例`，拥有自己的地址空间，是系统资源分配和调度的一个独立单位；而`线程`则是进程中的一个实体，有时亦被称作是`轻量级的进程`。关于`进程`与`线程`的具体区分，我推荐大家可以阅读这篇博客[进程与线程的一个简单解释](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)。\n\n# 队列\n学过数据结构的朋友应该都清楚`队列`的含义，它是一种常用的`数据结构`，是一种特殊的线性表，拥有`FIFO`（先进先出）的特性。在iOS多线程开发中，会经常使用到这种数据结构来存储线程。\n\n# 串行队列与并行队列\niOS开发中的`串行队列`，指的是在队列中，所有的任务都是按顺序一条一条执行的，只有完成了上一条任务，才能执行下一条任务；而`并行队列`指的是一个队列中所有任务是可以同时运行的。\n　  \n# 同步与异步\n`同步`与`异步`操作，针对的是线程这一级别的运行逻辑。`同步`是指在当前的线程中执行任务，不具备`开辟新线程`的能力；`异步`操作是指在新线程中执行任务，具有`开辟新线程`的能力。\n\n# 基本规则：\n\n1. 串行队列中的任务会按顺序执行，并行队列中的任务通常会并发执行，而且无法确定任务的执行顺序。\n2. 异步操作会新开辟线程来执行任务，而且无法确定执行顺序，同步操作不会新开辟线程\n3. 在串行队列中执行同步任务：不会新建线程，按顺序执行任务\n4. 在串行队列中执行异步任务，会新建线程，按顺序执行任务\n5. 在并行队列中执行同步任务：不会新建线程，按顺序执行任务\n6. 在并行队列中执行异步任务：会新建多个线程，但是无法确定任务的执行顺序\n7. 全局队列是系统的，直接拿过来就可以用，与并行队列类似，但是不能指定队列的名字，调试时无法确认任务所在队列\n8. 在全局队列中执行同步任务：不会新建线程，按顺序执行任务\n9. 在全局队列中执行异步任务：会新建多个线程，但是无法确定任务的执行顺序\n10. 每一个应用程序只有一个主线程即只有一个主队列\n11. 在ios开发中，所有UI的更新任务都必须在主线程上执行。\n12. 主队列中的操作都是主线程中执行的，不存在异步的概念      \n13. 主队列中添加的同步操作永远不会被执行会死锁","source":"_posts/iOS多线程开发（一）多线程基础.md","raw":"---\nlayout: post\ntitle: iOS多线程开发（一）多线程基础\ndate: 2015-08-01\ntags: [多线程]\ncategories: [多线程]\n---\n\n# 前言　　\n前段时间给项目添加了图片的传送与下载的功能，由于当时工期紧凑，并没有理会性能问题。闲暇之余，想起来给项目优化一下性能，于是决定研究一下多线程技术。\n\n>`多线程`，引用百度百科上面的话，就是指从软件或硬件上实现多个线程`并发执行`的技术。使用多线程的优点就在于可以把占据时间长得任务放在后台线程中去执行，避免影响主线程的运行，避免出现用户长时间等待操作，可以极好地提高程序的性能。\n<!-- more -->\n# iOS中的多线程\n在iOS开发中，有三种使用多线程开发的技术： `NSThread`、`NSOperation`和`GCD`。这三种多线程技术`抽象度`依次是越来越高，而抽象程度越高，使用起来越简单。我会在后面的文章中具体地讲述每一种多线程技术。\n\n# 进程与线程\n简单地说，`进程`是一个正在运行的程序的`实例`，拥有自己的地址空间，是系统资源分配和调度的一个独立单位；而`线程`则是进程中的一个实体，有时亦被称作是`轻量级的进程`。关于`进程`与`线程`的具体区分，我推荐大家可以阅读这篇博客[进程与线程的一个简单解释](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)。\n\n# 队列\n学过数据结构的朋友应该都清楚`队列`的含义，它是一种常用的`数据结构`，是一种特殊的线性表，拥有`FIFO`（先进先出）的特性。在iOS多线程开发中，会经常使用到这种数据结构来存储线程。\n\n# 串行队列与并行队列\niOS开发中的`串行队列`，指的是在队列中，所有的任务都是按顺序一条一条执行的，只有完成了上一条任务，才能执行下一条任务；而`并行队列`指的是一个队列中所有任务是可以同时运行的。\n　  \n# 同步与异步\n`同步`与`异步`操作，针对的是线程这一级别的运行逻辑。`同步`是指在当前的线程中执行任务，不具备`开辟新线程`的能力；`异步`操作是指在新线程中执行任务，具有`开辟新线程`的能力。\n\n# 基本规则：\n\n1. 串行队列中的任务会按顺序执行，并行队列中的任务通常会并发执行，而且无法确定任务的执行顺序。\n2. 异步操作会新开辟线程来执行任务，而且无法确定执行顺序，同步操作不会新开辟线程\n3. 在串行队列中执行同步任务：不会新建线程，按顺序执行任务\n4. 在串行队列中执行异步任务，会新建线程，按顺序执行任务\n5. 在并行队列中执行同步任务：不会新建线程，按顺序执行任务\n6. 在并行队列中执行异步任务：会新建多个线程，但是无法确定任务的执行顺序\n7. 全局队列是系统的，直接拿过来就可以用，与并行队列类似，但是不能指定队列的名字，调试时无法确认任务所在队列\n8. 在全局队列中执行同步任务：不会新建线程，按顺序执行任务\n9. 在全局队列中执行异步任务：会新建多个线程，但是无法确定任务的执行顺序\n10. 每一个应用程序只有一个主线程即只有一个主队列\n11. 在ios开发中，所有UI的更新任务都必须在主线程上执行。\n12. 主队列中的操作都是主线程中执行的，不存在异步的概念      \n13. 主队列中添加的同步操作永远不会被执行会死锁","slug":"iOS多线程开发（一）多线程基础","published":1,"updated":"2016-04-12T06:46:33.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9tr000t94suvivjfitx","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>前段时间给项目添加了图片的传送与下载的功能，由于当时工期紧凑，并没有理会性能问题。闲暇之余，想起来给项目优化一下性能，于是决定研究一下多线程技术。</p>\n<blockquote>\n<p><code>多线程</code>，引用百度百科上面的话，就是指从软件或硬件上实现多个线程<code>并发执行</code>的技术。使用多线程的优点就在于可以把占据时间长得任务放在后台线程中去执行，避免影响主线程的运行，避免出现用户长时间等待操作，可以极好地提高程序的性能。<br><a id=\"more\"></a></p>\n<h1 id=\"iOS中的多线程\"><a href=\"#iOS中的多线程\" class=\"headerlink\" title=\"iOS中的多线程\"></a>iOS中的多线程</h1><p>在iOS开发中，有三种使用多线程开发的技术： <code>NSThread</code>、<code>NSOperation</code>和<code>GCD</code>。这三种多线程技术<code>抽象度</code>依次是越来越高，而抽象程度越高，使用起来越简单。我会在后面的文章中具体地讲述每一种多线程技术。</p>\n</blockquote>\n<h1 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h1><p>简单地说，<code>进程</code>是一个正在运行的程序的<code>实例</code>，拥有自己的地址空间，是系统资源分配和调度的一个独立单位；而<code>线程</code>则是进程中的一个实体，有时亦被称作是<code>轻量级的进程</code>。关于<code>进程</code>与<code>线程</code>的具体区分，我推荐大家可以阅读这篇博客<a href=\"http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html\" target=\"_blank\" rel=\"external\">进程与线程的一个简单解释</a>。</p>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><p>学过数据结构的朋友应该都清楚<code>队列</code>的含义，它是一种常用的<code>数据结构</code>，是一种特殊的线性表，拥有<code>FIFO</code>（先进先出）的特性。在iOS多线程开发中，会经常使用到这种数据结构来存储线程。</p>\n<h1 id=\"串行队列与并行队列\"><a href=\"#串行队列与并行队列\" class=\"headerlink\" title=\"串行队列与并行队列\"></a>串行队列与并行队列</h1><p>iOS开发中的<code>串行队列</code>，指的是在队列中，所有的任务都是按顺序一条一条执行的，只有完成了上一条任务，才能执行下一条任务；而<code>并行队列</code>指的是一个队列中所有任务是可以同时运行的。\n　  </p>\n<h1 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h1><p><code>同步</code>与<code>异步</code>操作，针对的是线程这一级别的运行逻辑。<code>同步</code>是指在当前的线程中执行任务，不具备<code>开辟新线程</code>的能力；<code>异步</code>操作是指在新线程中执行任务，具有<code>开辟新线程</code>的能力。</p>\n<h1 id=\"基本规则：\"><a href=\"#基本规则：\" class=\"headerlink\" title=\"基本规则：\"></a>基本规则：</h1><ol>\n<li>串行队列中的任务会按顺序执行，并行队列中的任务通常会并发执行，而且无法确定任务的执行顺序。</li>\n<li>异步操作会新开辟线程来执行任务，而且无法确定执行顺序，同步操作不会新开辟线程</li>\n<li>在串行队列中执行同步任务：不会新建线程，按顺序执行任务</li>\n<li>在串行队列中执行异步任务，会新建线程，按顺序执行任务</li>\n<li>在并行队列中执行同步任务：不会新建线程，按顺序执行任务</li>\n<li>在并行队列中执行异步任务：会新建多个线程，但是无法确定任务的执行顺序</li>\n<li>全局队列是系统的，直接拿过来就可以用，与并行队列类似，但是不能指定队列的名字，调试时无法确认任务所在队列</li>\n<li>在全局队列中执行同步任务：不会新建线程，按顺序执行任务</li>\n<li>在全局队列中执行异步任务：会新建多个线程，但是无法确定任务的执行顺序</li>\n<li>每一个应用程序只有一个主线程即只有一个主队列</li>\n<li>在ios开发中，所有UI的更新任务都必须在主线程上执行。</li>\n<li>主队列中的操作都是主线程中执行的，不存在异步的概念      </li>\n<li>主队列中添加的同步操作永远不会被执行会死锁</li>\n</ol>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>前段时间给项目添加了图片的传送与下载的功能，由于当时工期紧凑，并没有理会性能问题。闲暇之余，想起来给项目优化一下性能，于是决定研究一下多线程技术。</p>\n<blockquote>\n<p><code>多线程</code>，引用百度百科上面的话，就是指从软件或硬件上实现多个线程<code>并发执行</code>的技术。使用多线程的优点就在于可以把占据时间长得任务放在后台线程中去执行，避免影响主线程的运行，避免出现用户长时间等待操作，可以极好地提高程序的性能。<br>","more":"</p>\n<h1 id=\"iOS中的多线程\"><a href=\"#iOS中的多线程\" class=\"headerlink\" title=\"iOS中的多线程\"></a>iOS中的多线程</h1><p>在iOS开发中，有三种使用多线程开发的技术： <code>NSThread</code>、<code>NSOperation</code>和<code>GCD</code>。这三种多线程技术<code>抽象度</code>依次是越来越高，而抽象程度越高，使用起来越简单。我会在后面的文章中具体地讲述每一种多线程技术。</p>\n</blockquote>\n<h1 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h1><p>简单地说，<code>进程</code>是一个正在运行的程序的<code>实例</code>，拥有自己的地址空间，是系统资源分配和调度的一个独立单位；而<code>线程</code>则是进程中的一个实体，有时亦被称作是<code>轻量级的进程</code>。关于<code>进程</code>与<code>线程</code>的具体区分，我推荐大家可以阅读这篇博客<a href=\"http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html\">进程与线程的一个简单解释</a>。</p>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><p>学过数据结构的朋友应该都清楚<code>队列</code>的含义，它是一种常用的<code>数据结构</code>，是一种特殊的线性表，拥有<code>FIFO</code>（先进先出）的特性。在iOS多线程开发中，会经常使用到这种数据结构来存储线程。</p>\n<h1 id=\"串行队列与并行队列\"><a href=\"#串行队列与并行队列\" class=\"headerlink\" title=\"串行队列与并行队列\"></a>串行队列与并行队列</h1><p>iOS开发中的<code>串行队列</code>，指的是在队列中，所有的任务都是按顺序一条一条执行的，只有完成了上一条任务，才能执行下一条任务；而<code>并行队列</code>指的是一个队列中所有任务是可以同时运行的。\n　  </p>\n<h1 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h1><p><code>同步</code>与<code>异步</code>操作，针对的是线程这一级别的运行逻辑。<code>同步</code>是指在当前的线程中执行任务，不具备<code>开辟新线程</code>的能力；<code>异步</code>操作是指在新线程中执行任务，具有<code>开辟新线程</code>的能力。</p>\n<h1 id=\"基本规则：\"><a href=\"#基本规则：\" class=\"headerlink\" title=\"基本规则：\"></a>基本规则：</h1><ol>\n<li>串行队列中的任务会按顺序执行，并行队列中的任务通常会并发执行，而且无法确定任务的执行顺序。</li>\n<li>异步操作会新开辟线程来执行任务，而且无法确定执行顺序，同步操作不会新开辟线程</li>\n<li>在串行队列中执行同步任务：不会新建线程，按顺序执行任务</li>\n<li>在串行队列中执行异步任务，会新建线程，按顺序执行任务</li>\n<li>在并行队列中执行同步任务：不会新建线程，按顺序执行任务</li>\n<li>在并行队列中执行异步任务：会新建多个线程，但是无法确定任务的执行顺序</li>\n<li>全局队列是系统的，直接拿过来就可以用，与并行队列类似，但是不能指定队列的名字，调试时无法确认任务所在队列</li>\n<li>在全局队列中执行同步任务：不会新建线程，按顺序执行任务</li>\n<li>在全局队列中执行异步任务：会新建多个线程，但是无法确定任务的执行顺序</li>\n<li>每一个应用程序只有一个主线程即只有一个主队列</li>\n<li>在ios开发中，所有UI的更新任务都必须在主线程上执行。</li>\n<li>主队列中的操作都是主线程中执行的，不存在异步的概念      </li>\n<li>主队列中添加的同步操作永远不会被执行会死锁</li>\n</ol>"},{"layout":"post","title":"iOS多线程开发（五）GCD开发","date":"2015-08-04T16:00:00.000Z","_content":"\n# 前言\n我们在这一篇继之前的文章，记录另外一种更简单得使用多线程的方式，那就是`GCD`（Grand Central Dispatch）。`GCD`是libdispatch（Apple库）的代名词，为多核设备的并发处理和应用程序的性能优化提供了良好的支持。学习GCD之前，希望大家可以先温顾一下我在“多线程基础”这篇文章中提到的一些基础概念：`队列`，`串行与并行`，`同步与异步`。GCD使用C语言编写的一套提供并发处理的函数库，对于C语言熟悉的朋友，理解和使用起来应该会更简单。\n<!-- more -->\n# Dispatch Queues\n我们的程序进程中有一个`主队列`（main queue），所有与UI处理相关的操作都必须在主队列进行。我们可以使用`dispatch_get_main_queue`函数获取到主队列的引用，而且主队列是一个`串行队列`，所有的任务都是一个一个处理的。此外，系统还为我们提供了`并行队列`，就是`全局调度队列`（Global Dispatch Queue），按优先级不同可以分为：\n{% codeblock lang:objc %}\nDISPATCH_QUEUE_PRIORITY_HIGH；\nDISPATCH_QUEUE_DEFAULT；\nDISPATCH_QUEUE_LOW；\nDISPATCH_QUEUE_PRIORITY_BACKGROUND；\n{% endcodeblock %}\n\n我们可以使用`dispatch_get_global_queue`获取全局调度队列的引用。此外，我们也可以使用`dispatch_queue_create`函数创建自己的队列：\n{% codeblock lang:objc %}　\ndispatch_queue_t   myQueue = dispatch_queue_create(\"myQueue\",NULL);\n{% endcodeblock %}\n\n# Synchronous and Asynchronous\nGCD提供了俩个函数分别代表了`同步`与`异步`操作：`dispatch_sync`代表`同步`执行任务，`dispatch_async`代表`异步`执行操作。这俩个函数都结合`block`进行使用的。\n\n# 单例线程安全\n`单例模式`是开发中常常应用到的一种设计模式，而单例也会遇到线程安全的问题，如果多个线程同时访问并初始化一个单例对象，就会可能破坏掉单例的安全性，即使得资源变得不可信。GCD提供了单例线程的安全处理：\n{% codeblock lang:objc %}\n+ (instancetype)sharedContext\n{\nstatic MyContext *sharedContext = nil;\nstaticdispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\nsharedContext = [[MyContext alloc] init];\nNSLog(@\"Singleton has memory address at: %@\", sharedContext);\n});\nreturn sharedPhotoManager;\n}\n{% endcodeblock %}\n\n# Dispatch Group\n如果当前进程中有俩个非主线程，而这俩个线程是并行执行的，现在的需求是当这俩个线程都执行完后，汇总结果再执行下面的任务。针对这种情况，我们就可以应用到`dispatch_group`的概念，将多个线程同时加入到group中，然后使用`dispatch_group_async`函数并行执行所有的线程，最后使用`dispatch_group_notify`函数来汇总结果。\n\n# 其他用法\nGCD中还提供了一些高级用法来帮助我们更好地使用多线程。例如，使用`dispatch_after`和`dispatch_time`来做一些延迟程序执行时间的事情，使用`dispatch_source`控制共享资源等等。","source":"_posts/iOS多线程开发（五）GCD.md","raw":"---\nlayout: post\ntitle: iOS多线程开发（五）GCD开发\ndate: 2015-08-05\ntags: [多线程]\ncategories: [多线程]\n---\n\n# 前言\n我们在这一篇继之前的文章，记录另外一种更简单得使用多线程的方式，那就是`GCD`（Grand Central Dispatch）。`GCD`是libdispatch（Apple库）的代名词，为多核设备的并发处理和应用程序的性能优化提供了良好的支持。学习GCD之前，希望大家可以先温顾一下我在“多线程基础”这篇文章中提到的一些基础概念：`队列`，`串行与并行`，`同步与异步`。GCD使用C语言编写的一套提供并发处理的函数库，对于C语言熟悉的朋友，理解和使用起来应该会更简单。\n<!-- more -->\n# Dispatch Queues\n我们的程序进程中有一个`主队列`（main queue），所有与UI处理相关的操作都必须在主队列进行。我们可以使用`dispatch_get_main_queue`函数获取到主队列的引用，而且主队列是一个`串行队列`，所有的任务都是一个一个处理的。此外，系统还为我们提供了`并行队列`，就是`全局调度队列`（Global Dispatch Queue），按优先级不同可以分为：\n{% codeblock lang:objc %}\nDISPATCH_QUEUE_PRIORITY_HIGH；\nDISPATCH_QUEUE_DEFAULT；\nDISPATCH_QUEUE_LOW；\nDISPATCH_QUEUE_PRIORITY_BACKGROUND；\n{% endcodeblock %}\n\n我们可以使用`dispatch_get_global_queue`获取全局调度队列的引用。此外，我们也可以使用`dispatch_queue_create`函数创建自己的队列：\n{% codeblock lang:objc %}　\ndispatch_queue_t   myQueue = dispatch_queue_create(\"myQueue\",NULL);\n{% endcodeblock %}\n\n# Synchronous and Asynchronous\nGCD提供了俩个函数分别代表了`同步`与`异步`操作：`dispatch_sync`代表`同步`执行任务，`dispatch_async`代表`异步`执行操作。这俩个函数都结合`block`进行使用的。\n\n# 单例线程安全\n`单例模式`是开发中常常应用到的一种设计模式，而单例也会遇到线程安全的问题，如果多个线程同时访问并初始化一个单例对象，就会可能破坏掉单例的安全性，即使得资源变得不可信。GCD提供了单例线程的安全处理：\n{% codeblock lang:objc %}\n+ (instancetype)sharedContext\n{\nstatic MyContext *sharedContext = nil;\nstaticdispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\nsharedContext = [[MyContext alloc] init];\nNSLog(@\"Singleton has memory address at: %@\", sharedContext);\n});\nreturn sharedPhotoManager;\n}\n{% endcodeblock %}\n\n# Dispatch Group\n如果当前进程中有俩个非主线程，而这俩个线程是并行执行的，现在的需求是当这俩个线程都执行完后，汇总结果再执行下面的任务。针对这种情况，我们就可以应用到`dispatch_group`的概念，将多个线程同时加入到group中，然后使用`dispatch_group_async`函数并行执行所有的线程，最后使用`dispatch_group_notify`函数来汇总结果。\n\n# 其他用法\nGCD中还提供了一些高级用法来帮助我们更好地使用多线程。例如，使用`dispatch_after`和`dispatch_time`来做一些延迟程序执行时间的事情，使用`dispatch_source`控制共享资源等等。","slug":"iOS多线程开发（五）GCD","published":1,"updated":"2016-04-12T06:48:04.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9ts000x94suc8oex3gm","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>我们在这一篇继之前的文章，记录另外一种更简单得使用多线程的方式，那就是<code>GCD</code>（Grand Central Dispatch）。<code>GCD</code>是libdispatch（Apple库）的代名词，为多核设备的并发处理和应用程序的性能优化提供了良好的支持。学习GCD之前，希望大家可以先温顾一下我在“多线程基础”这篇文章中提到的一些基础概念：<code>队列</code>，<code>串行与并行</code>，<code>同步与异步</code>。GCD使用C语言编写的一套提供并发处理的函数库，对于C语言熟悉的朋友，理解和使用起来应该会更简单。<br><a id=\"more\"></a></p>\n<h1 id=\"Dispatch-Queues\"><a href=\"#Dispatch-Queues\" class=\"headerlink\" title=\"Dispatch Queues\"></a>Dispatch Queues</h1><p>我们的程序进程中有一个<code>主队列</code>（main queue），所有与UI处理相关的操作都必须在主队列进行。我们可以使用<code>dispatch_get_main_queue</code>函数获取到主队列的引用，而且主队列是一个<code>串行队列</code>，所有的任务都是一个一个处理的。此外，系统还为我们提供了<code>并行队列</code>，就是<code>全局调度队列</code>（Global Dispatch Queue），按优先级不同可以分为：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DISPATCH_QUEUE_PRIORITY_HIGH；</span><br><span class=\"line\">DISPATCH_QUEUE_DEFAULT；</span><br><span class=\"line\">DISPATCH_QUEUE_LOW；</span><br><span class=\"line\">DISPATCH_QUEUE_PRIORITY_BACKGROUND；</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用<code>dispatch_get_global_queue</code>获取全局调度队列的引用。此外，我们也可以使用<code>dispatch_queue_create</code>函数创建自己的队列：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　</span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span>   myQueue = dispatch_queue_create(<span class=\"string\">\"myQueue\"</span>,<span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Synchronous-and-Asynchronous\"><a href=\"#Synchronous-and-Asynchronous\" class=\"headerlink\" title=\"Synchronous and Asynchronous\"></a>Synchronous and Asynchronous</h1><p>GCD提供了俩个函数分别代表了<code>同步</code>与<code>异步</code>操作：<code>dispatch_sync</code>代表<code>同步</code>执行任务，<code>dispatch_async</code>代表<code>异步</code>执行操作。这俩个函数都结合<code>block</code>进行使用的。</p>\n<h1 id=\"单例线程安全\"><a href=\"#单例线程安全\" class=\"headerlink\" title=\"单例线程安全\"></a>单例线程安全</h1><p><code>单例模式</code>是开发中常常应用到的一种设计模式，而单例也会遇到线程安全的问题，如果多个线程同时访问并初始化一个单例对象，就会可能破坏掉单例的安全性，即使得资源变得不可信。GCD提供了单例线程的安全处理：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)sharedContext</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">static</span> MyContext *sharedContext = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">staticdispatch_once_t onceToken;</span><br><span class=\"line\"><span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">sharedContext = [[MyContext alloc] init];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Singleton has memory address at: %@\"</span>, sharedContext);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">return</span> sharedPhotoManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Dispatch-Group\"><a href=\"#Dispatch-Group\" class=\"headerlink\" title=\"Dispatch Group\"></a>Dispatch Group</h1><p>如果当前进程中有俩个非主线程，而这俩个线程是并行执行的，现在的需求是当这俩个线程都执行完后，汇总结果再执行下面的任务。针对这种情况，我们就可以应用到<code>dispatch_group</code>的概念，将多个线程同时加入到group中，然后使用<code>dispatch_group_async</code>函数并行执行所有的线程，最后使用<code>dispatch_group_notify</code>函数来汇总结果。</p>\n<h1 id=\"其他用法\"><a href=\"#其他用法\" class=\"headerlink\" title=\"其他用法\"></a>其他用法</h1><p>GCD中还提供了一些高级用法来帮助我们更好地使用多线程。例如，使用<code>dispatch_after</code>和<code>dispatch_time</code>来做一些延迟程序执行时间的事情，使用<code>dispatch_source</code>控制共享资源等等。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>我们在这一篇继之前的文章，记录另外一种更简单得使用多线程的方式，那就是<code>GCD</code>（Grand Central Dispatch）。<code>GCD</code>是libdispatch（Apple库）的代名词，为多核设备的并发处理和应用程序的性能优化提供了良好的支持。学习GCD之前，希望大家可以先温顾一下我在“多线程基础”这篇文章中提到的一些基础概念：<code>队列</code>，<code>串行与并行</code>，<code>同步与异步</code>。GCD使用C语言编写的一套提供并发处理的函数库，对于C语言熟悉的朋友，理解和使用起来应该会更简单。<br>","more":"</p>\n<h1 id=\"Dispatch-Queues\"><a href=\"#Dispatch-Queues\" class=\"headerlink\" title=\"Dispatch Queues\"></a>Dispatch Queues</h1><p>我们的程序进程中有一个<code>主队列</code>（main queue），所有与UI处理相关的操作都必须在主队列进行。我们可以使用<code>dispatch_get_main_queue</code>函数获取到主队列的引用，而且主队列是一个<code>串行队列</code>，所有的任务都是一个一个处理的。此外，系统还为我们提供了<code>并行队列</code>，就是<code>全局调度队列</code>（Global Dispatch Queue），按优先级不同可以分为：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DISPATCH_QUEUE_PRIORITY_HIGH；</span><br><span class=\"line\">DISPATCH_QUEUE_DEFAULT；</span><br><span class=\"line\">DISPATCH_QUEUE_LOW；</span><br><span class=\"line\">DISPATCH_QUEUE_PRIORITY_BACKGROUND；</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用<code>dispatch_get_global_queue</code>获取全局调度队列的引用。此外，我们也可以使用<code>dispatch_queue_create</code>函数创建自己的队列：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　</span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span>   myQueue = dispatch_queue_create(<span class=\"string\">\"myQueue\"</span>,<span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Synchronous-and-Asynchronous\"><a href=\"#Synchronous-and-Asynchronous\" class=\"headerlink\" title=\"Synchronous and Asynchronous\"></a>Synchronous and Asynchronous</h1><p>GCD提供了俩个函数分别代表了<code>同步</code>与<code>异步</code>操作：<code>dispatch_sync</code>代表<code>同步</code>执行任务，<code>dispatch_async</code>代表<code>异步</code>执行操作。这俩个函数都结合<code>block</code>进行使用的。</p>\n<h1 id=\"单例线程安全\"><a href=\"#单例线程安全\" class=\"headerlink\" title=\"单例线程安全\"></a>单例线程安全</h1><p><code>单例模式</code>是开发中常常应用到的一种设计模式，而单例也会遇到线程安全的问题，如果多个线程同时访问并初始化一个单例对象，就会可能破坏掉单例的安全性，即使得资源变得不可信。GCD提供了单例线程的安全处理：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)sharedContext</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">static</span> MyContext *sharedContext = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">staticdispatch_once_t onceToken;</span><br><span class=\"line\"><span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">sharedContext = [[MyContext alloc] init];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Singleton has memory address at: %@\"</span>, sharedContext);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">return</span> sharedPhotoManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Dispatch-Group\"><a href=\"#Dispatch-Group\" class=\"headerlink\" title=\"Dispatch Group\"></a>Dispatch Group</h1><p>如果当前进程中有俩个非主线程，而这俩个线程是并行执行的，现在的需求是当这俩个线程都执行完后，汇总结果再执行下面的任务。针对这种情况，我们就可以应用到<code>dispatch_group</code>的概念，将多个线程同时加入到group中，然后使用<code>dispatch_group_async</code>函数并行执行所有的线程，最后使用<code>dispatch_group_notify</code>函数来汇总结果。</p>\n<h1 id=\"其他用法\"><a href=\"#其他用法\" class=\"headerlink\" title=\"其他用法\"></a>其他用法</h1><p>GCD中还提供了一些高级用法来帮助我们更好地使用多线程。例如，使用<code>dispatch_after</code>和<code>dispatch_time</code>来做一些延迟程序执行时间的事情，使用<code>dispatch_source</code>控制共享资源等等。</p>"},{"layout":"post","title":"iOS多线程开发（三）线程安全","date":"2015-08-02T16:00:00.000Z","_content":"\n# 前言\n在我们使用多线程技术进行开发的时候，无可避免地就要涉及到系统共享资源的安全隐患，也就是我们这篇博客中想要讨论的问题：`线程安全`。\n\n>关于`线程安全性`，引用一段`百度百科`里面的文字描述：当对一个复杂对象进行某种操作时，从操作开始到操作结束，被操作的对象往往会经历若干非法的中间状态。调用一个函数（假设该函数是正确的）操作某对象常常会使该对象暂时陷入不可用的状态（通常称为不稳定状态），等到操作完全结束，该对象才会重新回到完全可用的状态。如果其他线程企图访问一个处于不可用状态的对象，该对象将不能正确响应从而产生无法预料的结果，如何避免这种情况发生是线程安全性的核心问题。\n<!-- more -->\n# 线程同步\n具体到实际的开发中，为了确保`线程安全`，我们必须做到`线程同步`。所谓`线程同步`，就是多个线程在共享系统资源时，协同步调，按预定地先后顺序依次执行，确保数据的`正确性`与`安全性`。\n\n# 原子操作\niOS平台下的原子操作函数都以`OSAtomic`开头，使用时需要包含头文件`<libkern/OSAtomic.h>`。不同线程如果通过`原子操作`函数对同一变量进行操作，可以保证一个线程的操作不会影响到其他线程内对此变量的操作，因为这些操作都是`原子式`的。`原子操作`只能对`内置类型`进行操作，所以`原子操作`能够同步的线程只能位于同一个进程的地址空间内。关于无锁编程的更多讲解，我推荐朋友们阅读这篇文章------[无锁编程以及CAS](http://www.cnblogs.com/caca/p/lock-free_CAS_ABA.html)。\n\nObjective-C语言中，在定义一个属性时可以在`@property`的参数中选择`atomic`和`nonatomic`，既代表`原子性`（线程安全）和`非原子性`（线程不安全）。然而达到属性的线程安全会消耗大量的系统资源，因而并不适合内存较小的移动设备，所以一般我们都会设置属性的非原子性。而涉及到线程安全的一些数据时，一般要把线程同步地逻辑放在Server端。\n\n# 使用“锁”\n在Objective-C语言中，锁有很多种：`NSLock`（一般锁），`NSRecursiveLock`（递归锁），`NSConditionLock`（条件锁）。关于这些锁的具体使用，大家可以查看官方文档，这里我也给大家推荐一篇博文----- [iOS 多线程 锁 互斥 同步](http://blog.csdn.net/likendsl/article/details/8568961)。在Objective-C中还有另外一种使用“锁”的机制，就是`NSCondition`,这里封装了`加锁`和`解锁`的操作，想研究的朋友可以直接查阅官方文档。\n\n# @synchronized\n利用@synchronized互斥锁来锁住代码，直接使用于加锁的对象。\n{% codeblock lang:objc %}\n@synchronized(self) {\n    printf(\"\\n\");\n   //加锁代码\n}\n{% endcodeblock %}","source":"_posts/iOS多线程开发（三）线程安全.md","raw":"---\nlayout: post\ntitle: iOS多线程开发（三）线程安全\ndate: 2015-08-03\ntags: [多线程]\ncategories: [多线程]\n---\n\n# 前言\n在我们使用多线程技术进行开发的时候，无可避免地就要涉及到系统共享资源的安全隐患，也就是我们这篇博客中想要讨论的问题：`线程安全`。\n\n>关于`线程安全性`，引用一段`百度百科`里面的文字描述：当对一个复杂对象进行某种操作时，从操作开始到操作结束，被操作的对象往往会经历若干非法的中间状态。调用一个函数（假设该函数是正确的）操作某对象常常会使该对象暂时陷入不可用的状态（通常称为不稳定状态），等到操作完全结束，该对象才会重新回到完全可用的状态。如果其他线程企图访问一个处于不可用状态的对象，该对象将不能正确响应从而产生无法预料的结果，如何避免这种情况发生是线程安全性的核心问题。\n<!-- more -->\n# 线程同步\n具体到实际的开发中，为了确保`线程安全`，我们必须做到`线程同步`。所谓`线程同步`，就是多个线程在共享系统资源时，协同步调，按预定地先后顺序依次执行，确保数据的`正确性`与`安全性`。\n\n# 原子操作\niOS平台下的原子操作函数都以`OSAtomic`开头，使用时需要包含头文件`<libkern/OSAtomic.h>`。不同线程如果通过`原子操作`函数对同一变量进行操作，可以保证一个线程的操作不会影响到其他线程内对此变量的操作，因为这些操作都是`原子式`的。`原子操作`只能对`内置类型`进行操作，所以`原子操作`能够同步的线程只能位于同一个进程的地址空间内。关于无锁编程的更多讲解，我推荐朋友们阅读这篇文章------[无锁编程以及CAS](http://www.cnblogs.com/caca/p/lock-free_CAS_ABA.html)。\n\nObjective-C语言中，在定义一个属性时可以在`@property`的参数中选择`atomic`和`nonatomic`，既代表`原子性`（线程安全）和`非原子性`（线程不安全）。然而达到属性的线程安全会消耗大量的系统资源，因而并不适合内存较小的移动设备，所以一般我们都会设置属性的非原子性。而涉及到线程安全的一些数据时，一般要把线程同步地逻辑放在Server端。\n\n# 使用“锁”\n在Objective-C语言中，锁有很多种：`NSLock`（一般锁），`NSRecursiveLock`（递归锁），`NSConditionLock`（条件锁）。关于这些锁的具体使用，大家可以查看官方文档，这里我也给大家推荐一篇博文----- [iOS 多线程 锁 互斥 同步](http://blog.csdn.net/likendsl/article/details/8568961)。在Objective-C中还有另外一种使用“锁”的机制，就是`NSCondition`,这里封装了`加锁`和`解锁`的操作，想研究的朋友可以直接查阅官方文档。\n\n# @synchronized\n利用@synchronized互斥锁来锁住代码，直接使用于加锁的对象。\n{% codeblock lang:objc %}\n@synchronized(self) {\n    printf(\"\\n\");\n   //加锁代码\n}\n{% endcodeblock %}","slug":"iOS多线程开发（三）线程安全","published":1,"updated":"2016-04-12T06:47:16.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9tt001094suftl82n1b","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在我们使用多线程技术进行开发的时候，无可避免地就要涉及到系统共享资源的安全隐患，也就是我们这篇博客中想要讨论的问题：<code>线程安全</code>。</p>\n<blockquote>\n<p>关于<code>线程安全性</code>，引用一段<code>百度百科</code>里面的文字描述：当对一个复杂对象进行某种操作时，从操作开始到操作结束，被操作的对象往往会经历若干非法的中间状态。调用一个函数（假设该函数是正确的）操作某对象常常会使该对象暂时陷入不可用的状态（通常称为不稳定状态），等到操作完全结束，该对象才会重新回到完全可用的状态。如果其他线程企图访问一个处于不可用状态的对象，该对象将不能正确响应从而产生无法预料的结果，如何避免这种情况发生是线程安全性的核心问题。<br><a id=\"more\"></a></p>\n<h1 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h1><p>具体到实际的开发中，为了确保<code>线程安全</code>，我们必须做到<code>线程同步</code>。所谓<code>线程同步</code>，就是多个线程在共享系统资源时，协同步调，按预定地先后顺序依次执行，确保数据的<code>正确性</code>与<code>安全性</code>。</p>\n</blockquote>\n<h1 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h1><p>iOS平台下的原子操作函数都以<code>OSAtomic</code>开头，使用时需要包含头文件<code>&lt;libkern/OSAtomic.h&gt;</code>。不同线程如果通过<code>原子操作</code>函数对同一变量进行操作，可以保证一个线程的操作不会影响到其他线程内对此变量的操作，因为这些操作都是<code>原子式</code>的。<code>原子操作</code>只能对<code>内置类型</code>进行操作，所以<code>原子操作</code>能够同步的线程只能位于同一个进程的地址空间内。关于无锁编程的更多讲解，我推荐朋友们阅读这篇文章——<a href=\"http://www.cnblogs.com/caca/p/lock-free_CAS_ABA.html\" target=\"_blank\" rel=\"external\">无锁编程以及CAS</a>。</p>\n<p>Objective-C语言中，在定义一个属性时可以在<code>@property</code>的参数中选择<code>atomic</code>和<code>nonatomic</code>，既代表<code>原子性</code>（线程安全）和<code>非原子性</code>（线程不安全）。然而达到属性的线程安全会消耗大量的系统资源，因而并不适合内存较小的移动设备，所以一般我们都会设置属性的非原子性。而涉及到线程安全的一些数据时，一般要把线程同步地逻辑放在Server端。</p>\n<h1 id=\"使用“锁”\"><a href=\"#使用“锁”\" class=\"headerlink\" title=\"使用“锁”\"></a>使用“锁”</h1><p>在Objective-C语言中，锁有很多种：<code>NSLock</code>（一般锁），<code>NSRecursiveLock</code>（递归锁），<code>NSConditionLock</code>（条件锁）。关于这些锁的具体使用，大家可以查看官方文档，这里我也给大家推荐一篇博文—– <a href=\"http://blog.csdn.net/likendsl/article/details/8568961\" target=\"_blank\" rel=\"external\">iOS 多线程 锁 互斥 同步</a>。在Objective-C中还有另外一种使用“锁”的机制，就是<code>NSCondition</code>,这里封装了<code>加锁</code>和<code>解锁</code>的操作，想研究的朋友可以直接查阅官方文档。</p>\n<h1 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"@synchronized\"></a>@synchronized</h1><p>利用@synchronized互斥锁来锁住代码，直接使用于加锁的对象。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">    printf(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">   <span class=\"comment\">//加锁代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在我们使用多线程技术进行开发的时候，无可避免地就要涉及到系统共享资源的安全隐患，也就是我们这篇博客中想要讨论的问题：<code>线程安全</code>。</p>\n<blockquote>\n<p>关于<code>线程安全性</code>，引用一段<code>百度百科</code>里面的文字描述：当对一个复杂对象进行某种操作时，从操作开始到操作结束，被操作的对象往往会经历若干非法的中间状态。调用一个函数（假设该函数是正确的）操作某对象常常会使该对象暂时陷入不可用的状态（通常称为不稳定状态），等到操作完全结束，该对象才会重新回到完全可用的状态。如果其他线程企图访问一个处于不可用状态的对象，该对象将不能正确响应从而产生无法预料的结果，如何避免这种情况发生是线程安全性的核心问题。<br>","more":"</p>\n<h1 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h1><p>具体到实际的开发中，为了确保<code>线程安全</code>，我们必须做到<code>线程同步</code>。所谓<code>线程同步</code>，就是多个线程在共享系统资源时，协同步调，按预定地先后顺序依次执行，确保数据的<code>正确性</code>与<code>安全性</code>。</p>\n</blockquote>\n<h1 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h1><p>iOS平台下的原子操作函数都以<code>OSAtomic</code>开头，使用时需要包含头文件<code>&lt;libkern/OSAtomic.h&gt;</code>。不同线程如果通过<code>原子操作</code>函数对同一变量进行操作，可以保证一个线程的操作不会影响到其他线程内对此变量的操作，因为这些操作都是<code>原子式</code>的。<code>原子操作</code>只能对<code>内置类型</code>进行操作，所以<code>原子操作</code>能够同步的线程只能位于同一个进程的地址空间内。关于无锁编程的更多讲解，我推荐朋友们阅读这篇文章——<a href=\"http://www.cnblogs.com/caca/p/lock-free_CAS_ABA.html\">无锁编程以及CAS</a>。</p>\n<p>Objective-C语言中，在定义一个属性时可以在<code>@property</code>的参数中选择<code>atomic</code>和<code>nonatomic</code>，既代表<code>原子性</code>（线程安全）和<code>非原子性</code>（线程不安全）。然而达到属性的线程安全会消耗大量的系统资源，因而并不适合内存较小的移动设备，所以一般我们都会设置属性的非原子性。而涉及到线程安全的一些数据时，一般要把线程同步地逻辑放在Server端。</p>\n<h1 id=\"使用“锁”\"><a href=\"#使用“锁”\" class=\"headerlink\" title=\"使用“锁”\"></a>使用“锁”</h1><p>在Objective-C语言中，锁有很多种：<code>NSLock</code>（一般锁），<code>NSRecursiveLock</code>（递归锁），<code>NSConditionLock</code>（条件锁）。关于这些锁的具体使用，大家可以查看官方文档，这里我也给大家推荐一篇博文—– <a href=\"http://blog.csdn.net/likendsl/article/details/8568961\">iOS 多线程 锁 互斥 同步</a>。在Objective-C中还有另外一种使用“锁”的机制，就是<code>NSCondition</code>,这里封装了<code>加锁</code>和<code>解锁</code>的操作，想研究的朋友可以直接查阅官方文档。</p>\n<h1 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"@synchronized\"></a>@synchronized</h1><p>利用@synchronized互斥锁来锁住代码，直接使用于加锁的对象。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">    printf(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">   <span class=\"comment\">//加锁代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"layout":"post","title":"iOS多线程开发（二）使用NSThread","date":"2015-08-01T16:00:00.000Z","_content":"\n# 前言　　\n在上一篇博客中，我们讲述了`多线程`的基础知识，也谈到了iOS开发中三个使用多线程的技术，`NSThread`、`NSOperation`和`GCD`；我们在这一篇中，主要讲一下第一种多线程技术`NSThread`。相比于其他俩种技术，`NSThread`具有更`轻量级`的优点，也是可以完全控制，完全负责的，也是最麻烦的。我们需要手动地管理线程的生命周期和同步的问题，这里的同步指的是系统资源地分配和调度上的同步。\n<!-- more -->\n# NSThread创建\n`NSThread`的一个实例对象就代表着一条线程，创建一条线程主要有下面几种方法：\n{% codeblock lang:objc %}\n1. -（instancetype)initWithTarget:(id)target selector:(SEL)selector object:(id)argument\n{% endcodeblock %}\n使用NSThread的实例方法来创建一条线程，创建之后，必须调用```[yourThread　start]```启动线程.使用这种方法创建线程，我们可以对线程进行控制，例如设置线程名称，优先级，栈尺寸等。\n \n{% codeblock lang:objc %}\n2. + (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument;\n{% endcodeblock %}\n使用类方法直接创建并开启一条线程，无需其他操作，但是无法对线程进行进一步的控制\n\n{% codeblock objc %}\n3. NSObject -- performSelectorInBackground:(SEL）aSelector withObject:(id)arg\n{% endcodeblock %}\n非显示地创建一条线程，同样是无法对线程进行控制\n\n# 常用属性方法\nNSThread还拥有一些常用的属性和方法，可以让我们对线程进行控制，例如：\n \n1. `+ (NSThread *)currentThread`\n顾名思义，就是获取当前线程。\n\n2. `@property double threadPriority`\n在最新的SDK中被另外一个属性NSQualityOfService替代，标识线程优先级，并且在线程启动后是只读的。\n\n3. `+ （NSThread *）mainThread`\n获取程序的主线程\n\n4. `@property NSUInteger stackSize`\n标识线程的栈空间的大小，我们可以通过setter方法来改变线程栈空间优化内存。\n\n5. `+ （void）exit  ` 与　`- （void）cancel`\n如果我们想中断一个线程的运行时，按照许多前辈地建议，我们最好先用cancel实例方法来标记一下线程，这个方法只是给线程一个判断位，然后根据属性判断```isCancelled```的值，确实之后再调用```exit```类方法彻底结束线程。后来看到一篇文档上写到，当使用```sleepForTimeInterval:```方法使得线程处于休眠状态时，这个时候调用```cancel```是没有作用的，当线程醒过来之后，依然会执行任务。\n\n# 线程通信\n一个进程中的线程并不是各自独立的，他们往往需要相互通信，例如，有时候会把占据时间的下载任务放到后台线程中，等到数据下载完之后把数据传到主线程中去更新界面。在`NSObject`的catogery　`NSThreadPerformAdditions`中就提供了几个线程之间的通信方法：\n{% codeblock lang:objc %}\n1. - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait\n2. - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait\n{% endcodeblock %}","source":"_posts/iOS多线程开发（二）使用NSThread.md","raw":"---\nlayout: post\ntitle: iOS多线程开发（二）使用NSThread\ndate: 2015-08-02\ntags: [多线程]\ncategories: [多线程]\n---\n\n# 前言　　\n在上一篇博客中，我们讲述了`多线程`的基础知识，也谈到了iOS开发中三个使用多线程的技术，`NSThread`、`NSOperation`和`GCD`；我们在这一篇中，主要讲一下第一种多线程技术`NSThread`。相比于其他俩种技术，`NSThread`具有更`轻量级`的优点，也是可以完全控制，完全负责的，也是最麻烦的。我们需要手动地管理线程的生命周期和同步的问题，这里的同步指的是系统资源地分配和调度上的同步。\n<!-- more -->\n# NSThread创建\n`NSThread`的一个实例对象就代表着一条线程，创建一条线程主要有下面几种方法：\n{% codeblock lang:objc %}\n1. -（instancetype)initWithTarget:(id)target selector:(SEL)selector object:(id)argument\n{% endcodeblock %}\n使用NSThread的实例方法来创建一条线程，创建之后，必须调用```[yourThread　start]```启动线程.使用这种方法创建线程，我们可以对线程进行控制，例如设置线程名称，优先级，栈尺寸等。\n \n{% codeblock lang:objc %}\n2. + (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument;\n{% endcodeblock %}\n使用类方法直接创建并开启一条线程，无需其他操作，但是无法对线程进行进一步的控制\n\n{% codeblock objc %}\n3. NSObject -- performSelectorInBackground:(SEL）aSelector withObject:(id)arg\n{% endcodeblock %}\n非显示地创建一条线程，同样是无法对线程进行控制\n\n# 常用属性方法\nNSThread还拥有一些常用的属性和方法，可以让我们对线程进行控制，例如：\n \n1. `+ (NSThread *)currentThread`\n顾名思义，就是获取当前线程。\n\n2. `@property double threadPriority`\n在最新的SDK中被另外一个属性NSQualityOfService替代，标识线程优先级，并且在线程启动后是只读的。\n\n3. `+ （NSThread *）mainThread`\n获取程序的主线程\n\n4. `@property NSUInteger stackSize`\n标识线程的栈空间的大小，我们可以通过setter方法来改变线程栈空间优化内存。\n\n5. `+ （void）exit  ` 与　`- （void）cancel`\n如果我们想中断一个线程的运行时，按照许多前辈地建议，我们最好先用cancel实例方法来标记一下线程，这个方法只是给线程一个判断位，然后根据属性判断```isCancelled```的值，确实之后再调用```exit```类方法彻底结束线程。后来看到一篇文档上写到，当使用```sleepForTimeInterval:```方法使得线程处于休眠状态时，这个时候调用```cancel```是没有作用的，当线程醒过来之后，依然会执行任务。\n\n# 线程通信\n一个进程中的线程并不是各自独立的，他们往往需要相互通信，例如，有时候会把占据时间的下载任务放到后台线程中，等到数据下载完之后把数据传到主线程中去更新界面。在`NSObject`的catogery　`NSThreadPerformAdditions`中就提供了几个线程之间的通信方法：\n{% codeblock lang:objc %}\n1. - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait\n2. - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait\n{% endcodeblock %}","slug":"iOS多线程开发（二）使用NSThread","published":1,"updated":"2016-04-12T06:46:56.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9ty001494suxpm90srh","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>在上一篇博客中，我们讲述了<code>多线程</code>的基础知识，也谈到了iOS开发中三个使用多线程的技术，<code>NSThread</code>、<code>NSOperation</code>和<code>GCD</code>；我们在这一篇中，主要讲一下第一种多线程技术<code>NSThread</code>。相比于其他俩种技术，<code>NSThread</code>具有更<code>轻量级</code>的优点，也是可以完全控制，完全负责的，也是最麻烦的。我们需要手动地管理线程的生命周期和同步的问题，这里的同步指的是系统资源地分配和调度上的同步。<br><a id=\"more\"></a></p>\n<h1 id=\"NSThread创建\"><a href=\"#NSThread创建\" class=\"headerlink\" title=\"NSThread创建\"></a>NSThread创建</h1><p><code>NSThread</code>的一个实例对象就代表着一条线程，创建一条线程主要有下面几种方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> -（instancetype)initWithTarget:(<span class=\"keyword\">id</span>)target selector:(SEL)selector object:(<span class=\"keyword\">id</span>)argument</span><br></pre></td></tr></table></figure><br>使用NSThread的实例方法来创建一条线程，创建之后，必须调用<code>[yourThread　start]</code>启动线程.使用这种方法创建线程，我们可以对线程进行控制，例如设置线程名称，优先级，栈尺寸等。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2.</span> + (<span class=\"keyword\">void</span>)detachNewThreadSelector:(SEL)selector toTarget:(<span class=\"keyword\">id</span>)target withObject:(<span class=\"keyword\">id</span>)argument;</span><br></pre></td></tr></table></figure>\n<p>使用类方法直接创建并开启一条线程，无需其他操作，但是无法对线程进行进一步的控制</p>\n<figure class=\"highlight plain\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. NSObject -- performSelectorInBackground:(SEL）aSelector withObject:(id)arg</span><br></pre></td></tr></table></figure>\n<p>非显示地创建一条线程，同样是无法对线程进行控制</p>\n<h1 id=\"常用属性方法\"><a href=\"#常用属性方法\" class=\"headerlink\" title=\"常用属性方法\"></a>常用属性方法</h1><p>NSThread还拥有一些常用的属性和方法，可以让我们对线程进行控制，例如：</p>\n<ol>\n<li><p><code>+ (NSThread *)currentThread</code><br>顾名思义，就是获取当前线程。</p>\n</li>\n<li><p><code>@property double threadPriority</code><br>在最新的SDK中被另外一个属性NSQualityOfService替代，标识线程优先级，并且在线程启动后是只读的。</p>\n</li>\n<li><p><code>+ （NSThread *）mainThread</code><br>获取程序的主线程</p>\n</li>\n<li><p><code>@property NSUInteger stackSize</code><br>标识线程的栈空间的大小，我们可以通过setter方法来改变线程栈空间优化内存。</p>\n</li>\n<li><p><code>+ （void）exit</code> 与　<code>- （void）cancel</code><br>如果我们想中断一个线程的运行时，按照许多前辈地建议，我们最好先用cancel实例方法来标记一下线程，这个方法只是给线程一个判断位，然后根据属性判断<code>isCancelled</code>的值，确实之后再调用<code>exit</code>类方法彻底结束线程。后来看到一篇文档上写到，当使用<code>sleepForTimeInterval:</code>方法使得线程处于休眠状态时，这个时候调用<code>cancel</code>是没有作用的，当线程醒过来之后，依然会执行任务。</p>\n</li>\n</ol>\n<h1 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h1><p>一个进程中的线程并不是各自独立的，他们往往需要相互通信，例如，有时候会把占据时间的下载任务放到后台线程中，等到数据下载完之后把数据传到主线程中去更新界面。在<code>NSObject</code>的catogery　<code>NSThreadPerformAdditions</code>中就提供了几个线程之间的通信方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> - (<span class=\"keyword\">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class=\"keyword\">id</span>)arg waitUntilDone:(<span class=\"built_in\">BOOL</span>)wait</span><br><span class=\"line\"><span class=\"number\">2.</span> - (<span class=\"keyword\">void</span>)performSelector:(SEL)aSelector onThread:(<span class=\"built_in\">NSThread</span> *)thr withObject:(<span class=\"keyword\">id</span>)arg waitUntilDone:(<span class=\"built_in\">BOOL</span>)wait</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>在上一篇博客中，我们讲述了<code>多线程</code>的基础知识，也谈到了iOS开发中三个使用多线程的技术，<code>NSThread</code>、<code>NSOperation</code>和<code>GCD</code>；我们在这一篇中，主要讲一下第一种多线程技术<code>NSThread</code>。相比于其他俩种技术，<code>NSThread</code>具有更<code>轻量级</code>的优点，也是可以完全控制，完全负责的，也是最麻烦的。我们需要手动地管理线程的生命周期和同步的问题，这里的同步指的是系统资源地分配和调度上的同步。<br>","more":"</p>\n<h1 id=\"NSThread创建\"><a href=\"#NSThread创建\" class=\"headerlink\" title=\"NSThread创建\"></a>NSThread创建</h1><p><code>NSThread</code>的一个实例对象就代表着一条线程，创建一条线程主要有下面几种方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> -（instancetype)initWithTarget:(<span class=\"keyword\">id</span>)target selector:(SEL)selector object:(<span class=\"keyword\">id</span>)argument</span><br></pre></td></tr></table></figure><br>使用NSThread的实例方法来创建一条线程，创建之后，必须调用<code>[yourThread　start]</code>启动线程.使用这种方法创建线程，我们可以对线程进行控制，例如设置线程名称，优先级，栈尺寸等。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2.</span> + (<span class=\"keyword\">void</span>)detachNewThreadSelector:(SEL)selector toTarget:(<span class=\"keyword\">id</span>)target withObject:(<span class=\"keyword\">id</span>)argument;</span><br></pre></td></tr></table></figure>\n<p>使用类方法直接创建并开启一条线程，无需其他操作，但是无法对线程进行进一步的控制</p>\n<figure class=\"highlight plain\"><figcaption><span>objc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. NSObject -- performSelectorInBackground:(SEL）aSelector withObject:(id)arg</span><br></pre></td></tr></table></figure>\n<p>非显示地创建一条线程，同样是无法对线程进行控制</p>\n<h1 id=\"常用属性方法\"><a href=\"#常用属性方法\" class=\"headerlink\" title=\"常用属性方法\"></a>常用属性方法</h1><p>NSThread还拥有一些常用的属性和方法，可以让我们对线程进行控制，例如：</p>\n<ol>\n<li><p><code>+ (NSThread *)currentThread</code><br>顾名思义，就是获取当前线程。</p>\n</li>\n<li><p><code>@property double threadPriority</code><br>在最新的SDK中被另外一个属性NSQualityOfService替代，标识线程优先级，并且在线程启动后是只读的。</p>\n</li>\n<li><p><code>+ （NSThread *）mainThread</code><br>获取程序的主线程</p>\n</li>\n<li><p><code>@property NSUInteger stackSize</code><br>标识线程的栈空间的大小，我们可以通过setter方法来改变线程栈空间优化内存。</p>\n</li>\n<li><p><code>+ （void）exit</code> 与　<code>- （void）cancel</code><br>如果我们想中断一个线程的运行时，按照许多前辈地建议，我们最好先用cancel实例方法来标记一下线程，这个方法只是给线程一个判断位，然后根据属性判断<code>isCancelled</code>的值，确实之后再调用<code>exit</code>类方法彻底结束线程。后来看到一篇文档上写到，当使用<code>sleepForTimeInterval:</code>方法使得线程处于休眠状态时，这个时候调用<code>cancel</code>是没有作用的，当线程醒过来之后，依然会执行任务。</p>\n</li>\n</ol>\n<h1 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h1><p>一个进程中的线程并不是各自独立的，他们往往需要相互通信，例如，有时候会把占据时间的下载任务放到后台线程中，等到数据下载完之后把数据传到主线程中去更新界面。在<code>NSObject</code>的catogery　<code>NSThreadPerformAdditions</code>中就提供了几个线程之间的通信方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> - (<span class=\"keyword\">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class=\"keyword\">id</span>)arg waitUntilDone:(<span class=\"built_in\">BOOL</span>)wait</span><br><span class=\"line\"><span class=\"number\">2.</span> - (<span class=\"keyword\">void</span>)performSelector:(SEL)aSelector onThread:(<span class=\"built_in\">NSThread</span> *)thr withObject:(<span class=\"keyword\">id</span>)arg waitUntilDone:(<span class=\"built_in\">BOOL</span>)wait</span><br></pre></td></tr></table></figure></p>"},{"layout":"post","title":"iOS多线程开发（四）NSOperation和NSOperationQueue","date":"2015-08-03T16:00:00.000Z","_content":"\n# 前言\n在前几篇中，我们讲述了多线程的基础概念和在iOS开发中应用多线程的方法。我们在这一篇继续讨论在iOS开发中使用多线程的一种方式，使用`NSOperation`和`NSOperationQueue`。`NSOperation`的实例代表一个任务，默认封装了需要执行的操作和数据，从而简化了我们很多的操作，我们不必在关心底层的线程的运行和状态，只需要把精力放在我们需要执行的操作上。\n<!-- more -->\n# 使用方式\n`NSOperation`是一个`抽象类`，有俩种使用方式。第一种就是使用`Foundation`框架中提供的`NSOperation`的俩个子类：`NSInvocationOperation`和`NSBlockOperation`,第二种就是`自定义`类并继承NSOperation。\n\n# NSInvocationOperation\n1)封装要执行的操作\n\n{% codeblock lang:objc %}\nNSInvocationOperation *operation = [[NSInvocationOperationalloc] initWithTarget:selfselector:@selector(temp) object:nil];\n{% endcodeblock %}\n\n2)开始操作,一旦开始就会执行封装的操作，并且默认是在主线程执行\n\n{% codeblock lang:objc %}\n[operation start];\n{% endcodeblock %}\n\n# NSBlockOperation\n1)创建操作对象，与Objective-C中的block机制结合使用\n{% codeblock lang:objc %}\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^(void){\n    //添加要执行的操作\n}];\n{% endcodeblock %}\n\n2)添加新的操作\n{% codeblock lang:objc %}\n[operation addExecutionBlock:^(void){\n    //添加要执行的操作\n}];\n{% endcodeblock %}\n\n3)开始执行操作，当添加到当前操作对象的block操作数大于1时，会异步执行操作，并发执行所有操作\n{% codeblock lang:objc %}\n[operation start];     \n{% endcodeblock %}\n\n# 常用方法与属性\n1) Cancel\n{% codeblock lang:objc %}\n@property （getter=isCancelled) BOOL cancelled和　- （void）cancel\n{% endcodeblock %}\n\ncancel方法可以取消当前操作，而isCancelled方法可以检测操作是否已经被取消，实际开发中我们可能会频繁地调用isCancelled,而它本身非常地轻量级，不会对我们项目地性能产生较大地损失。\n\n2）添加依赖\n{% codeblock lang:objc %}\n- （void）addDependency：（NSOperation *）op\n{% endcodeblock %}\n\n为操作对象添加依赖操作，只有依赖的操作op执行完之后才会开始执行当前的操作对象。\n\n3）completionBlock\n{% codeblock lang:objc %}\n@property （copy） void （^completionBlock）(void)\n{% endcodeblock %}\n\n当前操作执行完后可执行的block，我们可以通过setCompletionBlock：来添加在操作对象执行完后我们想执行的任务。\n\n# 自定义子类\n如果上面的这些属性和方法还不满足需求的话，我们还可以自定义一个`NSOperation`的子类，封装一些我们想要的操作和数据。一个`main`函数基本上是程序的标准入口，所有的线程的开启也是通过`main`方法，所以如果我们自定义`NSOperation`子类的话，必须在子类中重写main方法。\n{% codeblock lang:objc %}\n-（void）main{\n    //我们必须为自定义的operation提供autorelease pool，因为operation完成之后需要销毁\n    @autoreleasepool{\n        //添加自己的操作逻辑\n    };\n}\n{% endcodeblock %}\n\n除此之外，我们也需要重写一些其他的基本方法，如：```start```，```isFinished```，```isExecuting```等，并且需要实现`KVO`机制。\n\n我们自定义的`NSOperation`子类，可以设置操作是异步执行，还是同步执行，一般默认的都是同步执行，想要我们自定义的operation异步执行，我们需要重写`isConcurrent`这个方法并且返回YES，iOS7.0以后的SDK中，`isConcurrent`被`isAsynchronous`取代了。\n\n#使用NSOperationQueue\n为了异步执行我们的操作，我们可以将operation添加到一个`NSOperationQueue`中去执行。一个`NSOperationQueue`操作队列，就相当于一个线程管理器，允许我们添加自己的operation。一旦把operation通过addOperation：方法加到操作队列中，operation就开始被处理，直到完成或者取消，然后被释放掉。\n\n1)创建操作队列，并添加操作\n{% codeblock lang:objc %}\nNSOperationQueue *queue = [[NSOperationQueuealloc]init];\n//添加一个operation\n[queue addOperation:operation];\n//添加一组operations\n[queue addOperations:operations waitUntilFinished:NO];\n{% endcodeblock %}\n\n2)执行顺序\noperation被添加到操作队列后，通常会按添加顺序依次得到执行，但是一个操作队列中的operation之间存在依赖关系，我们可以通过`NSOperation`的`addDependency：`方法为操作添加依赖；而且operation都有一个`NSOperationQueuePriority`优先级属性，这些都会影响操作队列中的operation的执行顺序。\n\n3)并发任务数量\n一个操作队列可以设置并发操作的数量，意思就是队列中最多可以同时运行几条线程。因为默认地，一个`NSOperationQueue`操作队列会为每一个operation提供一条线程来运行，operation之间是并发执行操作的。\n{% codeblock lang:objc %}\n//模拟串行队列，每次只允许执行一个操作，既只有一条线程\n[queue setMaxConcurrentOperationCount:1]\n{% endcodeblock %}","source":"_posts/iOS多线程开发（四）NSOperation和NSOperationQueue.md","raw":"---\nlayout: post\ntitle: iOS多线程开发（四）NSOperation和NSOperationQueue\ndate: 2015-08-04\ntags: [多线程]\ncategories: [多线程]\n---\n\n# 前言\n在前几篇中，我们讲述了多线程的基础概念和在iOS开发中应用多线程的方法。我们在这一篇继续讨论在iOS开发中使用多线程的一种方式，使用`NSOperation`和`NSOperationQueue`。`NSOperation`的实例代表一个任务，默认封装了需要执行的操作和数据，从而简化了我们很多的操作，我们不必在关心底层的线程的运行和状态，只需要把精力放在我们需要执行的操作上。\n<!-- more -->\n# 使用方式\n`NSOperation`是一个`抽象类`，有俩种使用方式。第一种就是使用`Foundation`框架中提供的`NSOperation`的俩个子类：`NSInvocationOperation`和`NSBlockOperation`,第二种就是`自定义`类并继承NSOperation。\n\n# NSInvocationOperation\n1)封装要执行的操作\n\n{% codeblock lang:objc %}\nNSInvocationOperation *operation = [[NSInvocationOperationalloc] initWithTarget:selfselector:@selector(temp) object:nil];\n{% endcodeblock %}\n\n2)开始操作,一旦开始就会执行封装的操作，并且默认是在主线程执行\n\n{% codeblock lang:objc %}\n[operation start];\n{% endcodeblock %}\n\n# NSBlockOperation\n1)创建操作对象，与Objective-C中的block机制结合使用\n{% codeblock lang:objc %}\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^(void){\n    //添加要执行的操作\n}];\n{% endcodeblock %}\n\n2)添加新的操作\n{% codeblock lang:objc %}\n[operation addExecutionBlock:^(void){\n    //添加要执行的操作\n}];\n{% endcodeblock %}\n\n3)开始执行操作，当添加到当前操作对象的block操作数大于1时，会异步执行操作，并发执行所有操作\n{% codeblock lang:objc %}\n[operation start];     \n{% endcodeblock %}\n\n# 常用方法与属性\n1) Cancel\n{% codeblock lang:objc %}\n@property （getter=isCancelled) BOOL cancelled和　- （void）cancel\n{% endcodeblock %}\n\ncancel方法可以取消当前操作，而isCancelled方法可以检测操作是否已经被取消，实际开发中我们可能会频繁地调用isCancelled,而它本身非常地轻量级，不会对我们项目地性能产生较大地损失。\n\n2）添加依赖\n{% codeblock lang:objc %}\n- （void）addDependency：（NSOperation *）op\n{% endcodeblock %}\n\n为操作对象添加依赖操作，只有依赖的操作op执行完之后才会开始执行当前的操作对象。\n\n3）completionBlock\n{% codeblock lang:objc %}\n@property （copy） void （^completionBlock）(void)\n{% endcodeblock %}\n\n当前操作执行完后可执行的block，我们可以通过setCompletionBlock：来添加在操作对象执行完后我们想执行的任务。\n\n# 自定义子类\n如果上面的这些属性和方法还不满足需求的话，我们还可以自定义一个`NSOperation`的子类，封装一些我们想要的操作和数据。一个`main`函数基本上是程序的标准入口，所有的线程的开启也是通过`main`方法，所以如果我们自定义`NSOperation`子类的话，必须在子类中重写main方法。\n{% codeblock lang:objc %}\n-（void）main{\n    //我们必须为自定义的operation提供autorelease pool，因为operation完成之后需要销毁\n    @autoreleasepool{\n        //添加自己的操作逻辑\n    };\n}\n{% endcodeblock %}\n\n除此之外，我们也需要重写一些其他的基本方法，如：```start```，```isFinished```，```isExecuting```等，并且需要实现`KVO`机制。\n\n我们自定义的`NSOperation`子类，可以设置操作是异步执行，还是同步执行，一般默认的都是同步执行，想要我们自定义的operation异步执行，我们需要重写`isConcurrent`这个方法并且返回YES，iOS7.0以后的SDK中，`isConcurrent`被`isAsynchronous`取代了。\n\n#使用NSOperationQueue\n为了异步执行我们的操作，我们可以将operation添加到一个`NSOperationQueue`中去执行。一个`NSOperationQueue`操作队列，就相当于一个线程管理器，允许我们添加自己的operation。一旦把operation通过addOperation：方法加到操作队列中，operation就开始被处理，直到完成或者取消，然后被释放掉。\n\n1)创建操作队列，并添加操作\n{% codeblock lang:objc %}\nNSOperationQueue *queue = [[NSOperationQueuealloc]init];\n//添加一个operation\n[queue addOperation:operation];\n//添加一组operations\n[queue addOperations:operations waitUntilFinished:NO];\n{% endcodeblock %}\n\n2)执行顺序\noperation被添加到操作队列后，通常会按添加顺序依次得到执行，但是一个操作队列中的operation之间存在依赖关系，我们可以通过`NSOperation`的`addDependency：`方法为操作添加依赖；而且operation都有一个`NSOperationQueuePriority`优先级属性，这些都会影响操作队列中的operation的执行顺序。\n\n3)并发任务数量\n一个操作队列可以设置并发操作的数量，意思就是队列中最多可以同时运行几条线程。因为默认地，一个`NSOperationQueue`操作队列会为每一个operation提供一条线程来运行，operation之间是并发执行操作的。\n{% codeblock lang:objc %}\n//模拟串行队列，每次只允许执行一个操作，既只有一条线程\n[queue setMaxConcurrentOperationCount:1]\n{% endcodeblock %}","slug":"iOS多线程开发（四）NSOperation和NSOperationQueue","published":1,"updated":"2016-04-12T06:47:42.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9tz001794such8cpfcv","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在前几篇中，我们讲述了多线程的基础概念和在iOS开发中应用多线程的方法。我们在这一篇继续讨论在iOS开发中使用多线程的一种方式，使用<code>NSOperation</code>和<code>NSOperationQueue</code>。<code>NSOperation</code>的实例代表一个任务，默认封装了需要执行的操作和数据，从而简化了我们很多的操作，我们不必在关心底层的线程的运行和状态，只需要把精力放在我们需要执行的操作上。<br><a id=\"more\"></a></p>\n<h1 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h1><p><code>NSOperation</code>是一个<code>抽象类</code>，有俩种使用方式。第一种就是使用<code>Foundation</code>框架中提供的<code>NSOperation</code>的俩个子类：<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>,第二种就是<code>自定义</code>类并继承NSOperation。</p>\n<h1 id=\"NSInvocationOperation\"><a href=\"#NSInvocationOperation\" class=\"headerlink\" title=\"NSInvocationOperation\"></a>NSInvocationOperation</h1><p>1)封装要执行的操作</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSInvocationOperation</span> *operation = [[<span class=\"built_in\">NSInvocationOperationalloc</span>] initWithTarget:selfselector:<span class=\"keyword\">@selector</span>(temp) object:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<p>2)开始操作,一旦开始就会执行封装的操作，并且默认是在主线程执行</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<h1 id=\"NSBlockOperation\"><a href=\"#NSBlockOperation\" class=\"headerlink\" title=\"NSBlockOperation\"></a>NSBlockOperation</h1><p>1)创建操作对象，与Objective-C中的block机制结合使用<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^(<span class=\"keyword\">void</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加要执行的操作</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<p>2)添加新的操作<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[operation addExecutionBlock:^(<span class=\"keyword\">void</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加要执行的操作</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<p>3)开始执行操作，当添加到当前操作对象的block操作数大于1时，会异步执行操作，并发执行所有操作<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[operation start];     </span><br></pre></td></tr></table></figure></p>\n<h1 id=\"常用方法与属性\"><a href=\"#常用方法与属性\" class=\"headerlink\" title=\"常用方法与属性\"></a>常用方法与属性</h1><p>1) Cancel<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> （getter=isCancelled) <span class=\"built_in\">BOOL</span> cancelled和　- （<span class=\"keyword\">void</span>）cancel</span><br></pre></td></tr></table></figure></p>\n<p>cancel方法可以取消当前操作，而isCancelled方法可以检测操作是否已经被取消，实际开发中我们可能会频繁地调用isCancelled,而它本身非常地轻量级，不会对我们项目地性能产生较大地损失。</p>\n<p>2）添加依赖<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- （<span class=\"keyword\">void</span>）addDependency：（<span class=\"built_in\">NSOperation</span> *）op</span><br></pre></td></tr></table></figure></p>\n<p>为操作对象添加依赖操作，只有依赖的操作op执行完之后才会开始执行当前的操作对象。</p>\n<p>3）completionBlock<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> （<span class=\"keyword\">copy</span>） <span class=\"keyword\">void</span> （^completionBlock）(<span class=\"keyword\">void</span>)</span><br></pre></td></tr></table></figure></p>\n<p>当前操作执行完后可执行的block，我们可以通过setCompletionBlock：来添加在操作对象执行完后我们想执行的任务。</p>\n<h1 id=\"自定义子类\"><a href=\"#自定义子类\" class=\"headerlink\" title=\"自定义子类\"></a>自定义子类</h1><p>如果上面的这些属性和方法还不满足需求的话，我们还可以自定义一个<code>NSOperation</code>的子类，封装一些我们想要的操作和数据。一个<code>main</code>函数基本上是程序的标准入口，所有的线程的开启也是通过<code>main</code>方法，所以如果我们自定义<code>NSOperation</code>子类的话，必须在子类中重写main方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-（<span class=\"keyword\">void</span>）main&#123;</span><br><span class=\"line\">    <span class=\"comment\">//我们必须为自定义的operation提供autorelease pool，因为operation完成之后需要销毁</span></span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加自己的操作逻辑</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除此之外，我们也需要重写一些其他的基本方法，如：<code>start</code>，<code>isFinished</code>，<code>isExecuting</code>等，并且需要实现<code>KVO</code>机制。</p>\n<p>我们自定义的<code>NSOperation</code>子类，可以设置操作是异步执行，还是同步执行，一般默认的都是同步执行，想要我们自定义的operation异步执行，我们需要重写<code>isConcurrent</code>这个方法并且返回YES，iOS7.0以后的SDK中，<code>isConcurrent</code>被<code>isAsynchronous</code>取代了。</p>\n<p>#使用NSOperationQueue<br>为了异步执行我们的操作，我们可以将operation添加到一个<code>NSOperationQueue</code>中去执行。一个<code>NSOperationQueue</code>操作队列，就相当于一个线程管理器，允许我们添加自己的operation。一旦把operation通过addOperation：方法加到操作队列中，operation就开始被处理，直到完成或者取消，然后被释放掉。</p>\n<p>1)创建操作队列，并添加操作<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueuealloc</span>]init];</span><br><span class=\"line\"><span class=\"comment\">//添加一个operation</span></span><br><span class=\"line\">[queue addOperation:operation];</span><br><span class=\"line\"><span class=\"comment\">//添加一组operations</span></span><br><span class=\"line\">[queue addOperations:operations waitUntilFinished:<span class=\"literal\">NO</span>];</span><br></pre></td></tr></table></figure></p>\n<p>2)执行顺序<br>operation被添加到操作队列后，通常会按添加顺序依次得到执行，但是一个操作队列中的operation之间存在依赖关系，我们可以通过<code>NSOperation</code>的<code>addDependency：</code>方法为操作添加依赖；而且operation都有一个<code>NSOperationQueuePriority</code>优先级属性，这些都会影响操作队列中的operation的执行顺序。</p>\n<p>3)并发任务数量<br>一个操作队列可以设置并发操作的数量，意思就是队列中最多可以同时运行几条线程。因为默认地，一个<code>NSOperationQueue</code>操作队列会为每一个operation提供一条线程来运行，operation之间是并发执行操作的。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟串行队列，每次只允许执行一个操作，既只有一条线程</span></span><br><span class=\"line\">[queue setMaxConcurrentOperationCount:<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在前几篇中，我们讲述了多线程的基础概念和在iOS开发中应用多线程的方法。我们在这一篇继续讨论在iOS开发中使用多线程的一种方式，使用<code>NSOperation</code>和<code>NSOperationQueue</code>。<code>NSOperation</code>的实例代表一个任务，默认封装了需要执行的操作和数据，从而简化了我们很多的操作，我们不必在关心底层的线程的运行和状态，只需要把精力放在我们需要执行的操作上。<br>","more":"</p>\n<h1 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h1><p><code>NSOperation</code>是一个<code>抽象类</code>，有俩种使用方式。第一种就是使用<code>Foundation</code>框架中提供的<code>NSOperation</code>的俩个子类：<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>,第二种就是<code>自定义</code>类并继承NSOperation。</p>\n<h1 id=\"NSInvocationOperation\"><a href=\"#NSInvocationOperation\" class=\"headerlink\" title=\"NSInvocationOperation\"></a>NSInvocationOperation</h1><p>1)封装要执行的操作</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSInvocationOperation</span> *operation = [[<span class=\"built_in\">NSInvocationOperationalloc</span>] initWithTarget:selfselector:<span class=\"keyword\">@selector</span>(temp) object:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n<p>2)开始操作,一旦开始就会执行封装的操作，并且默认是在主线程执行</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<h1 id=\"NSBlockOperation\"><a href=\"#NSBlockOperation\" class=\"headerlink\" title=\"NSBlockOperation\"></a>NSBlockOperation</h1><p>1)创建操作对象，与Objective-C中的block机制结合使用<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^(<span class=\"keyword\">void</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加要执行的操作</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<p>2)添加新的操作<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[operation addExecutionBlock:^(<span class=\"keyword\">void</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加要执行的操作</span></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<p>3)开始执行操作，当添加到当前操作对象的block操作数大于1时，会异步执行操作，并发执行所有操作<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[operation start];     </span><br></pre></td></tr></table></figure></p>\n<h1 id=\"常用方法与属性\"><a href=\"#常用方法与属性\" class=\"headerlink\" title=\"常用方法与属性\"></a>常用方法与属性</h1><p>1) Cancel<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> （getter=isCancelled) <span class=\"built_in\">BOOL</span> cancelled和　- （<span class=\"keyword\">void</span>）cancel</span><br></pre></td></tr></table></figure></p>\n<p>cancel方法可以取消当前操作，而isCancelled方法可以检测操作是否已经被取消，实际开发中我们可能会频繁地调用isCancelled,而它本身非常地轻量级，不会对我们项目地性能产生较大地损失。</p>\n<p>2）添加依赖<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- （<span class=\"keyword\">void</span>）addDependency：（<span class=\"built_in\">NSOperation</span> *）op</span><br></pre></td></tr></table></figure></p>\n<p>为操作对象添加依赖操作，只有依赖的操作op执行完之后才会开始执行当前的操作对象。</p>\n<p>3）completionBlock<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> （<span class=\"keyword\">copy</span>） <span class=\"keyword\">void</span> （^completionBlock）(<span class=\"keyword\">void</span>)</span><br></pre></td></tr></table></figure></p>\n<p>当前操作执行完后可执行的block，我们可以通过setCompletionBlock：来添加在操作对象执行完后我们想执行的任务。</p>\n<h1 id=\"自定义子类\"><a href=\"#自定义子类\" class=\"headerlink\" title=\"自定义子类\"></a>自定义子类</h1><p>如果上面的这些属性和方法还不满足需求的话，我们还可以自定义一个<code>NSOperation</code>的子类，封装一些我们想要的操作和数据。一个<code>main</code>函数基本上是程序的标准入口，所有的线程的开启也是通过<code>main</code>方法，所以如果我们自定义<code>NSOperation</code>子类的话，必须在子类中重写main方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-（<span class=\"keyword\">void</span>）main&#123;</span><br><span class=\"line\">    <span class=\"comment\">//我们必须为自定义的operation提供autorelease pool，因为operation完成之后需要销毁</span></span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加自己的操作逻辑</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除此之外，我们也需要重写一些其他的基本方法，如：<code>start</code>，<code>isFinished</code>，<code>isExecuting</code>等，并且需要实现<code>KVO</code>机制。</p>\n<p>我们自定义的<code>NSOperation</code>子类，可以设置操作是异步执行，还是同步执行，一般默认的都是同步执行，想要我们自定义的operation异步执行，我们需要重写<code>isConcurrent</code>这个方法并且返回YES，iOS7.0以后的SDK中，<code>isConcurrent</code>被<code>isAsynchronous</code>取代了。</p>\n<p>#使用NSOperationQueue<br>为了异步执行我们的操作，我们可以将operation添加到一个<code>NSOperationQueue</code>中去执行。一个<code>NSOperationQueue</code>操作队列，就相当于一个线程管理器，允许我们添加自己的operation。一旦把operation通过addOperation：方法加到操作队列中，operation就开始被处理，直到完成或者取消，然后被释放掉。</p>\n<p>1)创建操作队列，并添加操作<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueuealloc</span>]init];</span><br><span class=\"line\"><span class=\"comment\">//添加一个operation</span></span><br><span class=\"line\">[queue addOperation:operation];</span><br><span class=\"line\"><span class=\"comment\">//添加一组operations</span></span><br><span class=\"line\">[queue addOperations:operations waitUntilFinished:<span class=\"literal\">NO</span>];</span><br></pre></td></tr></table></figure></p>\n<p>2)执行顺序<br>operation被添加到操作队列后，通常会按添加顺序依次得到执行，但是一个操作队列中的operation之间存在依赖关系，我们可以通过<code>NSOperation</code>的<code>addDependency：</code>方法为操作添加依赖；而且operation都有一个<code>NSOperationQueuePriority</code>优先级属性，这些都会影响操作队列中的operation的执行顺序。</p>\n<p>3)并发任务数量<br>一个操作队列可以设置并发操作的数量，意思就是队列中最多可以同时运行几条线程。因为默认地，一个<code>NSOperationQueue</code>操作队列会为每一个operation提供一条线程来运行，operation之间是并发执行操作的。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟串行队列，每次只允许执行一个操作，既只有一条线程</span></span><br><span class=\"line\">[queue setMaxConcurrentOperationCount:<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure></p>"},{"layout":"post","title":"iOS实现App之间的内容分享","date":"2015-11-24T16:00:00.000Z","description":"介绍如何在iOS系统上实现跨App之间的内容分享","_content":"\n# 前言\n我们在iOS平台上想要实现不同App之间的内容分享一般有几种常用方式：\n\n1. 第一种是通过`AirDrop`实现不同设备的App之间文档和数据的分享；\n2. 第二种是给每个App定义一个URL Scheme，通过访问指定了URL Scheme的一个URL，实现直接访问一个APP；\n3. 第三种是通过`UIDocumentInteractionController`或者是`UIActivityViewController`这俩个iOS SDK中封装好的类在App之间发送数据、分享数据和操作数据；\n4. 第四种是通过`App Extension`，在iOS 8的SDK中提供的扩展新特性实现跨App的数据操作和分享；\n5. 还有一种集成第三方SDK实现的有限个App的数据分享，比如社交平台(QQ,微信,新浪微博等)给我们提供的官方SDK，或者是集成了多个社交平台的ShareSDK组件和友盟分享组件等。\n<!-- more -->\n关于集成第三方SDK的使用，各大平台官网上都有详细的文档说明，因此我们这系列文章主要是来谈谈苹果原生提供的基于iOS SDK的分享技术，同时推荐俩篇苹果开发者中心的文档：[Inter-App Communication](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW2)和[Document Interaction Programming Topics for iOS](https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/DocumentInteraction_TopicsForIOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010409-SW1)。我们的第一篇文章就谈一下如何通过UTI让我们的App支持分享。\n\n# 原理\n我在[“详解苹果提供的UTI(统一类型标识符)“](http://www.jianshu.com/p/d6fe1e7af9b6)这篇文章中，详细地讲解了一下`UTI(Uniform Type Identifier)`,一套苹果给我们提供用来在基于Cocoa和Cocoa Touch应用程序中识别实体内容类型的规范，而关于实现内容关联的技术也正是基于这套规范。在iOS和Mac OS开发中，苹果给我们提供了注册文档类型的接口，而这种注册的文档类型是全局的，系统中所有的应用程序和服务都可以侦测到。因此我们通过这个底层侦测，可以使用其他可选的`第三方App`来预览`我们的App`中不支持的文档，而且我们还可以通过这个接口在`我们的App`中打开并处理`第三方App`的文档。\n\n如果我们的App可以处理某些类型的实体内容，那么我们就可以在我们项目中的`Info.plist`文件中进行注册。关于使用哪种类型和UTI，就要参考我在[“详解苹果提供的UTI(统一类型标识符)“](http://www.jianshu.com/p/d6fe1e7af9b6)这篇文章中的讲解。当一个第三方App通过苹果的底层侦测技术检查有哪些App可以处理它所指定的内容类型时，如果我们的App已经注册了这种类型，那么我们的App图标就会显示在其中，并且作为我们自己的App的一个入口。\n\n# 主要技术\n主要应用到这种底层侦测的技术有iOS SDK中给我们提供的`UIDocumentInteractionController`、`UIActivityViewController` 和` Quick Look 框架`。此外，在iOS 8中，苹果又给开发者提供了`App Extension`，一种更高大上的方式在App之间的实现分享内容。关于`UIDocumentInteractionController`、`UIActivityViewController`、` Quick Look 框架`以及`App Extension`的细节，我计划在后面的文章中详细讲解。这篇文章，我们主要是来谈谈`如何注册我们App可用的文档类型`以及`简单使用我们的App来处理第三方App分享的内容`。\n\n# 注册可用类型\n我们需要在`info.plist`文件中，添加一个新的属性`CFBundleDocumentTypes`(实际上输入的是`\"Document types\"`)，这是一个数组类型的属性，意思就是我们可以同时注册多个类型。而针对数组中的每一个元素，都有许多属性可以指定，详细的属性列表我们可以从官方文档上找到: [Core Foundation Keys ---- CFBundleDocumentTypes](https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-101685)。这里列举我们在做iOS开发时常用的属性：\n\n* CFBundleTypeName(`\"Icon File Name\"`)\n\n字符串类型，指定某种类型的别名，也就是用来指代我们规定的类型的别称，一般为了保持唯一性，我们使用UTI来标识。\n\n* CFBundleTypeIconFiles\n数组类型，包含指定的png图标的文件名，指定代表某种类型的图标，而图标有具体的尺寸标识：\n\n|Device |Sizes     |\n|:------|:---------|\n|iPad     |64 x 64 pixels, 320 x 320 pixels|\n|iPhone and iPod touch|22 x 29 pixels, 44 x 58 pixels (high       resolution)|\n\n* LSItemContentTypes(`\"Document Content Type UTIs\"`)\n\n数组类型，包含UTI字符串，指定我们的应用程序所有可以识别的类型集合\n\n* LSHandlerRank(`\"Handler rank\"`)\n\n字符串类型，包含`Owner`,`Default`,`Alternate`,`None`四个可选值，指定对于某种类型的优先权级别，而`Launcher Service`会根据这个优先级别来排列显示的App的顺序。优先级别从高到低依次是`Owner`，`Alternate`,`Default`。`None`表示不接受这种类型。\n\n了解了这些基本属性，我们就需要在注册App可用类型时，指定这些属性，根据每个项目的需求不同，属性值也不同。具体的注册请参照我的GitHub上的项目：[SeraZheng---ZSUTITest](https://github.com/SeraZheng/ZSUTITest/tree/master)。下图示例作为一个参照：\n{% img /images/在info中添加DocumentTypes.png %}\n\n而当我们添加完所有属性后，开始运行我们的程序，然后再回到我们的Info界面，就会看到`Document types`这个列表已经发生了变化，这就证明我们成功的注册好了App可用的类型。\n{% img /images/注册成功.png %}\n\n# 打开第三方应用\n我们在上面的步骤中注册好了我们的App可以识别的类型，现在我们可以打开一个使用`UIDocumentInteractionController`或者是` Quick Look `框架来展示内容的第三方App，这里以iPhone 上的QQ程序为例。\n\n我们在上面的注册步骤中，注册的`LSItemContentTypes`仅包含了`public.image`这个UTI。所以我们先从QQ应用程序的`我的文件`中，打开不同类型的文件进行对比，大家可以看下图`我的文件`列表中包含俩种类型的文件，一种是`.jpg`扩展名的图片文件，一种是`.pdf`扩展名的文档文件。\n\n{% img /images/我的文件列表.png %}\n\n当我打开一个图片文件进行预览时，点击`其他应用打开`，就可以在App列表中看到我们的App图标。简单介绍一下这个页面，第一行是苹果在iOS 7之后给我们提供的使用`AirDrop`在`iPhone`、`iPad`或`iPod Touch`设备之间通过`iCloud`共享内容的一种方式。第二行是通过文档类型关联技术识别的App的列表。第三行是通过文档关联技术识别的`Action`的列表，`Action`表示对文档可进行的操作，如复制，打印等。\n{% img /images/打开图片看到图标.png %}\n\n而如果我打开PDF文件的话，就看不到我们的App图标。\n{% img /images/PDF看不到图标.png %}\n\n# 程序回调\n当我们通过上面步骤，成功地显示了`ZSUTITestDemo` 的图标之后，点击图标，我们就可以跳转到`ZSUTITestDemo`应用中，而苹果在iOS SDK中给我们提供的接收回调的方法在iOS 9之后做出了改变，因此我们需要针对不同的设备版本做出改变：\n\n{% codeblock lang:objc %}\n#if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_9_0\n- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(nullable NSString *)sourceApplication annotation:(id)annotation\n{\n    UINavigationController *navigation = (UINavigationController *)application.keyWindow.rootViewController;\n    ViewController *displayController = (ViewController *)navigation.topViewController;\n    \n    [displayController.imageView setImage:[UIImage imageWithData:[NSData dataWithContentsOfURL:url]]];\n    [displayController.label setText:sourceApplication];\n    \n    return YES;\n}\n\n#else\n- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url options:(nonnull NSDictionary<NSString *,id> *)options\n{\n    UINavigationController *navigation = (UINavigationController *)application.keyWindow.rootViewController;\n    ViewController *displayController = (ViewController *)navigation.topViewController;\n    \n    [displayController.imageView setImage:[UIImage imageWithData:[NSData dataWithContentsOfURL:url]]];\n    [displayController.label setText:[options objectForKey:UIApplicationOpenURLOptionsSourceApplicationKey]];\n    \n    return YES;\n}\n#endif\n{% endcodeblock %}\n\nDemo示例可以从GitHub项目上参照代码：[SeraZheng---ZSUTITest](https://github.com/SeraZheng/ZSUTITest/tree/master)。当点击`ZSUTITestDemo`程序图标回到调用代码中，我们可以在这里做各种我们想做的事，如上传图片、预览图片、操作图片等等。我只对图片做了简单的预览显示，然后显示文件的源程序的`Bundle Identifier`，示例如下图：\n{% img /images/显示图片.png %}\n","source":"_posts/iOS实现App之间的内容分享.md","raw":"---\nlayout: post\ntitle: iOS实现App之间的内容分享\ndate: 2015-11-25\ndescription: \"介绍如何在iOS系统上实现跨App之间的内容分享\"\ntags: [UTI]\ncategories: [iOS]\n---\n\n# 前言\n我们在iOS平台上想要实现不同App之间的内容分享一般有几种常用方式：\n\n1. 第一种是通过`AirDrop`实现不同设备的App之间文档和数据的分享；\n2. 第二种是给每个App定义一个URL Scheme，通过访问指定了URL Scheme的一个URL，实现直接访问一个APP；\n3. 第三种是通过`UIDocumentInteractionController`或者是`UIActivityViewController`这俩个iOS SDK中封装好的类在App之间发送数据、分享数据和操作数据；\n4. 第四种是通过`App Extension`，在iOS 8的SDK中提供的扩展新特性实现跨App的数据操作和分享；\n5. 还有一种集成第三方SDK实现的有限个App的数据分享，比如社交平台(QQ,微信,新浪微博等)给我们提供的官方SDK，或者是集成了多个社交平台的ShareSDK组件和友盟分享组件等。\n<!-- more -->\n关于集成第三方SDK的使用，各大平台官网上都有详细的文档说明，因此我们这系列文章主要是来谈谈苹果原生提供的基于iOS SDK的分享技术，同时推荐俩篇苹果开发者中心的文档：[Inter-App Communication](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW2)和[Document Interaction Programming Topics for iOS](https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/DocumentInteraction_TopicsForIOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010409-SW1)。我们的第一篇文章就谈一下如何通过UTI让我们的App支持分享。\n\n# 原理\n我在[“详解苹果提供的UTI(统一类型标识符)“](http://www.jianshu.com/p/d6fe1e7af9b6)这篇文章中，详细地讲解了一下`UTI(Uniform Type Identifier)`,一套苹果给我们提供用来在基于Cocoa和Cocoa Touch应用程序中识别实体内容类型的规范，而关于实现内容关联的技术也正是基于这套规范。在iOS和Mac OS开发中，苹果给我们提供了注册文档类型的接口，而这种注册的文档类型是全局的，系统中所有的应用程序和服务都可以侦测到。因此我们通过这个底层侦测，可以使用其他可选的`第三方App`来预览`我们的App`中不支持的文档，而且我们还可以通过这个接口在`我们的App`中打开并处理`第三方App`的文档。\n\n如果我们的App可以处理某些类型的实体内容，那么我们就可以在我们项目中的`Info.plist`文件中进行注册。关于使用哪种类型和UTI，就要参考我在[“详解苹果提供的UTI(统一类型标识符)“](http://www.jianshu.com/p/d6fe1e7af9b6)这篇文章中的讲解。当一个第三方App通过苹果的底层侦测技术检查有哪些App可以处理它所指定的内容类型时，如果我们的App已经注册了这种类型，那么我们的App图标就会显示在其中，并且作为我们自己的App的一个入口。\n\n# 主要技术\n主要应用到这种底层侦测的技术有iOS SDK中给我们提供的`UIDocumentInteractionController`、`UIActivityViewController` 和` Quick Look 框架`。此外，在iOS 8中，苹果又给开发者提供了`App Extension`，一种更高大上的方式在App之间的实现分享内容。关于`UIDocumentInteractionController`、`UIActivityViewController`、` Quick Look 框架`以及`App Extension`的细节，我计划在后面的文章中详细讲解。这篇文章，我们主要是来谈谈`如何注册我们App可用的文档类型`以及`简单使用我们的App来处理第三方App分享的内容`。\n\n# 注册可用类型\n我们需要在`info.plist`文件中，添加一个新的属性`CFBundleDocumentTypes`(实际上输入的是`\"Document types\"`)，这是一个数组类型的属性，意思就是我们可以同时注册多个类型。而针对数组中的每一个元素，都有许多属性可以指定，详细的属性列表我们可以从官方文档上找到: [Core Foundation Keys ---- CFBundleDocumentTypes](https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-101685)。这里列举我们在做iOS开发时常用的属性：\n\n* CFBundleTypeName(`\"Icon File Name\"`)\n\n字符串类型，指定某种类型的别名，也就是用来指代我们规定的类型的别称，一般为了保持唯一性，我们使用UTI来标识。\n\n* CFBundleTypeIconFiles\n数组类型，包含指定的png图标的文件名，指定代表某种类型的图标，而图标有具体的尺寸标识：\n\n|Device |Sizes     |\n|:------|:---------|\n|iPad     |64 x 64 pixels, 320 x 320 pixels|\n|iPhone and iPod touch|22 x 29 pixels, 44 x 58 pixels (high       resolution)|\n\n* LSItemContentTypes(`\"Document Content Type UTIs\"`)\n\n数组类型，包含UTI字符串，指定我们的应用程序所有可以识别的类型集合\n\n* LSHandlerRank(`\"Handler rank\"`)\n\n字符串类型，包含`Owner`,`Default`,`Alternate`,`None`四个可选值，指定对于某种类型的优先权级别，而`Launcher Service`会根据这个优先级别来排列显示的App的顺序。优先级别从高到低依次是`Owner`，`Alternate`,`Default`。`None`表示不接受这种类型。\n\n了解了这些基本属性，我们就需要在注册App可用类型时，指定这些属性，根据每个项目的需求不同，属性值也不同。具体的注册请参照我的GitHub上的项目：[SeraZheng---ZSUTITest](https://github.com/SeraZheng/ZSUTITest/tree/master)。下图示例作为一个参照：\n{% img /images/在info中添加DocumentTypes.png %}\n\n而当我们添加完所有属性后，开始运行我们的程序，然后再回到我们的Info界面，就会看到`Document types`这个列表已经发生了变化，这就证明我们成功的注册好了App可用的类型。\n{% img /images/注册成功.png %}\n\n# 打开第三方应用\n我们在上面的步骤中注册好了我们的App可以识别的类型，现在我们可以打开一个使用`UIDocumentInteractionController`或者是` Quick Look `框架来展示内容的第三方App，这里以iPhone 上的QQ程序为例。\n\n我们在上面的注册步骤中，注册的`LSItemContentTypes`仅包含了`public.image`这个UTI。所以我们先从QQ应用程序的`我的文件`中，打开不同类型的文件进行对比，大家可以看下图`我的文件`列表中包含俩种类型的文件，一种是`.jpg`扩展名的图片文件，一种是`.pdf`扩展名的文档文件。\n\n{% img /images/我的文件列表.png %}\n\n当我打开一个图片文件进行预览时，点击`其他应用打开`，就可以在App列表中看到我们的App图标。简单介绍一下这个页面，第一行是苹果在iOS 7之后给我们提供的使用`AirDrop`在`iPhone`、`iPad`或`iPod Touch`设备之间通过`iCloud`共享内容的一种方式。第二行是通过文档类型关联技术识别的App的列表。第三行是通过文档关联技术识别的`Action`的列表，`Action`表示对文档可进行的操作，如复制，打印等。\n{% img /images/打开图片看到图标.png %}\n\n而如果我打开PDF文件的话，就看不到我们的App图标。\n{% img /images/PDF看不到图标.png %}\n\n# 程序回调\n当我们通过上面步骤，成功地显示了`ZSUTITestDemo` 的图标之后，点击图标，我们就可以跳转到`ZSUTITestDemo`应用中，而苹果在iOS SDK中给我们提供的接收回调的方法在iOS 9之后做出了改变，因此我们需要针对不同的设备版本做出改变：\n\n{% codeblock lang:objc %}\n#if __IPHONE_OS_VERSION_MAX_ALLOWED < __IPHONE_9_0\n- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(nullable NSString *)sourceApplication annotation:(id)annotation\n{\n    UINavigationController *navigation = (UINavigationController *)application.keyWindow.rootViewController;\n    ViewController *displayController = (ViewController *)navigation.topViewController;\n    \n    [displayController.imageView setImage:[UIImage imageWithData:[NSData dataWithContentsOfURL:url]]];\n    [displayController.label setText:sourceApplication];\n    \n    return YES;\n}\n\n#else\n- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url options:(nonnull NSDictionary<NSString *,id> *)options\n{\n    UINavigationController *navigation = (UINavigationController *)application.keyWindow.rootViewController;\n    ViewController *displayController = (ViewController *)navigation.topViewController;\n    \n    [displayController.imageView setImage:[UIImage imageWithData:[NSData dataWithContentsOfURL:url]]];\n    [displayController.label setText:[options objectForKey:UIApplicationOpenURLOptionsSourceApplicationKey]];\n    \n    return YES;\n}\n#endif\n{% endcodeblock %}\n\nDemo示例可以从GitHub项目上参照代码：[SeraZheng---ZSUTITest](https://github.com/SeraZheng/ZSUTITest/tree/master)。当点击`ZSUTITestDemo`程序图标回到调用代码中，我们可以在这里做各种我们想做的事，如上传图片、预览图片、操作图片等等。我只对图片做了简单的预览显示，然后显示文件的源程序的`Bundle Identifier`，示例如下图：\n{% img /images/显示图片.png %}\n","slug":"iOS实现App之间的内容分享","published":1,"updated":"2016-04-12T06:52:16.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9u1001b94supdh36pr4","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>我们在iOS平台上想要实现不同App之间的内容分享一般有几种常用方式：</p>\n<ol>\n<li>第一种是通过<code>AirDrop</code>实现不同设备的App之间文档和数据的分享；</li>\n<li>第二种是给每个App定义一个URL Scheme，通过访问指定了URL Scheme的一个URL，实现直接访问一个APP；</li>\n<li>第三种是通过<code>UIDocumentInteractionController</code>或者是<code>UIActivityViewController</code>这俩个iOS SDK中封装好的类在App之间发送数据、分享数据和操作数据；</li>\n<li>第四种是通过<code>App Extension</code>，在iOS 8的SDK中提供的扩展新特性实现跨App的数据操作和分享；</li>\n<li>还有一种集成第三方SDK实现的有限个App的数据分享，比如社交平台(QQ,微信,新浪微博等)给我们提供的官方SDK，或者是集成了多个社交平台的ShareSDK组件和友盟分享组件等。<a id=\"more\"></a>\n关于集成第三方SDK的使用，各大平台官网上都有详细的文档说明，因此我们这系列文章主要是来谈谈苹果原生提供的基于iOS SDK的分享技术，同时推荐俩篇苹果开发者中心的文档：<a href=\"https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW2\" target=\"_blank\" rel=\"external\">Inter-App Communication</a>和<a href=\"https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/DocumentInteraction_TopicsForIOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010409-SW1\" target=\"_blank\" rel=\"external\">Document Interaction Programming Topics for iOS</a>。我们的第一篇文章就谈一下如何通过UTI让我们的App支持分享。</li>\n</ol>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>我在<a href=\"http://www.jianshu.com/p/d6fe1e7af9b6\" target=\"_blank\" rel=\"external\">“详解苹果提供的UTI(统一类型标识符)“</a>这篇文章中，详细地讲解了一下<code>UTI(Uniform Type Identifier)</code>,一套苹果给我们提供用来在基于Cocoa和Cocoa Touch应用程序中识别实体内容类型的规范，而关于实现内容关联的技术也正是基于这套规范。在iOS和Mac OS开发中，苹果给我们提供了注册文档类型的接口，而这种注册的文档类型是全局的，系统中所有的应用程序和服务都可以侦测到。因此我们通过这个底层侦测，可以使用其他可选的<code>第三方App</code>来预览<code>我们的App</code>中不支持的文档，而且我们还可以通过这个接口在<code>我们的App</code>中打开并处理<code>第三方App</code>的文档。</p>\n<p>如果我们的App可以处理某些类型的实体内容，那么我们就可以在我们项目中的<code>Info.plist</code>文件中进行注册。关于使用哪种类型和UTI，就要参考我在<a href=\"http://www.jianshu.com/p/d6fe1e7af9b6\" target=\"_blank\" rel=\"external\">“详解苹果提供的UTI(统一类型标识符)“</a>这篇文章中的讲解。当一个第三方App通过苹果的底层侦测技术检查有哪些App可以处理它所指定的内容类型时，如果我们的App已经注册了这种类型，那么我们的App图标就会显示在其中，并且作为我们自己的App的一个入口。</p>\n<h1 id=\"主要技术\"><a href=\"#主要技术\" class=\"headerlink\" title=\"主要技术\"></a>主要技术</h1><p>主要应用到这种底层侦测的技术有iOS SDK中给我们提供的<code>UIDocumentInteractionController</code>、<code>UIActivityViewController</code> 和<code>Quick Look 框架</code>。此外，在iOS 8中，苹果又给开发者提供了<code>App Extension</code>，一种更高大上的方式在App之间的实现分享内容。关于<code>UIDocumentInteractionController</code>、<code>UIActivityViewController</code>、<code>Quick Look 框架</code>以及<code>App Extension</code>的细节，我计划在后面的文章中详细讲解。这篇文章，我们主要是来谈谈<code>如何注册我们App可用的文档类型</code>以及<code>简单使用我们的App来处理第三方App分享的内容</code>。</p>\n<h1 id=\"注册可用类型\"><a href=\"#注册可用类型\" class=\"headerlink\" title=\"注册可用类型\"></a>注册可用类型</h1><p>我们需要在<code>info.plist</code>文件中，添加一个新的属性<code>CFBundleDocumentTypes</code>(实际上输入的是<code>&quot;Document types&quot;</code>)，这是一个数组类型的属性，意思就是我们可以同时注册多个类型。而针对数组中的每一个元素，都有许多属性可以指定，详细的属性列表我们可以从官方文档上找到: <a href=\"https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-101685\" target=\"_blank\" rel=\"external\">Core Foundation Keys —- CFBundleDocumentTypes</a>。这里列举我们在做iOS开发时常用的属性：</p>\n<ul>\n<li>CFBundleTypeName(<code>&quot;Icon File Name&quot;</code>)</li>\n</ul>\n<p>字符串类型，指定某种类型的别名，也就是用来指代我们规定的类型的别称，一般为了保持唯一性，我们使用UTI来标识。</p>\n<ul>\n<li>CFBundleTypeIconFiles<br>数组类型，包含指定的png图标的文件名，指定代表某种类型的图标，而图标有具体的尺寸标识：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Device</th>\n<th style=\"text-align:left\">Sizes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">iPad</td>\n<td style=\"text-align:left\">64 x 64 pixels, 320 x 320 pixels</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">iPhone and iPod touch</td>\n<td style=\"text-align:left\">22 x 29 pixels, 44 x 58 pixels (high       resolution)</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>LSItemContentTypes(<code>&quot;Document Content Type UTIs&quot;</code>)</li>\n</ul>\n<p>数组类型，包含UTI字符串，指定我们的应用程序所有可以识别的类型集合</p>\n<ul>\n<li>LSHandlerRank(<code>&quot;Handler rank&quot;</code>)</li>\n</ul>\n<p>字符串类型，包含<code>Owner</code>,<code>Default</code>,<code>Alternate</code>,<code>None</code>四个可选值，指定对于某种类型的优先权级别，而<code>Launcher Service</code>会根据这个优先级别来排列显示的App的顺序。优先级别从高到低依次是<code>Owner</code>，<code>Alternate</code>,<code>Default</code>。<code>None</code>表示不接受这种类型。</p>\n<p>了解了这些基本属性，我们就需要在注册App可用类型时，指定这些属性，根据每个项目的需求不同，属性值也不同。具体的注册请参照我的GitHub上的项目：<a href=\"https://github.com/SeraZheng/ZSUTITest/tree/master\" target=\"_blank\" rel=\"external\">SeraZheng—ZSUTITest</a>。下图示例作为一个参照：<br><img src=\"/images/在info中添加DocumentTypes.png\"></p>\n<p>而当我们添加完所有属性后，开始运行我们的程序，然后再回到我们的Info界面，就会看到<code>Document types</code>这个列表已经发生了变化，这就证明我们成功的注册好了App可用的类型。<br><img src=\"/images/注册成功.png\"></p>\n<h1 id=\"打开第三方应用\"><a href=\"#打开第三方应用\" class=\"headerlink\" title=\"打开第三方应用\"></a>打开第三方应用</h1><p>我们在上面的步骤中注册好了我们的App可以识别的类型，现在我们可以打开一个使用<code>UIDocumentInteractionController</code>或者是<code>Quick Look</code>框架来展示内容的第三方App，这里以iPhone 上的QQ程序为例。</p>\n<p>我们在上面的注册步骤中，注册的<code>LSItemContentTypes</code>仅包含了<code>public.image</code>这个UTI。所以我们先从QQ应用程序的<code>我的文件</code>中，打开不同类型的文件进行对比，大家可以看下图<code>我的文件</code>列表中包含俩种类型的文件，一种是<code>.jpg</code>扩展名的图片文件，一种是<code>.pdf</code>扩展名的文档文件。</p>\n<img src=\"/images/我的文件列表.png\">\n<p>当我打开一个图片文件进行预览时，点击<code>其他应用打开</code>，就可以在App列表中看到我们的App图标。简单介绍一下这个页面，第一行是苹果在iOS 7之后给我们提供的使用<code>AirDrop</code>在<code>iPhone</code>、<code>iPad</code>或<code>iPod Touch</code>设备之间通过<code>iCloud</code>共享内容的一种方式。第二行是通过文档类型关联技术识别的App的列表。第三行是通过文档关联技术识别的<code>Action</code>的列表，<code>Action</code>表示对文档可进行的操作，如复制，打印等。<br><img src=\"/images/打开图片看到图标.png\"></p>\n<p>而如果我打开PDF文件的话，就看不到我们的App图标。<br><img src=\"/images/PDF看不到图标.png\"></p>\n<h1 id=\"程序回调\"><a href=\"#程序回调\" class=\"headerlink\" title=\"程序回调\"></a>程序回调</h1><p>当我们通过上面步骤，成功地显示了<code>ZSUTITestDemo</code> 的图标之后，点击图标，我们就可以跳转到<code>ZSUTITestDemo</code>应用中，而苹果在iOS SDK中给我们提供的接收回调的方法在iOS 9之后做出了改变，因此我们需要针对不同的设备版本做出改变：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#if __IPHONE_OS_VERSION_MAX_ALLOWED <span class=\"meta-string\">&lt; __IPHONE_9_0</span><br><span class=\"line\">- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(nullable NSString *)sourceApplication annotation:(id)annotation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    UINavigationController *navigation = (UINavigationController *)application.keyWindow.rootViewController;</span><br><span class=\"line\">    ViewController *displayController = (ViewController *)navigation.topViewController;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [displayController.imageView setImage:[UIImage imageWithData:[NSData dataWithContentsOfURL:url]]];</span><br><span class=\"line\">    [displayController.label setText:sourceApplication];</span><br><span class=\"line\">    </span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#else</span><br><span class=\"line\">- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url options:(nonnull NSDictionary&lt;NSString *,id&gt;</span> *)options</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UINavigationController</span> *navigation = (<span class=\"built_in\">UINavigationController</span> *)application.keyWindow.rootViewController;</span><br><span class=\"line\">    ViewController *displayController = (ViewController *)navigation.topViewController;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [displayController.imageView setImage:[<span class=\"built_in\">UIImage</span> imageWithData:[<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url]]];</span><br><span class=\"line\">    [displayController.label setText:[options objectForKey:<span class=\"built_in\">UIApplicationOpenURLOptionsSourceApplicationKey</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>Demo示例可以从GitHub项目上参照代码：<a href=\"https://github.com/SeraZheng/ZSUTITest/tree/master\" target=\"_blank\" rel=\"external\">SeraZheng—ZSUTITest</a>。当点击<code>ZSUTITestDemo</code>程序图标回到调用代码中，我们可以在这里做各种我们想做的事，如上传图片、预览图片、操作图片等等。我只对图片做了简单的预览显示，然后显示文件的源程序的<code>Bundle Identifier</code>，示例如下图：<br><img src=\"/images/显示图片.png\"></p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>我们在iOS平台上想要实现不同App之间的内容分享一般有几种常用方式：</p>\n<ol>\n<li>第一种是通过<code>AirDrop</code>实现不同设备的App之间文档和数据的分享；</li>\n<li>第二种是给每个App定义一个URL Scheme，通过访问指定了URL Scheme的一个URL，实现直接访问一个APP；</li>\n<li>第三种是通过<code>UIDocumentInteractionController</code>或者是<code>UIActivityViewController</code>这俩个iOS SDK中封装好的类在App之间发送数据、分享数据和操作数据；</li>\n<li>第四种是通过<code>App Extension</code>，在iOS 8的SDK中提供的扩展新特性实现跨App的数据操作和分享；</li>\n<li>还有一种集成第三方SDK实现的有限个App的数据分享，比如社交平台(QQ,微信,新浪微博等)给我们提供的官方SDK，或者是集成了多个社交平台的ShareSDK组件和友盟分享组件等。","more":"关于集成第三方SDK的使用，各大平台官网上都有详细的文档说明，因此我们这系列文章主要是来谈谈苹果原生提供的基于iOS SDK的分享技术，同时推荐俩篇苹果开发者中心的文档：<a href=\"https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW2\">Inter-App Communication</a>和<a href=\"https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/DocumentInteraction_TopicsForIOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010409-SW1\">Document Interaction Programming Topics for iOS</a>。我们的第一篇文章就谈一下如何通过UTI让我们的App支持分享。</li>\n</ol>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>我在<a href=\"http://www.jianshu.com/p/d6fe1e7af9b6\">“详解苹果提供的UTI(统一类型标识符)“</a>这篇文章中，详细地讲解了一下<code>UTI(Uniform Type Identifier)</code>,一套苹果给我们提供用来在基于Cocoa和Cocoa Touch应用程序中识别实体内容类型的规范，而关于实现内容关联的技术也正是基于这套规范。在iOS和Mac OS开发中，苹果给我们提供了注册文档类型的接口，而这种注册的文档类型是全局的，系统中所有的应用程序和服务都可以侦测到。因此我们通过这个底层侦测，可以使用其他可选的<code>第三方App</code>来预览<code>我们的App</code>中不支持的文档，而且我们还可以通过这个接口在<code>我们的App</code>中打开并处理<code>第三方App</code>的文档。</p>\n<p>如果我们的App可以处理某些类型的实体内容，那么我们就可以在我们项目中的<code>Info.plist</code>文件中进行注册。关于使用哪种类型和UTI，就要参考我在<a href=\"http://www.jianshu.com/p/d6fe1e7af9b6\">“详解苹果提供的UTI(统一类型标识符)“</a>这篇文章中的讲解。当一个第三方App通过苹果的底层侦测技术检查有哪些App可以处理它所指定的内容类型时，如果我们的App已经注册了这种类型，那么我们的App图标就会显示在其中，并且作为我们自己的App的一个入口。</p>\n<h1 id=\"主要技术\"><a href=\"#主要技术\" class=\"headerlink\" title=\"主要技术\"></a>主要技术</h1><p>主要应用到这种底层侦测的技术有iOS SDK中给我们提供的<code>UIDocumentInteractionController</code>、<code>UIActivityViewController</code> 和<code>Quick Look 框架</code>。此外，在iOS 8中，苹果又给开发者提供了<code>App Extension</code>，一种更高大上的方式在App之间的实现分享内容。关于<code>UIDocumentInteractionController</code>、<code>UIActivityViewController</code>、<code>Quick Look 框架</code>以及<code>App Extension</code>的细节，我计划在后面的文章中详细讲解。这篇文章，我们主要是来谈谈<code>如何注册我们App可用的文档类型</code>以及<code>简单使用我们的App来处理第三方App分享的内容</code>。</p>\n<h1 id=\"注册可用类型\"><a href=\"#注册可用类型\" class=\"headerlink\" title=\"注册可用类型\"></a>注册可用类型</h1><p>我们需要在<code>info.plist</code>文件中，添加一个新的属性<code>CFBundleDocumentTypes</code>(实际上输入的是<code>&quot;Document types&quot;</code>)，这是一个数组类型的属性，意思就是我们可以同时注册多个类型。而针对数组中的每一个元素，都有许多属性可以指定，详细的属性列表我们可以从官方文档上找到: <a href=\"https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-101685\">Core Foundation Keys —- CFBundleDocumentTypes</a>。这里列举我们在做iOS开发时常用的属性：</p>\n<ul>\n<li>CFBundleTypeName(<code>&quot;Icon File Name&quot;</code>)</li>\n</ul>\n<p>字符串类型，指定某种类型的别名，也就是用来指代我们规定的类型的别称，一般为了保持唯一性，我们使用UTI来标识。</p>\n<ul>\n<li>CFBundleTypeIconFiles<br>数组类型，包含指定的png图标的文件名，指定代表某种类型的图标，而图标有具体的尺寸标识：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Device</th>\n<th style=\"text-align:left\">Sizes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">iPad</td>\n<td style=\"text-align:left\">64 x 64 pixels, 320 x 320 pixels</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">iPhone and iPod touch</td>\n<td style=\"text-align:left\">22 x 29 pixels, 44 x 58 pixels (high       resolution)</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>LSItemContentTypes(<code>&quot;Document Content Type UTIs&quot;</code>)</li>\n</ul>\n<p>数组类型，包含UTI字符串，指定我们的应用程序所有可以识别的类型集合</p>\n<ul>\n<li>LSHandlerRank(<code>&quot;Handler rank&quot;</code>)</li>\n</ul>\n<p>字符串类型，包含<code>Owner</code>,<code>Default</code>,<code>Alternate</code>,<code>None</code>四个可选值，指定对于某种类型的优先权级别，而<code>Launcher Service</code>会根据这个优先级别来排列显示的App的顺序。优先级别从高到低依次是<code>Owner</code>，<code>Alternate</code>,<code>Default</code>。<code>None</code>表示不接受这种类型。</p>\n<p>了解了这些基本属性，我们就需要在注册App可用类型时，指定这些属性，根据每个项目的需求不同，属性值也不同。具体的注册请参照我的GitHub上的项目：<a href=\"https://github.com/SeraZheng/ZSUTITest/tree/master\">SeraZheng—ZSUTITest</a>。下图示例作为一个参照：<br><img src=\"/images/在info中添加DocumentTypes.png\"></p>\n<p>而当我们添加完所有属性后，开始运行我们的程序，然后再回到我们的Info界面，就会看到<code>Document types</code>这个列表已经发生了变化，这就证明我们成功的注册好了App可用的类型。<br><img src=\"/images/注册成功.png\"></p>\n<h1 id=\"打开第三方应用\"><a href=\"#打开第三方应用\" class=\"headerlink\" title=\"打开第三方应用\"></a>打开第三方应用</h1><p>我们在上面的步骤中注册好了我们的App可以识别的类型，现在我们可以打开一个使用<code>UIDocumentInteractionController</code>或者是<code>Quick Look</code>框架来展示内容的第三方App，这里以iPhone 上的QQ程序为例。</p>\n<p>我们在上面的注册步骤中，注册的<code>LSItemContentTypes</code>仅包含了<code>public.image</code>这个UTI。所以我们先从QQ应用程序的<code>我的文件</code>中，打开不同类型的文件进行对比，大家可以看下图<code>我的文件</code>列表中包含俩种类型的文件，一种是<code>.jpg</code>扩展名的图片文件，一种是<code>.pdf</code>扩展名的文档文件。</p>\n<img src=\"/images/我的文件列表.png\">\n<p>当我打开一个图片文件进行预览时，点击<code>其他应用打开</code>，就可以在App列表中看到我们的App图标。简单介绍一下这个页面，第一行是苹果在iOS 7之后给我们提供的使用<code>AirDrop</code>在<code>iPhone</code>、<code>iPad</code>或<code>iPod Touch</code>设备之间通过<code>iCloud</code>共享内容的一种方式。第二行是通过文档类型关联技术识别的App的列表。第三行是通过文档关联技术识别的<code>Action</code>的列表，<code>Action</code>表示对文档可进行的操作，如复制，打印等。<br><img src=\"/images/打开图片看到图标.png\"></p>\n<p>而如果我打开PDF文件的话，就看不到我们的App图标。<br><img src=\"/images/PDF看不到图标.png\"></p>\n<h1 id=\"程序回调\"><a href=\"#程序回调\" class=\"headerlink\" title=\"程序回调\"></a>程序回调</h1><p>当我们通过上面步骤，成功地显示了<code>ZSUTITestDemo</code> 的图标之后，点击图标，我们就可以跳转到<code>ZSUTITestDemo</code>应用中，而苹果在iOS SDK中给我们提供的接收回调的方法在iOS 9之后做出了改变，因此我们需要针对不同的设备版本做出改变：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#if __IPHONE_OS_VERSION_MAX_ALLOWED <span class=\"meta-string\">&lt; __IPHONE_9_0</span><br><span class=\"line\">- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(nullable NSString *)sourceApplication annotation:(id)annotation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    UINavigationController *navigation = (UINavigationController *)application.keyWindow.rootViewController;</span><br><span class=\"line\">    ViewController *displayController = (ViewController *)navigation.topViewController;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [displayController.imageView setImage:[UIImage imageWithData:[NSData dataWithContentsOfURL:url]]];</span><br><span class=\"line\">    [displayController.label setText:sourceApplication];</span><br><span class=\"line\">    </span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#else</span><br><span class=\"line\">- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url options:(nonnull NSDictionary&lt;NSString *,id&gt;</span> *)options</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UINavigationController</span> *navigation = (<span class=\"built_in\">UINavigationController</span> *)application.keyWindow.rootViewController;</span><br><span class=\"line\">    ViewController *displayController = (ViewController *)navigation.topViewController;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [displayController.imageView setImage:[<span class=\"built_in\">UIImage</span> imageWithData:[<span class=\"built_in\">NSData</span> dataWithContentsOfURL:url]]];</span><br><span class=\"line\">    [displayController.label setText:[options objectForKey:<span class=\"built_in\">UIApplicationOpenURLOptionsSourceApplicationKey</span>]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>Demo示例可以从GitHub项目上参照代码：<a href=\"https://github.com/SeraZheng/ZSUTITest/tree/master\">SeraZheng—ZSUTITest</a>。当点击<code>ZSUTITestDemo</code>程序图标回到调用代码中，我们可以在这里做各种我们想做的事，如上传图片、预览图片、操作图片等等。我只对图片做了简单的预览显示，然后显示文件的源程序的<code>Bundle Identifier</code>，示例如下图：<br><img src=\"/images/显示图片.png\"></p>"},{"layout":"post","title":"使用谓词(NSPredicate)来提高集合遍历与过滤查找的效率","date":"2015-10-11T16:00:00.000Z","description":"介绍'NSPredicate'功能的一些设计方式","_content":"\n# 前言\n在开发中，我们经常会遇到一些需要，让我们从集合中查找某个值，从集合中过滤想要的内容等等，因而我们就需要`遍历`集合，加条件判断，然后获取符合条件的值。而关于`集合的遍历`是所有软件开发从业人员经常打交道的一些事情。\n\n把范围缩小到iOS开发中，关于集合地遍历的方法就有好多种，人们一直在讨论和争辩，想寻找出一种最快最有效的方法，是用`for循环`，还是`block`，是用`并发操作`，还是`顺序操作`，等等。甚至有人不惜使用`大数据量`来测试各种遍历方式的`效率`以及`精确度`。\n\n>然而我认为寻找并选择一种自己认为合适的操作是最好的，简单地几个数据的集合，就用到普通的for循环，基于大数据量的遍历就需要用到并发操作。\n<!-- more -->\n# NSPredicate\n而我并不会在这里展示如何遍历集合，而是提示一种在iOS开发中，用一种类似于SQL语句来过滤集合内容的方式从而避免了自己进行集合遍历的方法，就是`NSPredicate`。苹果在Cocoa touch框架给我们提供了`NSPredicate`这个类，封装了一些让我们可以直接对集合设置过滤条件的方法，而至于苹果是如何在SDK中进行数据查找地，我们并不需要关心，因为我相信它做的一定比我们好。学过`SQL语法`的人，使用`NSPredicate`会十分容易。我会在下面的内容中详细的讲述`NSPredicate`的语法规则。\n\n# 符号表达式\n如<, >, == , !=, 等等这些数学符号表达式，在NSPredicate的format中依然有效\n{% codeblock lang:objc %}\nNSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@\"SELF > 10\"];\n{% endcodeblock %}\n\"SELF\"代表的时集合中的对象本身，此时集合对象是整型数据，在iOS中的集合可以是nil之外的任何数据类型。\n\n# 范围表示\n如`IN`,`BETWEEN`等等这种代表范围区间的格式字符串，可以形象地称之为关键字\n{% codeblock lang:objc %}\nNSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@\"age BETWEEN {1,5}\"];\n{% endcodeblock %}\n\"age\"代表了集合中对象的一个实例属性，此时集合中的对象是一个个的实体。\n\n# 字符串区间\n如`BEGINSWITH`，`ENDSWITH`，`CONTAINS`，顾名思义，我们可以很容易理解他们的过滤条件\n{% codeblock lang:objc %}\nNSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@\"name CONTAINS[cd] %@\",text];\n{% endcodeblock %}\n在格式化语言中，我们仍然可以自如地使用”%@“等符号表示变量。[cd]中的c表示不区分大小写，d表示不区分发音符号。\n \n# 通配符\n如`LIKE`,这些与SQL语义中的关键字定义十分相像。\n{% codeblock lang:objc %}\nNSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@\"name LIKE[cd] '*er'\"];\n{% endcodeblock %}\n在NSPredicate格式串中，是自动给字符串加上引号的，所以我们自定义的字符串必须加上引号（单/双）\n \n# 正则匹配\n如`MATCHES`，诸如其他的查找语言，都是需要匹配正则表达式的\n{% codeblock lang:objc %}\nNSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@\"name MATCHES 'Z.+e$'\"];\n {% endcodeblock %}\n\n# 组合查询\n如`AND`，在设置过滤条件时，可能单一条件并不能满足我们的需要，所以我们就需要设置组合条件\n{% codeblock lang:objc %}\nNSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@\"name LIKE[cd] '*er'\" AND age > 10];\n{% endcodeblock %}","source":"_posts/使用谓词(NSPredicate)来提高集合遍历与过滤查找的效率.md","raw":"---\nlayout: post\ntitle: 使用谓词(NSPredicate)来提高集合遍历与过滤查找的效率\ndate: 2015-10-12\ndescription: \"介绍'NSPredicate'功能的一些设计方式\"\ntags: [OC基础]\ncategories: [Objective-C]\n---\n\n# 前言\n在开发中，我们经常会遇到一些需要，让我们从集合中查找某个值，从集合中过滤想要的内容等等，因而我们就需要`遍历`集合，加条件判断，然后获取符合条件的值。而关于`集合的遍历`是所有软件开发从业人员经常打交道的一些事情。\n\n把范围缩小到iOS开发中，关于集合地遍历的方法就有好多种，人们一直在讨论和争辩，想寻找出一种最快最有效的方法，是用`for循环`，还是`block`，是用`并发操作`，还是`顺序操作`，等等。甚至有人不惜使用`大数据量`来测试各种遍历方式的`效率`以及`精确度`。\n\n>然而我认为寻找并选择一种自己认为合适的操作是最好的，简单地几个数据的集合，就用到普通的for循环，基于大数据量的遍历就需要用到并发操作。\n<!-- more -->\n# NSPredicate\n而我并不会在这里展示如何遍历集合，而是提示一种在iOS开发中，用一种类似于SQL语句来过滤集合内容的方式从而避免了自己进行集合遍历的方法，就是`NSPredicate`。苹果在Cocoa touch框架给我们提供了`NSPredicate`这个类，封装了一些让我们可以直接对集合设置过滤条件的方法，而至于苹果是如何在SDK中进行数据查找地，我们并不需要关心，因为我相信它做的一定比我们好。学过`SQL语法`的人，使用`NSPredicate`会十分容易。我会在下面的内容中详细的讲述`NSPredicate`的语法规则。\n\n# 符号表达式\n如<, >, == , !=, 等等这些数学符号表达式，在NSPredicate的format中依然有效\n{% codeblock lang:objc %}\nNSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@\"SELF > 10\"];\n{% endcodeblock %}\n\"SELF\"代表的时集合中的对象本身，此时集合对象是整型数据，在iOS中的集合可以是nil之外的任何数据类型。\n\n# 范围表示\n如`IN`,`BETWEEN`等等这种代表范围区间的格式字符串，可以形象地称之为关键字\n{% codeblock lang:objc %}\nNSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@\"age BETWEEN {1,5}\"];\n{% endcodeblock %}\n\"age\"代表了集合中对象的一个实例属性，此时集合中的对象是一个个的实体。\n\n# 字符串区间\n如`BEGINSWITH`，`ENDSWITH`，`CONTAINS`，顾名思义，我们可以很容易理解他们的过滤条件\n{% codeblock lang:objc %}\nNSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@\"name CONTAINS[cd] %@\",text];\n{% endcodeblock %}\n在格式化语言中，我们仍然可以自如地使用”%@“等符号表示变量。[cd]中的c表示不区分大小写，d表示不区分发音符号。\n \n# 通配符\n如`LIKE`,这些与SQL语义中的关键字定义十分相像。\n{% codeblock lang:objc %}\nNSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@\"name LIKE[cd] '*er'\"];\n{% endcodeblock %}\n在NSPredicate格式串中，是自动给字符串加上引号的，所以我们自定义的字符串必须加上引号（单/双）\n \n# 正则匹配\n如`MATCHES`，诸如其他的查找语言，都是需要匹配正则表达式的\n{% codeblock lang:objc %}\nNSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@\"name MATCHES 'Z.+e$'\"];\n {% endcodeblock %}\n\n# 组合查询\n如`AND`，在设置过滤条件时，可能单一条件并不能满足我们的需要，所以我们就需要设置组合条件\n{% codeblock lang:objc %}\nNSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@\"name LIKE[cd] '*er'\" AND age > 10];\n{% endcodeblock %}","slug":"使用谓词(NSPredicate)来提高集合遍历与过滤查找的效率","published":1,"updated":"2016-04-12T06:50:49.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9u3001d94suvzp9it26","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在开发中，我们经常会遇到一些需要，让我们从集合中查找某个值，从集合中过滤想要的内容等等，因而我们就需要<code>遍历</code>集合，加条件判断，然后获取符合条件的值。而关于<code>集合的遍历</code>是所有软件开发从业人员经常打交道的一些事情。</p>\n<p>把范围缩小到iOS开发中，关于集合地遍历的方法就有好多种，人们一直在讨论和争辩，想寻找出一种最快最有效的方法，是用<code>for循环</code>，还是<code>block</code>，是用<code>并发操作</code>，还是<code>顺序操作</code>，等等。甚至有人不惜使用<code>大数据量</code>来测试各种遍历方式的<code>效率</code>以及<code>精确度</code>。</p>\n<blockquote>\n<p>然而我认为寻找并选择一种自己认为合适的操作是最好的，简单地几个数据的集合，就用到普通的for循环，基于大数据量的遍历就需要用到并发操作。<br><a id=\"more\"></a></p>\n<h1 id=\"NSPredicate\"><a href=\"#NSPredicate\" class=\"headerlink\" title=\"NSPredicate\"></a>NSPredicate</h1><p>而我并不会在这里展示如何遍历集合，而是提示一种在iOS开发中，用一种类似于SQL语句来过滤集合内容的方式从而避免了自己进行集合遍历的方法，就是<code>NSPredicate</code>。苹果在Cocoa touch框架给我们提供了<code>NSPredicate</code>这个类，封装了一些让我们可以直接对集合设置过滤条件的方法，而至于苹果是如何在SDK中进行数据查找地，我们并不需要关心，因为我相信它做的一定比我们好。学过<code>SQL语法</code>的人，使用<code>NSPredicate</code>会十分容易。我会在下面的内容中详细的讲述<code>NSPredicate</code>的语法规则。</p>\n</blockquote>\n<h1 id=\"符号表达式\"><a href=\"#符号表达式\" class=\"headerlink\" title=\"符号表达式\"></a>符号表达式</h1><p>如&lt;, &gt;, == , !=, 等等这些数学符号表达式，在NSPredicate的format中依然有效<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *filterPredicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"SELF &gt; 10\"</span>];</span><br></pre></td></tr></table></figure><br>“SELF”代表的时集合中的对象本身，此时集合对象是整型数据，在iOS中的集合可以是nil之外的任何数据类型。</p>\n<h1 id=\"范围表示\"><a href=\"#范围表示\" class=\"headerlink\" title=\"范围表示\"></a>范围表示</h1><p>如<code>IN</code>,<code>BETWEEN</code>等等这种代表范围区间的格式字符串，可以形象地称之为关键字<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *filterPredicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"age BETWEEN &#123;1,5&#125;\"</span>];</span><br></pre></td></tr></table></figure><br>“age”代表了集合中对象的一个实例属性，此时集合中的对象是一个个的实体。</p>\n<h1 id=\"字符串区间\"><a href=\"#字符串区间\" class=\"headerlink\" title=\"字符串区间\"></a>字符串区间</h1><p>如<code>BEGINSWITH</code>，<code>ENDSWITH</code>，<code>CONTAINS</code>，顾名思义，我们可以很容易理解他们的过滤条件<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *filterPredicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"name CONTAINS[cd] %@\"</span>,text];</span><br></pre></td></tr></table></figure><br>在格式化语言中，我们仍然可以自如地使用”%@“等符号表示变量。[cd]中的c表示不区分大小写，d表示不区分发音符号。</p>\n<h1 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h1><p>如<code>LIKE</code>,这些与SQL语义中的关键字定义十分相像。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *filterPredicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"name LIKE[cd] '*er'\"</span>];</span><br></pre></td></tr></table></figure><br>在NSPredicate格式串中，是自动给字符串加上引号的，所以我们自定义的字符串必须加上引号（单/双）</p>\n<h1 id=\"正则匹配\"><a href=\"#正则匹配\" class=\"headerlink\" title=\"正则匹配\"></a>正则匹配</h1><p>如<code>MATCHES</code>，诸如其他的查找语言，都是需要匹配正则表达式的<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *filterPredicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"name MATCHES 'Z.+e$'\"</span>];</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure></p>\n<h1 id=\"组合查询\"><a href=\"#组合查询\" class=\"headerlink\" title=\"组合查询\"></a>组合查询</h1><p>如<code>AND</code>，在设置过滤条件时，可能单一条件并不能满足我们的需要，所以我们就需要设置组合条件<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *filterPredicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"name LIKE[cd] '*er'\"</span> AND age &gt; <span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在开发中，我们经常会遇到一些需要，让我们从集合中查找某个值，从集合中过滤想要的内容等等，因而我们就需要<code>遍历</code>集合，加条件判断，然后获取符合条件的值。而关于<code>集合的遍历</code>是所有软件开发从业人员经常打交道的一些事情。</p>\n<p>把范围缩小到iOS开发中，关于集合地遍历的方法就有好多种，人们一直在讨论和争辩，想寻找出一种最快最有效的方法，是用<code>for循环</code>，还是<code>block</code>，是用<code>并发操作</code>，还是<code>顺序操作</code>，等等。甚至有人不惜使用<code>大数据量</code>来测试各种遍历方式的<code>效率</code>以及<code>精确度</code>。</p>\n<blockquote>\n<p>然而我认为寻找并选择一种自己认为合适的操作是最好的，简单地几个数据的集合，就用到普通的for循环，基于大数据量的遍历就需要用到并发操作。<br>","more":"</p>\n<h1 id=\"NSPredicate\"><a href=\"#NSPredicate\" class=\"headerlink\" title=\"NSPredicate\"></a>NSPredicate</h1><p>而我并不会在这里展示如何遍历集合，而是提示一种在iOS开发中，用一种类似于SQL语句来过滤集合内容的方式从而避免了自己进行集合遍历的方法，就是<code>NSPredicate</code>。苹果在Cocoa touch框架给我们提供了<code>NSPredicate</code>这个类，封装了一些让我们可以直接对集合设置过滤条件的方法，而至于苹果是如何在SDK中进行数据查找地，我们并不需要关心，因为我相信它做的一定比我们好。学过<code>SQL语法</code>的人，使用<code>NSPredicate</code>会十分容易。我会在下面的内容中详细的讲述<code>NSPredicate</code>的语法规则。</p>\n</blockquote>\n<h1 id=\"符号表达式\"><a href=\"#符号表达式\" class=\"headerlink\" title=\"符号表达式\"></a>符号表达式</h1><p>如&lt;, &gt;, == , !=, 等等这些数学符号表达式，在NSPredicate的format中依然有效<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *filterPredicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"SELF &gt; 10\"</span>];</span><br></pre></td></tr></table></figure><br>“SELF”代表的时集合中的对象本身，此时集合对象是整型数据，在iOS中的集合可以是nil之外的任何数据类型。</p>\n<h1 id=\"范围表示\"><a href=\"#范围表示\" class=\"headerlink\" title=\"范围表示\"></a>范围表示</h1><p>如<code>IN</code>,<code>BETWEEN</code>等等这种代表范围区间的格式字符串，可以形象地称之为关键字<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *filterPredicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"age BETWEEN &#123;1,5&#125;\"</span>];</span><br></pre></td></tr></table></figure><br>“age”代表了集合中对象的一个实例属性，此时集合中的对象是一个个的实体。</p>\n<h1 id=\"字符串区间\"><a href=\"#字符串区间\" class=\"headerlink\" title=\"字符串区间\"></a>字符串区间</h1><p>如<code>BEGINSWITH</code>，<code>ENDSWITH</code>，<code>CONTAINS</code>，顾名思义，我们可以很容易理解他们的过滤条件<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *filterPredicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"name CONTAINS[cd] %@\"</span>,text];</span><br></pre></td></tr></table></figure><br>在格式化语言中，我们仍然可以自如地使用”%@“等符号表示变量。[cd]中的c表示不区分大小写，d表示不区分发音符号。</p>\n<h1 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h1><p>如<code>LIKE</code>,这些与SQL语义中的关键字定义十分相像。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *filterPredicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"name LIKE[cd] '*er'\"</span>];</span><br></pre></td></tr></table></figure><br>在NSPredicate格式串中，是自动给字符串加上引号的，所以我们自定义的字符串必须加上引号（单/双）</p>\n<h1 id=\"正则匹配\"><a href=\"#正则匹配\" class=\"headerlink\" title=\"正则匹配\"></a>正则匹配</h1><p>如<code>MATCHES</code>，诸如其他的查找语言，都是需要匹配正则表达式的<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *filterPredicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"name MATCHES 'Z.+e$'\"</span>];</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure></p>\n<h1 id=\"组合查询\"><a href=\"#组合查询\" class=\"headerlink\" title=\"组合查询\"></a>组合查询</h1><p>如<code>AND</code>，在设置过滤条件时，可能单一条件并不能满足我们的需要，所以我们就需要设置组合条件<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSPredicate</span> *filterPredicate = [<span class=\"built_in\">NSPredicate</span> predicateWithFormat:<span class=\"string\">@\"name LIKE[cd] '*er'\"</span> AND age &gt; <span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure></p>"},{"layout":"post","title":"使用KVC自定义UISearchBar外观","date":"2015-10-24T16:00:00.000Z","description":"介绍'UISearchBar'定制外观的一些方式","_content":"\n# 前言\n在iOS8中，Apple在UIKit框架中给我们提供了`UISearchController`来代替之前的`UISearchDisplayController`，在`UISearchController`中，我们无需再自己初始化`UISearchBar`，只需要提供searchResult展示的视图。然而在开发中，我们往往需要根据项目的风格来改变`UISearchBar`的外观，通过继承的方式，我们可以完全定制符合项目风格的外观，然而有些情况下我们很难短时间内完成全部的外观定制工作，譬如我们项目用的好几个旧框架，代码中充斥着各种写好的`UISearchBar`的展示，而改动底层框架并不是一个较好地实践。于是我开始搜索并总结出了几个不通过继承的方式来更改UISearchBar外观的方法。\n<!-- more -->\n# 获取子view\n我们在`UISearchController`或者是`UISearchDisplayController`中都可以直接获取到`UISearchBar`的实例，我们可以从这里改变一些UISearchBar的属性来改变外观显示。同时我们也可以直接获取UISearchBar的subViews,UISearchBar的subView是一个UIView的实例，这个UIView包含了所有在UISearchBar上可以展示的子视图，iOS SDK提供的UISearchBar，在iOS7之前是分为`UISearchBarBackground`、`UISearchBarTextField`、`UIButton`这几个类的实例组成，而在iOS7之后，是将UIButton转换为了`UINavigationButton`的实例。\n\n#### 1.我们可以通过循环遍历出UISearchBar上所有展示出来的子视图\n{% codeblock lang:objc %}\nfor(UIView*viewin[[[_searchController.searchBar subviews]lastObject]subviews] ) {\n\tif([view isKindOfClass:NSClassFromString(@\"UISearchBarBackground\")]) {}\n\tif([view isKindOfClass:NSClassFromString(@\"UISearchBarTextField\")]) {}\n\tif([view isKindOfClass:NSClassFromString(@\"UINavigationButton\")]) {}\n}\n{% endcodeblock %}\n\n#### 2.通过KVC获取子视图\n{% codeblock lang:objc %}\nUIView *backgroundView = [_searchController.searchBar valueForKey:@\"_background\"];\nUITextField *searchField = [_searchController.searchBar valueForKey:@\"_searchField\"];\nUIButton *cancelButton = [_searchController.searchBar valueForKey:@\"_cancelButton\"];\n{% endcodeblock %}\n\n#### 3.当我们获取cancelButton时，一定要确保cancelButton包含在了UISearchBar中，必要时可以提前调用：\n{% codeblock lang:objc %}\n[_searchController.searchBar setShowsCancelButton:YES animated:NO];\n{% endcodeblock %}\n\n# 去掉搜索框背景\n{% codeblock lang:objc %}\nfor(UIView*viewin[[[_searchController.searchBar subviews]lastObject]subviews] ) {\n\tif([view isKindOfClass:NSClassFromString(@\"UISearchBarBackground\")]) {\n\t\t[view removeFromSuperview];\n\t}\n}\n{% endcodeblock %}\n\n# 去掉搜索框边框\n{% codeblock lang:objc %}\n[_searchController.searchBar setBackgroundImage:[UIImage new]];\n{% endcodeblock %}\n\n# 改变输入框文本\n{% codeblock lang:objc %}\n//提示文本颜色\n\nUITextField*searchField = [_searchController.searchBar valueForKey:@\"_searchField\"];\n\n[searchFieldsetTextColor:[UIColorblackColor]];\n\n[searchFieldsetValue:[UIColorgrayColor]forKeyPath:@\"_placeholderLabel.textColor\"];\n\n[searchFieldsetFont:[UIFontsystemFontOfSize:14]];\n\n[searchFieldsetBackgroundColor:[UIColorwhiteColor]];\n{% endcodeblock %}\n\n# 改变取消按钮的title\n{% codeblock lang:objc %}\nUIButton*cancelButton = [_searchController.searchBar valueForKey:@\"_cancelButton\"];\n\n[cancelButtonsetTitle:@\"Close\"forState:UIControlStateNormal];\n{% endcodeblock %}","source":"_posts/使用KVC自定义UISearchBar外观.md","raw":"---\nlayout: post\ntitle: 使用KVC自定义UISearchBar外观\ndate: 2015-10-25\ndescription: \"介绍'UISearchBar'定制外观的一些方式\"\ntags: [UIKit]\ncategories: [iOS]\n---\n\n# 前言\n在iOS8中，Apple在UIKit框架中给我们提供了`UISearchController`来代替之前的`UISearchDisplayController`，在`UISearchController`中，我们无需再自己初始化`UISearchBar`，只需要提供searchResult展示的视图。然而在开发中，我们往往需要根据项目的风格来改变`UISearchBar`的外观，通过继承的方式，我们可以完全定制符合项目风格的外观，然而有些情况下我们很难短时间内完成全部的外观定制工作，譬如我们项目用的好几个旧框架，代码中充斥着各种写好的`UISearchBar`的展示，而改动底层框架并不是一个较好地实践。于是我开始搜索并总结出了几个不通过继承的方式来更改UISearchBar外观的方法。\n<!-- more -->\n# 获取子view\n我们在`UISearchController`或者是`UISearchDisplayController`中都可以直接获取到`UISearchBar`的实例，我们可以从这里改变一些UISearchBar的属性来改变外观显示。同时我们也可以直接获取UISearchBar的subViews,UISearchBar的subView是一个UIView的实例，这个UIView包含了所有在UISearchBar上可以展示的子视图，iOS SDK提供的UISearchBar，在iOS7之前是分为`UISearchBarBackground`、`UISearchBarTextField`、`UIButton`这几个类的实例组成，而在iOS7之后，是将UIButton转换为了`UINavigationButton`的实例。\n\n#### 1.我们可以通过循环遍历出UISearchBar上所有展示出来的子视图\n{% codeblock lang:objc %}\nfor(UIView*viewin[[[_searchController.searchBar subviews]lastObject]subviews] ) {\n\tif([view isKindOfClass:NSClassFromString(@\"UISearchBarBackground\")]) {}\n\tif([view isKindOfClass:NSClassFromString(@\"UISearchBarTextField\")]) {}\n\tif([view isKindOfClass:NSClassFromString(@\"UINavigationButton\")]) {}\n}\n{% endcodeblock %}\n\n#### 2.通过KVC获取子视图\n{% codeblock lang:objc %}\nUIView *backgroundView = [_searchController.searchBar valueForKey:@\"_background\"];\nUITextField *searchField = [_searchController.searchBar valueForKey:@\"_searchField\"];\nUIButton *cancelButton = [_searchController.searchBar valueForKey:@\"_cancelButton\"];\n{% endcodeblock %}\n\n#### 3.当我们获取cancelButton时，一定要确保cancelButton包含在了UISearchBar中，必要时可以提前调用：\n{% codeblock lang:objc %}\n[_searchController.searchBar setShowsCancelButton:YES animated:NO];\n{% endcodeblock %}\n\n# 去掉搜索框背景\n{% codeblock lang:objc %}\nfor(UIView*viewin[[[_searchController.searchBar subviews]lastObject]subviews] ) {\n\tif([view isKindOfClass:NSClassFromString(@\"UISearchBarBackground\")]) {\n\t\t[view removeFromSuperview];\n\t}\n}\n{% endcodeblock %}\n\n# 去掉搜索框边框\n{% codeblock lang:objc %}\n[_searchController.searchBar setBackgroundImage:[UIImage new]];\n{% endcodeblock %}\n\n# 改变输入框文本\n{% codeblock lang:objc %}\n//提示文本颜色\n\nUITextField*searchField = [_searchController.searchBar valueForKey:@\"_searchField\"];\n\n[searchFieldsetTextColor:[UIColorblackColor]];\n\n[searchFieldsetValue:[UIColorgrayColor]forKeyPath:@\"_placeholderLabel.textColor\"];\n\n[searchFieldsetFont:[UIFontsystemFontOfSize:14]];\n\n[searchFieldsetBackgroundColor:[UIColorwhiteColor]];\n{% endcodeblock %}\n\n# 改变取消按钮的title\n{% codeblock lang:objc %}\nUIButton*cancelButton = [_searchController.searchBar valueForKey:@\"_cancelButton\"];\n\n[cancelButtonsetTitle:@\"Close\"forState:UIControlStateNormal];\n{% endcodeblock %}","slug":"使用KVC自定义UISearchBar外观","published":1,"updated":"2016-04-12T06:51:10.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9u6001g94sugqjpot4f","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在iOS8中，Apple在UIKit框架中给我们提供了<code>UISearchController</code>来代替之前的<code>UISearchDisplayController</code>，在<code>UISearchController</code>中，我们无需再自己初始化<code>UISearchBar</code>，只需要提供searchResult展示的视图。然而在开发中，我们往往需要根据项目的风格来改变<code>UISearchBar</code>的外观，通过继承的方式，我们可以完全定制符合项目风格的外观，然而有些情况下我们很难短时间内完成全部的外观定制工作，譬如我们项目用的好几个旧框架，代码中充斥着各种写好的<code>UISearchBar</code>的展示，而改动底层框架并不是一个较好地实践。于是我开始搜索并总结出了几个不通过继承的方式来更改UISearchBar外观的方法。<br><a id=\"more\"></a></p>\n<h1 id=\"获取子view\"><a href=\"#获取子view\" class=\"headerlink\" title=\"获取子view\"></a>获取子view</h1><p>我们在<code>UISearchController</code>或者是<code>UISearchDisplayController</code>中都可以直接获取到<code>UISearchBar</code>的实例，我们可以从这里改变一些UISearchBar的属性来改变外观显示。同时我们也可以直接获取UISearchBar的subViews,UISearchBar的subView是一个UIView的实例，这个UIView包含了所有在UISearchBar上可以展示的子视图，iOS SDK提供的UISearchBar，在iOS7之前是分为<code>UISearchBarBackground</code>、<code>UISearchBarTextField</code>、<code>UIButton</code>这几个类的实例组成，而在iOS7之后，是将UIButton转换为了<code>UINavigationButton</code>的实例。</p>\n<h4 id=\"1-我们可以通过循环遍历出UISearchBar上所有展示出来的子视图\"><a href=\"#1-我们可以通过循环遍历出UISearchBar上所有展示出来的子视图\" class=\"headerlink\" title=\"1.我们可以通过循环遍历出UISearchBar上所有展示出来的子视图\"></a>1.我们可以通过循环遍历出UISearchBar上所有展示出来的子视图</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">UIView</span>*viewin[[[_searchController.searchBar subviews]lastObject]subviews] ) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>([view isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"UISearchBarBackground\"</span>)]) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>([view isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"UISearchBarTextField\"</span>)]) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>([view isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"UINavigationButton\"</span>)]) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-通过KVC获取子视图\"><a href=\"#2-通过KVC获取子视图\" class=\"headerlink\" title=\"2.通过KVC获取子视图\"></a>2.通过KVC获取子视图</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIView</span> *backgroundView = [_searchController.searchBar valueForKey:<span class=\"string\">@\"_background\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">UITextField</span> *searchField = [_searchController.searchBar valueForKey:<span class=\"string\">@\"_searchField\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">UIButton</span> *cancelButton = [_searchController.searchBar valueForKey:<span class=\"string\">@\"_cancelButton\"</span>];</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-当我们获取cancelButton时，一定要确保cancelButton包含在了UISearchBar中，必要时可以提前调用：\"><a href=\"#3-当我们获取cancelButton时，一定要确保cancelButton包含在了UISearchBar中，必要时可以提前调用：\" class=\"headerlink\" title=\"3.当我们获取cancelButton时，一定要确保cancelButton包含在了UISearchBar中，必要时可以提前调用：\"></a>3.当我们获取cancelButton时，一定要确保cancelButton包含在了UISearchBar中，必要时可以提前调用：</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[_searchController.searchBar setShowsCancelButton:<span class=\"literal\">YES</span> animated:<span class=\"literal\">NO</span>];</span><br></pre></td></tr></table></figure>\n<h1 id=\"去掉搜索框背景\"><a href=\"#去掉搜索框背景\" class=\"headerlink\" title=\"去掉搜索框背景\"></a>去掉搜索框背景</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">UIView</span>*viewin[[[_searchController.searchBar subviews]lastObject]subviews] ) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>([view isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"UISearchBarBackground\"</span>)]) &#123;</span><br><span class=\"line\">\t\t[view removeFromSuperview];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"去掉搜索框边框\"><a href=\"#去掉搜索框边框\" class=\"headerlink\" title=\"去掉搜索框边框\"></a>去掉搜索框边框</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[_searchController.searchBar setBackgroundImage:[<span class=\"built_in\">UIImage</span> new]];</span><br></pre></td></tr></table></figure>\n<h1 id=\"改变输入框文本\"><a href=\"#改变输入框文本\" class=\"headerlink\" title=\"改变输入框文本\"></a>改变输入框文本</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//提示文本颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UITextField</span>*searchField = [_searchController.searchBar valueForKey:<span class=\"string\">@\"_searchField\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[searchFieldsetTextColor:[<span class=\"built_in\">UIColorblackColor</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">[searchFieldsetValue:[<span class=\"built_in\">UIColorgrayColor</span>]forKeyPath:<span class=\"string\">@\"_placeholderLabel.textColor\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[searchFieldsetFont:[<span class=\"built_in\">UIFontsystemFontOfSize</span>:<span class=\"number\">14</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">[searchFieldsetBackgroundColor:[<span class=\"built_in\">UIColorwhiteColor</span>]];</span><br></pre></td></tr></table></figure>\n<h1 id=\"改变取消按钮的title\"><a href=\"#改变取消按钮的title\" class=\"headerlink\" title=\"改变取消按钮的title\"></a>改变取消按钮的title</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span>*cancelButton = [_searchController.searchBar valueForKey:<span class=\"string\">@\"_cancelButton\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[cancelButtonsetTitle:<span class=\"string\">@\"Close\"</span>forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br></pre></td></tr></table></figure>","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在iOS8中，Apple在UIKit框架中给我们提供了<code>UISearchController</code>来代替之前的<code>UISearchDisplayController</code>，在<code>UISearchController</code>中，我们无需再自己初始化<code>UISearchBar</code>，只需要提供searchResult展示的视图。然而在开发中，我们往往需要根据项目的风格来改变<code>UISearchBar</code>的外观，通过继承的方式，我们可以完全定制符合项目风格的外观，然而有些情况下我们很难短时间内完成全部的外观定制工作，譬如我们项目用的好几个旧框架，代码中充斥着各种写好的<code>UISearchBar</code>的展示，而改动底层框架并不是一个较好地实践。于是我开始搜索并总结出了几个不通过继承的方式来更改UISearchBar外观的方法。<br>","more":"</p>\n<h1 id=\"获取子view\"><a href=\"#获取子view\" class=\"headerlink\" title=\"获取子view\"></a>获取子view</h1><p>我们在<code>UISearchController</code>或者是<code>UISearchDisplayController</code>中都可以直接获取到<code>UISearchBar</code>的实例，我们可以从这里改变一些UISearchBar的属性来改变外观显示。同时我们也可以直接获取UISearchBar的subViews,UISearchBar的subView是一个UIView的实例，这个UIView包含了所有在UISearchBar上可以展示的子视图，iOS SDK提供的UISearchBar，在iOS7之前是分为<code>UISearchBarBackground</code>、<code>UISearchBarTextField</code>、<code>UIButton</code>这几个类的实例组成，而在iOS7之后，是将UIButton转换为了<code>UINavigationButton</code>的实例。</p>\n<h4 id=\"1-我们可以通过循环遍历出UISearchBar上所有展示出来的子视图\"><a href=\"#1-我们可以通过循环遍历出UISearchBar上所有展示出来的子视图\" class=\"headerlink\" title=\"1.我们可以通过循环遍历出UISearchBar上所有展示出来的子视图\"></a>1.我们可以通过循环遍历出UISearchBar上所有展示出来的子视图</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">UIView</span>*viewin[[[_searchController.searchBar subviews]lastObject]subviews] ) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>([view isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"UISearchBarBackground\"</span>)]) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>([view isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"UISearchBarTextField\"</span>)]) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>([view isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"UINavigationButton\"</span>)]) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-通过KVC获取子视图\"><a href=\"#2-通过KVC获取子视图\" class=\"headerlink\" title=\"2.通过KVC获取子视图\"></a>2.通过KVC获取子视图</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIView</span> *backgroundView = [_searchController.searchBar valueForKey:<span class=\"string\">@\"_background\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">UITextField</span> *searchField = [_searchController.searchBar valueForKey:<span class=\"string\">@\"_searchField\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">UIButton</span> *cancelButton = [_searchController.searchBar valueForKey:<span class=\"string\">@\"_cancelButton\"</span>];</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-当我们获取cancelButton时，一定要确保cancelButton包含在了UISearchBar中，必要时可以提前调用：\"><a href=\"#3-当我们获取cancelButton时，一定要确保cancelButton包含在了UISearchBar中，必要时可以提前调用：\" class=\"headerlink\" title=\"3.当我们获取cancelButton时，一定要确保cancelButton包含在了UISearchBar中，必要时可以提前调用：\"></a>3.当我们获取cancelButton时，一定要确保cancelButton包含在了UISearchBar中，必要时可以提前调用：</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[_searchController.searchBar setShowsCancelButton:<span class=\"literal\">YES</span> animated:<span class=\"literal\">NO</span>];</span><br></pre></td></tr></table></figure>\n<h1 id=\"去掉搜索框背景\"><a href=\"#去掉搜索框背景\" class=\"headerlink\" title=\"去掉搜索框背景\"></a>去掉搜索框背景</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">UIView</span>*viewin[[[_searchController.searchBar subviews]lastObject]subviews] ) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>([view isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"UISearchBarBackground\"</span>)]) &#123;</span><br><span class=\"line\">\t\t[view removeFromSuperview];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"去掉搜索框边框\"><a href=\"#去掉搜索框边框\" class=\"headerlink\" title=\"去掉搜索框边框\"></a>去掉搜索框边框</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[_searchController.searchBar setBackgroundImage:[<span class=\"built_in\">UIImage</span> new]];</span><br></pre></td></tr></table></figure>\n<h1 id=\"改变输入框文本\"><a href=\"#改变输入框文本\" class=\"headerlink\" title=\"改变输入框文本\"></a>改变输入框文本</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//提示文本颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UITextField</span>*searchField = [_searchController.searchBar valueForKey:<span class=\"string\">@\"_searchField\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[searchFieldsetTextColor:[<span class=\"built_in\">UIColorblackColor</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">[searchFieldsetValue:[<span class=\"built_in\">UIColorgrayColor</span>]forKeyPath:<span class=\"string\">@\"_placeholderLabel.textColor\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[searchFieldsetFont:[<span class=\"built_in\">UIFontsystemFontOfSize</span>:<span class=\"number\">14</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">[searchFieldsetBackgroundColor:[<span class=\"built_in\">UIColorwhiteColor</span>]];</span><br></pre></td></tr></table></figure>\n<h1 id=\"改变取消按钮的title\"><a href=\"#改变取消按钮的title\" class=\"headerlink\" title=\"改变取消按钮的title\"></a>改变取消按钮的title</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span>*cancelButton = [_searchController.searchBar valueForKey:<span class=\"string\">@\"_cancelButton\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[cancelButtonsetTitle:<span class=\"string\">@\"Close\"</span>forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"使用Mockplus设计产品原型","date":"2015-09-17T16:00:00.000Z","description":"介绍产品设计相关的工具","_content":"\n# 前言\n最近接到了一项没有时间限制却比较重的任务，要对app进行UI上的重构。由于产品年代已久，而且UI也是相当得陈旧了,我们也没有直接地产品经理，所以难度可以想象。在这里我们每个开发人员都算是一个产品经理，这大概也是好多开发者期望得把。\n\n# 产品设计\n一个好的产品必须有一个好的设计，所以我开始从网上汲取一些软件设计的知识，作为一个尚未入门的设计师，我首先推荐一篇启蒙的博客：[一个门外汉的产品设计漫谈](http://www.alibuybuy.com/posts/77556.html)。而在CocoaChina上面也将产品设计单独做出了一个分类，上面贴出了许多与产品设计的主流趋势相关的博客，欣赏之下，的确发人深省。有了好的设计理念，然后再有一个好的设计工具，如此设计出来的产品必将生动形象，受人欢迎。\n<!-- more -->\n# 原型设计\n因为本人只是一名开发者，对产品设计的理念并不深懂，所以也就不再卖弄了，本篇博客主要地说一下我们做产品原型的工具。读到网上的博客“为原型产品推荐的四款设计工具”中提到了比较好用的做产品原型设计的工具，其中有知名的`Axure RP`这些主流工具，然而熟悉之下来看，做iOS产品原型这些工具并不专一，而且用起来相当不方便。在这里我给大家推荐一款个人认为比较好的一款工具：Mockplus。\n\n# Mockplus\n`Mockplus`是一款专做`iOS产品原型`的工具，拥有非常多的用户，还一直在不断地更新完善中。而且官网上帮助文档很多，写的也很好，官方社区也是相当活跃，使用时有什么困扰地可以进社区寻求帮助。最主要的还是Mockplus的使用相当简化，控件非常丰富，控件交互也设计地非常符合要求，是一款很好的设计工具。而且Mockplus还提供了更人性化的动态演示，甚至我们可以通过局域网在自己的手机上对设备进行演示\n{% img /images/Mockplus.png %}\n\n# 更新\n最近一直流行使用`Sketch`来做iOS app 的图标和UI设计等，由于是付费的软件，暂时没有涉猎。在iOS 8之后，苹果提供了`Size Class`的概念，使得我们在`storyboard`上针对不同的设备尺寸和屏幕分辨率，设计UI以及为UI控件添加约束变得更加简单，方便。因此个人感觉在storyboard上做设计也是一种可取的办法。","source":"_posts/使用Mockplus设计产品原型.md","raw":"---\nlayout: post\ntitle: 使用Mockplus设计产品原型\ndate: 2015-09-18\ndescription: \"介绍产品设计相关的工具\"\ntags: [设计]\ncategories: [设计]\n---\n\n# 前言\n最近接到了一项没有时间限制却比较重的任务，要对app进行UI上的重构。由于产品年代已久，而且UI也是相当得陈旧了,我们也没有直接地产品经理，所以难度可以想象。在这里我们每个开发人员都算是一个产品经理，这大概也是好多开发者期望得把。\n\n# 产品设计\n一个好的产品必须有一个好的设计，所以我开始从网上汲取一些软件设计的知识，作为一个尚未入门的设计师，我首先推荐一篇启蒙的博客：[一个门外汉的产品设计漫谈](http://www.alibuybuy.com/posts/77556.html)。而在CocoaChina上面也将产品设计单独做出了一个分类，上面贴出了许多与产品设计的主流趋势相关的博客，欣赏之下，的确发人深省。有了好的设计理念，然后再有一个好的设计工具，如此设计出来的产品必将生动形象，受人欢迎。\n<!-- more -->\n# 原型设计\n因为本人只是一名开发者，对产品设计的理念并不深懂，所以也就不再卖弄了，本篇博客主要地说一下我们做产品原型的工具。读到网上的博客“为原型产品推荐的四款设计工具”中提到了比较好用的做产品原型设计的工具，其中有知名的`Axure RP`这些主流工具，然而熟悉之下来看，做iOS产品原型这些工具并不专一，而且用起来相当不方便。在这里我给大家推荐一款个人认为比较好的一款工具：Mockplus。\n\n# Mockplus\n`Mockplus`是一款专做`iOS产品原型`的工具，拥有非常多的用户，还一直在不断地更新完善中。而且官网上帮助文档很多，写的也很好，官方社区也是相当活跃，使用时有什么困扰地可以进社区寻求帮助。最主要的还是Mockplus的使用相当简化，控件非常丰富，控件交互也设计地非常符合要求，是一款很好的设计工具。而且Mockplus还提供了更人性化的动态演示，甚至我们可以通过局域网在自己的手机上对设备进行演示\n{% img /images/Mockplus.png %}\n\n# 更新\n最近一直流行使用`Sketch`来做iOS app 的图标和UI设计等，由于是付费的软件，暂时没有涉猎。在iOS 8之后，苹果提供了`Size Class`的概念，使得我们在`storyboard`上针对不同的设备尺寸和屏幕分辨率，设计UI以及为UI控件添加约束变得更加简单，方便。因此个人感觉在storyboard上做设计也是一种可取的办法。","slug":"使用Mockplus设计产品原型","published":1,"updated":"2016-04-12T06:50:10.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9u8001k94su3kkjk7nx","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近接到了一项没有时间限制却比较重的任务，要对app进行UI上的重构。由于产品年代已久，而且UI也是相当得陈旧了,我们也没有直接地产品经理，所以难度可以想象。在这里我们每个开发人员都算是一个产品经理，这大概也是好多开发者期望得把。</p>\n<h1 id=\"产品设计\"><a href=\"#产品设计\" class=\"headerlink\" title=\"产品设计\"></a>产品设计</h1><p>一个好的产品必须有一个好的设计，所以我开始从网上汲取一些软件设计的知识，作为一个尚未入门的设计师，我首先推荐一篇启蒙的博客：<a href=\"http://www.alibuybuy.com/posts/77556.html\" target=\"_blank\" rel=\"external\">一个门外汉的产品设计漫谈</a>。而在CocoaChina上面也将产品设计单独做出了一个分类，上面贴出了许多与产品设计的主流趋势相关的博客，欣赏之下，的确发人深省。有了好的设计理念，然后再有一个好的设计工具，如此设计出来的产品必将生动形象，受人欢迎。<br><a id=\"more\"></a></p>\n<h1 id=\"原型设计\"><a href=\"#原型设计\" class=\"headerlink\" title=\"原型设计\"></a>原型设计</h1><p>因为本人只是一名开发者，对产品设计的理念并不深懂，所以也就不再卖弄了，本篇博客主要地说一下我们做产品原型的工具。读到网上的博客“为原型产品推荐的四款设计工具”中提到了比较好用的做产品原型设计的工具，其中有知名的<code>Axure RP</code>这些主流工具，然而熟悉之下来看，做iOS产品原型这些工具并不专一，而且用起来相当不方便。在这里我给大家推荐一款个人认为比较好的一款工具：Mockplus。</p>\n<h1 id=\"Mockplus\"><a href=\"#Mockplus\" class=\"headerlink\" title=\"Mockplus\"></a>Mockplus</h1><p><code>Mockplus</code>是一款专做<code>iOS产品原型</code>的工具，拥有非常多的用户，还一直在不断地更新完善中。而且官网上帮助文档很多，写的也很好，官方社区也是相当活跃，使用时有什么困扰地可以进社区寻求帮助。最主要的还是Mockplus的使用相当简化，控件非常丰富，控件交互也设计地非常符合要求，是一款很好的设计工具。而且Mockplus还提供了更人性化的动态演示，甚至我们可以通过局域网在自己的手机上对设备进行演示<br><img src=\"/images/Mockplus.png\"></p>\n<h1 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h1><p>最近一直流行使用<code>Sketch</code>来做iOS app 的图标和UI设计等，由于是付费的软件，暂时没有涉猎。在iOS 8之后，苹果提供了<code>Size Class</code>的概念，使得我们在<code>storyboard</code>上针对不同的设备尺寸和屏幕分辨率，设计UI以及为UI控件添加约束变得更加简单，方便。因此个人感觉在storyboard上做设计也是一种可取的办法。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近接到了一项没有时间限制却比较重的任务，要对app进行UI上的重构。由于产品年代已久，而且UI也是相当得陈旧了,我们也没有直接地产品经理，所以难度可以想象。在这里我们每个开发人员都算是一个产品经理，这大概也是好多开发者期望得把。</p>\n<h1 id=\"产品设计\"><a href=\"#产品设计\" class=\"headerlink\" title=\"产品设计\"></a>产品设计</h1><p>一个好的产品必须有一个好的设计，所以我开始从网上汲取一些软件设计的知识，作为一个尚未入门的设计师，我首先推荐一篇启蒙的博客：<a href=\"http://www.alibuybuy.com/posts/77556.html\">一个门外汉的产品设计漫谈</a>。而在CocoaChina上面也将产品设计单独做出了一个分类，上面贴出了许多与产品设计的主流趋势相关的博客，欣赏之下，的确发人深省。有了好的设计理念，然后再有一个好的设计工具，如此设计出来的产品必将生动形象，受人欢迎。<br>","more":"</p>\n<h1 id=\"原型设计\"><a href=\"#原型设计\" class=\"headerlink\" title=\"原型设计\"></a>原型设计</h1><p>因为本人只是一名开发者，对产品设计的理念并不深懂，所以也就不再卖弄了，本篇博客主要地说一下我们做产品原型的工具。读到网上的博客“为原型产品推荐的四款设计工具”中提到了比较好用的做产品原型设计的工具，其中有知名的<code>Axure RP</code>这些主流工具，然而熟悉之下来看，做iOS产品原型这些工具并不专一，而且用起来相当不方便。在这里我给大家推荐一款个人认为比较好的一款工具：Mockplus。</p>\n<h1 id=\"Mockplus\"><a href=\"#Mockplus\" class=\"headerlink\" title=\"Mockplus\"></a>Mockplus</h1><p><code>Mockplus</code>是一款专做<code>iOS产品原型</code>的工具，拥有非常多的用户，还一直在不断地更新完善中。而且官网上帮助文档很多，写的也很好，官方社区也是相当活跃，使用时有什么困扰地可以进社区寻求帮助。最主要的还是Mockplus的使用相当简化，控件非常丰富，控件交互也设计地非常符合要求，是一款很好的设计工具。而且Mockplus还提供了更人性化的动态演示，甚至我们可以通过局域网在自己的手机上对设备进行演示<br><img src=\"/images/Mockplus.png\"></p>\n<h1 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h1><p>最近一直流行使用<code>Sketch</code>来做iOS app 的图标和UI设计等，由于是付费的软件，暂时没有涉猎。在iOS 8之后，苹果提供了<code>Size Class</code>的概念，使得我们在<code>storyboard</code>上针对不同的设备尺寸和屏幕分辨率，设计UI以及为UI控件添加约束变得更加简单，方便。因此个人感觉在storyboard上做设计也是一种可取的办法。</p>"},{"layout":"post","title":"使用注释提高iOS开发效率","date":"2015-07-24T16:00:00.000Z","_content":"\n# 前言　　\n新手在开始参与一个开发项目的时候，会把大部分的时间耗费在阅读项目的`需求文档`、`开发文档`和`代码`，一篇好的`需求文档`和`开发文档`会帮助新手很快的理解项目的目标和进度，而新手对于代码的阅读会先从代码的注释开始。拥有良好`注释`的代码可以省去团队其他的开发者好多时间，不至于让其他参与者去一行一行的阅读代码，去不断地加断点查看代码地跳转逻辑，接下来我们就谈谈iOS开发中使用的一些注释。\n<!-- more -->\n# \\#pragma mark\n确切地说，这是Xcode编译器特定得编译命令，它的作用就是在代码地编辑器中，将顶部的方法函数弹出菜单按层次分开，方便于我们的查找。一般的使用方法是在想要分层的第一个方法或函数上面加上`#pragma mark -`　和`#pragma　mark something`(你的分层定义)。此外其他常用到的，是在我们想要标识代码的地方加上`#warning`，这样运行时编译器会自动帮助我们将代码标识到`issue　navigator`。\n\n# 自定义标示\n使用自定义的特殊标识符，例如`//TODO:`或者是`//FIXME:`。使用这一类的特殊标识符，首先需要在`Xcode`中添加支持，在我们的`Target`中，选择`Build Phases`，Xcode 6将`Build Phases`从`Build Settings`分离了出来。在`Build Phases`选择`New Run Script Phase`，然后输入：\n{% codeblock lang:bash %}\n KEYWORDS=\"TODO:|FIXME:\"\n find \"${SRCROOT}\"  −name\"∗.h\"−or−name\"∗.\"        -print0 | xargs -0 egrep --with-filename --line-number --only-matching \"($KEYWORDS).*\\$\" | perl -p -e \"s/($KEYWORDS)/ warning: \\$1/\"\n{% endcodeblock %}  \n 　\n由于本人对脚本语言不熟悉，想要深入研究的朋友们可以从网上搜索教程。在添加了上面的支持后，你就可以在代码中通过使用自定义的标识符来快速查找代码。\n     \n# 代码注释\n上面的俩种可以算是编译器识别的命令，下面我们来说一下传统意义上的代码注释。不管在使用哪种语言，我们一般都会使用到代码注释，而不同的语言有不同的注释规范，例如一般的单行注释，我们会使用`“//”`，而多行注释则会使用`\"/*......*/\"`，而对于iOS开发者来说，代码注释也拥有属于它自己的一套规范。下面就是一些常用的iOS的代码注释，这些衍生的注释目的是方便文档生成：   \n{% codeblock lang:objc %}   \n/// Single line comment.（单行文本）\n/// Single line comment spreading （多行文本）\n     /// over multiple lines.\n/** Single line comment. */ （单行文本）\n/** Single line comment spreading （多行文本）\n       * over multiple lines.\n       */\n/** Single line comment spreading （多行文本）\n       over multiple lines. No star.\n       */\n/*! Single line comment. */ （单行文本）\n/*! Single line comment spreading （多行文本）\n       over multiple lines.\n       */\n{% endcodeblock %}\n\n# 方法注释\n在iOS开发代码中有一种对方法的注释 ，其中包含了特有的指令：\n{% codeblock lang:objc %}\n  /**\n    * @brief 带字符串参数的方法.（具体描述）\n    * @param  value 值.（参数描述）\n    * @return 返回value.（返回值描述）\n    * @exception NSException 可能抛出的异常.（抛出异常描述）\n    * @see someMethod （关联描述）\n    * @warning 警告: appledoc中显示为蓝色背景, Doxygen中显示为红色竖条.（警告描述）\n    * @bug 缺陷: appledoc中显示为黄色背景, Doxygen中显示为绿色竖条.（缺陷描述）\n    */\n{% endcodeblock %}\n\n# 生成开发文档\n说起上面的这种iOS开发中的代码注释，就不得不说一下iOS开发中的文档生成，一个良好的代码文档可以帮助其他开发者很好的了解代码结构和具体内容。而时下比较流行的几个文档生成工具有下面几种，关于iOS代码文档的具体生成，我推荐朋友们观看这篇 [唐巧的技术博客-------使用Objective-C的文档生成工具](http://blog.devtang.com/blog/2012/02/01/use-appledoc-to-generate-xcode-doc/)。\n\n1. 第三方工具[Doxygen](http://www.stack.nl/~dimitri/doxygen/index.html)\n2. Xcode自带的[HeaderDoc](http://developer.apple.com/opensource/tools/headerdoc.html)\n3. 默认与苹果官方文档风格类似的[AppleDoc](http://gentlebytes.com/appledoc/)","source":"_posts/使用注释提高iOS开发效率.md","raw":"---\nlayout: post\ntitle: 使用注释提高iOS开发效率\ndate: 2015-07-25\ntags: [注释]\ncategories: [Xcode]\n---\n\n# 前言　　\n新手在开始参与一个开发项目的时候，会把大部分的时间耗费在阅读项目的`需求文档`、`开发文档`和`代码`，一篇好的`需求文档`和`开发文档`会帮助新手很快的理解项目的目标和进度，而新手对于代码的阅读会先从代码的注释开始。拥有良好`注释`的代码可以省去团队其他的开发者好多时间，不至于让其他参与者去一行一行的阅读代码，去不断地加断点查看代码地跳转逻辑，接下来我们就谈谈iOS开发中使用的一些注释。\n<!-- more -->\n# \\#pragma mark\n确切地说，这是Xcode编译器特定得编译命令，它的作用就是在代码地编辑器中，将顶部的方法函数弹出菜单按层次分开，方便于我们的查找。一般的使用方法是在想要分层的第一个方法或函数上面加上`#pragma mark -`　和`#pragma　mark something`(你的分层定义)。此外其他常用到的，是在我们想要标识代码的地方加上`#warning`，这样运行时编译器会自动帮助我们将代码标识到`issue　navigator`。\n\n# 自定义标示\n使用自定义的特殊标识符，例如`//TODO:`或者是`//FIXME:`。使用这一类的特殊标识符，首先需要在`Xcode`中添加支持，在我们的`Target`中，选择`Build Phases`，Xcode 6将`Build Phases`从`Build Settings`分离了出来。在`Build Phases`选择`New Run Script Phase`，然后输入：\n{% codeblock lang:bash %}\n KEYWORDS=\"TODO:|FIXME:\"\n find \"${SRCROOT}\"  −name\"∗.h\"−or−name\"∗.\"        -print0 | xargs -0 egrep --with-filename --line-number --only-matching \"($KEYWORDS).*\\$\" | perl -p -e \"s/($KEYWORDS)/ warning: \\$1/\"\n{% endcodeblock %}  \n 　\n由于本人对脚本语言不熟悉，想要深入研究的朋友们可以从网上搜索教程。在添加了上面的支持后，你就可以在代码中通过使用自定义的标识符来快速查找代码。\n     \n# 代码注释\n上面的俩种可以算是编译器识别的命令，下面我们来说一下传统意义上的代码注释。不管在使用哪种语言，我们一般都会使用到代码注释，而不同的语言有不同的注释规范，例如一般的单行注释，我们会使用`“//”`，而多行注释则会使用`\"/*......*/\"`，而对于iOS开发者来说，代码注释也拥有属于它自己的一套规范。下面就是一些常用的iOS的代码注释，这些衍生的注释目的是方便文档生成：   \n{% codeblock lang:objc %}   \n/// Single line comment.（单行文本）\n/// Single line comment spreading （多行文本）\n     /// over multiple lines.\n/** Single line comment. */ （单行文本）\n/** Single line comment spreading （多行文本）\n       * over multiple lines.\n       */\n/** Single line comment spreading （多行文本）\n       over multiple lines. No star.\n       */\n/*! Single line comment. */ （单行文本）\n/*! Single line comment spreading （多行文本）\n       over multiple lines.\n       */\n{% endcodeblock %}\n\n# 方法注释\n在iOS开发代码中有一种对方法的注释 ，其中包含了特有的指令：\n{% codeblock lang:objc %}\n  /**\n    * @brief 带字符串参数的方法.（具体描述）\n    * @param  value 值.（参数描述）\n    * @return 返回value.（返回值描述）\n    * @exception NSException 可能抛出的异常.（抛出异常描述）\n    * @see someMethod （关联描述）\n    * @warning 警告: appledoc中显示为蓝色背景, Doxygen中显示为红色竖条.（警告描述）\n    * @bug 缺陷: appledoc中显示为黄色背景, Doxygen中显示为绿色竖条.（缺陷描述）\n    */\n{% endcodeblock %}\n\n# 生成开发文档\n说起上面的这种iOS开发中的代码注释，就不得不说一下iOS开发中的文档生成，一个良好的代码文档可以帮助其他开发者很好的了解代码结构和具体内容。而时下比较流行的几个文档生成工具有下面几种，关于iOS代码文档的具体生成，我推荐朋友们观看这篇 [唐巧的技术博客-------使用Objective-C的文档生成工具](http://blog.devtang.com/blog/2012/02/01/use-appledoc-to-generate-xcode-doc/)。\n\n1. 第三方工具[Doxygen](http://www.stack.nl/~dimitri/doxygen/index.html)\n2. Xcode自带的[HeaderDoc](http://developer.apple.com/opensource/tools/headerdoc.html)\n3. 默认与苹果官方文档风格类似的[AppleDoc](http://gentlebytes.com/appledoc/)","slug":"使用注释提高iOS开发效率","published":1,"updated":"2016-04-12T06:45:39.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9ua001o94sul5iwcc9h","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>新手在开始参与一个开发项目的时候，会把大部分的时间耗费在阅读项目的<code>需求文档</code>、<code>开发文档</code>和<code>代码</code>，一篇好的<code>需求文档</code>和<code>开发文档</code>会帮助新手很快的理解项目的目标和进度，而新手对于代码的阅读会先从代码的注释开始。拥有良好<code>注释</code>的代码可以省去团队其他的开发者好多时间，不至于让其他参与者去一行一行的阅读代码，去不断地加断点查看代码地跳转逻辑，接下来我们就谈谈iOS开发中使用的一些注释。<br><a id=\"more\"></a></p>\n<h1 id=\"pragma-mark\"><a href=\"#pragma-mark\" class=\"headerlink\" title=\"#pragma mark\"></a>#pragma mark</h1><p>确切地说，这是Xcode编译器特定得编译命令，它的作用就是在代码地编辑器中，将顶部的方法函数弹出菜单按层次分开，方便于我们的查找。一般的使用方法是在想要分层的第一个方法或函数上面加上<code>#pragma mark -</code>　和<code>#pragma　mark something</code>(你的分层定义)。此外其他常用到的，是在我们想要标识代码的地方加上<code>#warning</code>，这样运行时编译器会自动帮助我们将代码标识到<code>issue　navigator</code>。</p>\n<h1 id=\"自定义标示\"><a href=\"#自定义标示\" class=\"headerlink\" title=\"自定义标示\"></a>自定义标示</h1><p>使用自定义的特殊标识符，例如<code>//TODO:</code>或者是<code>//FIXME:</code>。使用这一类的特殊标识符，首先需要在<code>Xcode</code>中添加支持，在我们的<code>Target</code>中，选择<code>Build Phases</code>，Xcode 6将<code>Build Phases</code>从<code>Build Settings</code>分离了出来。在<code>Build Phases</code>选择<code>New Run Script Phase</code>，然后输入：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEYWORDS=<span class=\"string\">\"TODO:|FIXME:\"</span></span><br><span class=\"line\">find <span class=\"string\">\"<span class=\"variable\">$&#123;SRCROOT&#125;</span>\"</span>  −name<span class=\"string\">\"∗.h\"</span>−or−name<span class=\"string\">\"∗.\"</span>        -print0 | xargs -0 egrep --with-filename --line-number --only-matching <span class=\"string\">\"(<span class=\"variable\">$KEYWORDS</span>).*\\$\"</span> | perl -p <span class=\"_\">-e</span> <span class=\"string\">\"s/(<span class=\"variable\">$KEYWORDS</span>)/ warning: \\$1/\"</span></span><br></pre></td></tr></table></figure><br> 　<br>由于本人对脚本语言不熟悉，想要深入研究的朋友们可以从网上搜索教程。在添加了上面的支持后，你就可以在代码中通过使用自定义的标识符来快速查找代码。</p>\n<h1 id=\"代码注释\"><a href=\"#代码注释\" class=\"headerlink\" title=\"代码注释\"></a>代码注释</h1><p>上面的俩种可以算是编译器识别的命令，下面我们来说一下传统意义上的代码注释。不管在使用哪种语言，我们一般都会使用到代码注释，而不同的语言有不同的注释规范，例如一般的单行注释，我们会使用<code>“//”</code>，而多行注释则会使用<code>&quot;/*......*/&quot;</code>，而对于iOS开发者来说，代码注释也拥有属于它自己的一套规范。下面就是一些常用的iOS的代码注释，这些衍生的注释目的是方便文档生成：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">/// Single line comment.（单行文本）</span></span><br><span class=\"line\"><span class=\"comment\">/// Single line comment spreading （多行文本）</span></span><br><span class=\"line\">     <span class=\"comment\">/// over multiple lines.</span></span><br><span class=\"line\"><span class=\"comment\">/** Single line comment. */</span> （单行文本）</span><br><span class=\"line\"><span class=\"comment\">/** Single line comment spreading （多行文本）</span><br><span class=\"line\">       * over multiple lines.</span><br><span class=\"line\">       */</span></span><br><span class=\"line\"><span class=\"comment\">/** Single line comment spreading （多行文本）</span><br><span class=\"line\">       over multiple lines. No star.</span><br><span class=\"line\">       */</span></span><br><span class=\"line\"><span class=\"comment\">/*! Single line comment. */</span> （单行文本）</span><br><span class=\"line\"><span class=\"comment\">/*! Single line comment spreading （多行文本）</span><br><span class=\"line\">       over multiple lines.</span><br><span class=\"line\">       */</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"方法注释\"><a href=\"#方法注释\" class=\"headerlink\" title=\"方法注释\"></a>方法注释</h1><p>在iOS开发代码中有一种对方法的注释 ，其中包含了特有的指令：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\">  * @brief 带字符串参数的方法.（具体描述）</span><br><span class=\"line\">  * @param  value 值.（参数描述）</span><br><span class=\"line\">  * @return 返回value.（返回值描述）</span><br><span class=\"line\">  * @exception NSException 可能抛出的异常.（抛出异常描述）</span><br><span class=\"line\">  * @see someMethod （关联描述）</span><br><span class=\"line\">  * @warning 警告: appledoc中显示为蓝色背景, Doxygen中显示为红色竖条.（警告描述）</span><br><span class=\"line\">  * @bug 缺陷: appledoc中显示为黄色背景, Doxygen中显示为绿色竖条.（缺陷描述）</span><br><span class=\"line\">  */</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"生成开发文档\"><a href=\"#生成开发文档\" class=\"headerlink\" title=\"生成开发文档\"></a>生成开发文档</h1><p>说起上面的这种iOS开发中的代码注释，就不得不说一下iOS开发中的文档生成，一个良好的代码文档可以帮助其他开发者很好的了解代码结构和具体内容。而时下比较流行的几个文档生成工具有下面几种，关于iOS代码文档的具体生成，我推荐朋友们观看这篇 <a href=\"http://blog.devtang.com/blog/2012/02/01/use-appledoc-to-generate-xcode-doc/\" target=\"_blank\" rel=\"external\">唐巧的技术博客——-使用Objective-C的文档生成工具</a>。</p>\n<ol>\n<li>第三方工具<a href=\"http://www.stack.nl/~dimitri/doxygen/index.html\" target=\"_blank\" rel=\"external\">Doxygen</a></li>\n<li>Xcode自带的<a href=\"http://developer.apple.com/opensource/tools/headerdoc.html\" target=\"_blank\" rel=\"external\">HeaderDoc</a></li>\n<li>默认与苹果官方文档风格类似的<a href=\"http://gentlebytes.com/appledoc/\" target=\"_blank\" rel=\"external\">AppleDoc</a></li>\n</ol>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>新手在开始参与一个开发项目的时候，会把大部分的时间耗费在阅读项目的<code>需求文档</code>、<code>开发文档</code>和<code>代码</code>，一篇好的<code>需求文档</code>和<code>开发文档</code>会帮助新手很快的理解项目的目标和进度，而新手对于代码的阅读会先从代码的注释开始。拥有良好<code>注释</code>的代码可以省去团队其他的开发者好多时间，不至于让其他参与者去一行一行的阅读代码，去不断地加断点查看代码地跳转逻辑，接下来我们就谈谈iOS开发中使用的一些注释。<br>","more":"</p>\n<h1 id=\"pragma-mark\"><a href=\"#pragma-mark\" class=\"headerlink\" title=\"#pragma mark\"></a>#pragma mark</h1><p>确切地说，这是Xcode编译器特定得编译命令，它的作用就是在代码地编辑器中，将顶部的方法函数弹出菜单按层次分开，方便于我们的查找。一般的使用方法是在想要分层的第一个方法或函数上面加上<code>#pragma mark -</code>　和<code>#pragma　mark something</code>(你的分层定义)。此外其他常用到的，是在我们想要标识代码的地方加上<code>#warning</code>，这样运行时编译器会自动帮助我们将代码标识到<code>issue　navigator</code>。</p>\n<h1 id=\"自定义标示\"><a href=\"#自定义标示\" class=\"headerlink\" title=\"自定义标示\"></a>自定义标示</h1><p>使用自定义的特殊标识符，例如<code>//TODO:</code>或者是<code>//FIXME:</code>。使用这一类的特殊标识符，首先需要在<code>Xcode</code>中添加支持，在我们的<code>Target</code>中，选择<code>Build Phases</code>，Xcode 6将<code>Build Phases</code>从<code>Build Settings</code>分离了出来。在<code>Build Phases</code>选择<code>New Run Script Phase</code>，然后输入：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEYWORDS=<span class=\"string\">\"TODO:|FIXME:\"</span></span><br><span class=\"line\">find <span class=\"string\">\"<span class=\"variable\">$&#123;SRCROOT&#125;</span>\"</span>  −name<span class=\"string\">\"∗.h\"</span>−or−name<span class=\"string\">\"∗.\"</span>        -print0 | xargs -0 egrep --with-filename --line-number --only-matching <span class=\"string\">\"(<span class=\"variable\">$KEYWORDS</span>).*\\$\"</span> | perl -p <span class=\"_\">-e</span> <span class=\"string\">\"s/(<span class=\"variable\">$KEYWORDS</span>)/ warning: \\$1/\"</span></span><br></pre></td></tr></table></figure><br> 　<br>由于本人对脚本语言不熟悉，想要深入研究的朋友们可以从网上搜索教程。在添加了上面的支持后，你就可以在代码中通过使用自定义的标识符来快速查找代码。</p>\n<h1 id=\"代码注释\"><a href=\"#代码注释\" class=\"headerlink\" title=\"代码注释\"></a>代码注释</h1><p>上面的俩种可以算是编译器识别的命令，下面我们来说一下传统意义上的代码注释。不管在使用哪种语言，我们一般都会使用到代码注释，而不同的语言有不同的注释规范，例如一般的单行注释，我们会使用<code>“//”</code>，而多行注释则会使用<code>&quot;/*......*/&quot;</code>，而对于iOS开发者来说，代码注释也拥有属于它自己的一套规范。下面就是一些常用的iOS的代码注释，这些衍生的注释目的是方便文档生成：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">/// Single line comment.（单行文本）</span></span><br><span class=\"line\"><span class=\"comment\">/// Single line comment spreading （多行文本）</span></span><br><span class=\"line\">     <span class=\"comment\">/// over multiple lines.</span></span><br><span class=\"line\"><span class=\"comment\">/** Single line comment. */</span> （单行文本）</span><br><span class=\"line\"><span class=\"comment\">/** Single line comment spreading （多行文本）</span><br><span class=\"line\">       * over multiple lines.</span><br><span class=\"line\">       */</span></span><br><span class=\"line\"><span class=\"comment\">/** Single line comment spreading （多行文本）</span><br><span class=\"line\">       over multiple lines. No star.</span><br><span class=\"line\">       */</span></span><br><span class=\"line\"><span class=\"comment\">/*! Single line comment. */</span> （单行文本）</span><br><span class=\"line\"><span class=\"comment\">/*! Single line comment spreading （多行文本）</span><br><span class=\"line\">       over multiple lines.</span><br><span class=\"line\">       */</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"方法注释\"><a href=\"#方法注释\" class=\"headerlink\" title=\"方法注释\"></a>方法注释</h1><p>在iOS开发代码中有一种对方法的注释 ，其中包含了特有的指令：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\">  * @brief 带字符串参数的方法.（具体描述）</span><br><span class=\"line\">  * @param  value 值.（参数描述）</span><br><span class=\"line\">  * @return 返回value.（返回值描述）</span><br><span class=\"line\">  * @exception NSException 可能抛出的异常.（抛出异常描述）</span><br><span class=\"line\">  * @see someMethod （关联描述）</span><br><span class=\"line\">  * @warning 警告: appledoc中显示为蓝色背景, Doxygen中显示为红色竖条.（警告描述）</span><br><span class=\"line\">  * @bug 缺陷: appledoc中显示为黄色背景, Doxygen中显示为绿色竖条.（缺陷描述）</span><br><span class=\"line\">  */</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"生成开发文档\"><a href=\"#生成开发文档\" class=\"headerlink\" title=\"生成开发文档\"></a>生成开发文档</h1><p>说起上面的这种iOS开发中的代码注释，就不得不说一下iOS开发中的文档生成，一个良好的代码文档可以帮助其他开发者很好的了解代码结构和具体内容。而时下比较流行的几个文档生成工具有下面几种，关于iOS代码文档的具体生成，我推荐朋友们观看这篇 <a href=\"http://blog.devtang.com/blog/2012/02/01/use-appledoc-to-generate-xcode-doc/\">唐巧的技术博客——-使用Objective-C的文档生成工具</a>。</p>\n<ol>\n<li>第三方工具<a href=\"http://www.stack.nl/~dimitri/doxygen/index.html\">Doxygen</a></li>\n<li>Xcode自带的<a href=\"http://developer.apple.com/opensource/tools/headerdoc.html\">HeaderDoc</a></li>\n<li>默认与苹果官方文档风格类似的<a href=\"http://gentlebytes.com/appledoc/\">AppleDoc</a></li>\n</ol>"},{"layout":"post","title":"内存管理之属性参数与变量关键字","date":"2015-08-19T16:00:00.000Z","description":"解释iOS中MRC和ARC俩种不同内存管理机制下得修饰符","_content":"\n# 前言\n自从Apple官方SDK中，引入了`ARC`的概念后，在iOS开发时的内容管理变得不在是难题，原来的手动管理内容的工作全部交由编译器来做。\n\nARC（Atomic Reference Count），简述就是自动引入计数，而我们这篇文章主要叙述的也是`Objective-C`语言中，影响“引用计数”的属性参数和变量关键字。\n<!-- more -->\n# 初始化实例\n在没有引入ARC时，使用`@property`关键字来生成属性的`getters`与`setters`方法，有几个可选的参数：`assign`（默认），`retain` ，`copy`。这几个参数主要影响的也是生成属性的setters方法。举例Person类有个属性为NSString类型的card,示例代码：\n{% codeblock lang:objc %}\n1）Person person = [[Person alloc] init];\n2）NSString *cardText = @\"number\";//@\"number\"堆内存地址：0X668901，引用计数为1,cardText指针地址：0X102221;\n3）person.card = cardText;\n{% endcodeblock %}\n\n# assign\n{% codeblock lang:objc %}\n@property (nonatomic, assign) NSString *card;\n{% endcodeblock %}\nassign参数，对于第三行的属性赋值来说就是简单赋值，不会更改\"number\"堆内存的引用计数，而且person.card指针的地址和cardText指针地址也是相同的。总结来说，就是一个简单地指针赋值。所以person.card的指针地址也是0X102221,指向的内存地址也是0X668901,而内存地址的引用计数仍然为1。\n\n# retain\n{% codeblock lang:objc %}\n@property (nonatomic, retain) NSString *card;\n{% endcodeblock %}\nretain参数，对于第三行的属性赋值来说，就要释放掉person.card以前的内存值，而将开辟新的指针地址，来指向\"number\" 。所以person.card的指针地址将会变成新的地址，而指向的内容地址就是0X668901，而\"number\"堆内存的引用计数为2。\n\n# Copy\n{% codeblock lang:objc %}\n@property (nonatomic, copy) NSString *card;\n{% endcodeblock %}\n顾名思义，copy参数，就是释放掉旧值，然后新建一块内存。对于第三行的赋值来说就是将\"number\"拷贝过去，所以person.card的指针地址将会变成新的地址，而person.card指向的堆内存地址也会变成新的地址，而\"number\"堆内存的引用计数仍然为1。这里额外说明一点，copy参数对于NSString类型的变量会拷贝堆内存的内容，而对于NSArray,NSDictionary等数据类型的变量时，拷贝的也是指针，就是我们所谓的“浅复制”。\n\n# ARC(weak、strong)\n在Apple官方SDK引入ARC以后，我们就需要在ARC项目中，使用`weak`和`strong`参数来代替之前的参数，`weak`就相当于之前的`assign`，不同的是当weak类型的指针不使用一块堆内存时，weak类型的指针会置为nil，而较于之前使用assign的好处，就在于使用assign声明的指针不使用一块堆内存时，无法知道其他人是否还会使用，所以内存无法随着指针一起自动释放掉。`strong`就相当于`retain`，而默认的参数就是`strong`，比如第二行的声明，cardText指针的类型也是strong类型。强引用和弱引用的区别就在于当一块堆内存没有任何强指针指向时，就会释放掉内存，并且清除掉所有的弱指针。在iOS开发中，唯一一种使用weak声明指针的情况，就是要避免“retain cycle”，也就是一个父类retain一个子类，而一个子类又retain了父类，造成内存无法释放。\n\n# block关键字\n除了使用@property关键字声明属性时的几个参数可以影响内存管理之外，Objective-C语言也提供了一些关键字，来帮助我们管理一些局部变量：\n\n1. __strong 是缺省的关键词。\n2. __weak 声明了一个可以自动 nil 化的弱引用。\n3. __unsafe_unretained 声明一个弱应用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了。\n4. __autoreleasing 用来修饰一个函数的参数，这个参数会在函数返回的时候被自动释放。","source":"_posts/内存管理之属性参数与变量关键字.md","raw":"---\nlayout: post\ntitle: 内存管理之属性参数与变量关键字\ndate: 2015-08-20\ndescription: \"解释iOS中MRC和ARC俩种不同内存管理机制下得修饰符\"\ntags: [内存管理]\ncategories: [Objective-C]\n---\n\n# 前言\n自从Apple官方SDK中，引入了`ARC`的概念后，在iOS开发时的内容管理变得不在是难题，原来的手动管理内容的工作全部交由编译器来做。\n\nARC（Atomic Reference Count），简述就是自动引入计数，而我们这篇文章主要叙述的也是`Objective-C`语言中，影响“引用计数”的属性参数和变量关键字。\n<!-- more -->\n# 初始化实例\n在没有引入ARC时，使用`@property`关键字来生成属性的`getters`与`setters`方法，有几个可选的参数：`assign`（默认），`retain` ，`copy`。这几个参数主要影响的也是生成属性的setters方法。举例Person类有个属性为NSString类型的card,示例代码：\n{% codeblock lang:objc %}\n1）Person person = [[Person alloc] init];\n2）NSString *cardText = @\"number\";//@\"number\"堆内存地址：0X668901，引用计数为1,cardText指针地址：0X102221;\n3）person.card = cardText;\n{% endcodeblock %}\n\n# assign\n{% codeblock lang:objc %}\n@property (nonatomic, assign) NSString *card;\n{% endcodeblock %}\nassign参数，对于第三行的属性赋值来说就是简单赋值，不会更改\"number\"堆内存的引用计数，而且person.card指针的地址和cardText指针地址也是相同的。总结来说，就是一个简单地指针赋值。所以person.card的指针地址也是0X102221,指向的内存地址也是0X668901,而内存地址的引用计数仍然为1。\n\n# retain\n{% codeblock lang:objc %}\n@property (nonatomic, retain) NSString *card;\n{% endcodeblock %}\nretain参数，对于第三行的属性赋值来说，就要释放掉person.card以前的内存值，而将开辟新的指针地址，来指向\"number\" 。所以person.card的指针地址将会变成新的地址，而指向的内容地址就是0X668901，而\"number\"堆内存的引用计数为2。\n\n# Copy\n{% codeblock lang:objc %}\n@property (nonatomic, copy) NSString *card;\n{% endcodeblock %}\n顾名思义，copy参数，就是释放掉旧值，然后新建一块内存。对于第三行的赋值来说就是将\"number\"拷贝过去，所以person.card的指针地址将会变成新的地址，而person.card指向的堆内存地址也会变成新的地址，而\"number\"堆内存的引用计数仍然为1。这里额外说明一点，copy参数对于NSString类型的变量会拷贝堆内存的内容，而对于NSArray,NSDictionary等数据类型的变量时，拷贝的也是指针，就是我们所谓的“浅复制”。\n\n# ARC(weak、strong)\n在Apple官方SDK引入ARC以后，我们就需要在ARC项目中，使用`weak`和`strong`参数来代替之前的参数，`weak`就相当于之前的`assign`，不同的是当weak类型的指针不使用一块堆内存时，weak类型的指针会置为nil，而较于之前使用assign的好处，就在于使用assign声明的指针不使用一块堆内存时，无法知道其他人是否还会使用，所以内存无法随着指针一起自动释放掉。`strong`就相当于`retain`，而默认的参数就是`strong`，比如第二行的声明，cardText指针的类型也是strong类型。强引用和弱引用的区别就在于当一块堆内存没有任何强指针指向时，就会释放掉内存，并且清除掉所有的弱指针。在iOS开发中，唯一一种使用weak声明指针的情况，就是要避免“retain cycle”，也就是一个父类retain一个子类，而一个子类又retain了父类，造成内存无法释放。\n\n# block关键字\n除了使用@property关键字声明属性时的几个参数可以影响内存管理之外，Objective-C语言也提供了一些关键字，来帮助我们管理一些局部变量：\n\n1. __strong 是缺省的关键词。\n2. __weak 声明了一个可以自动 nil 化的弱引用。\n3. __unsafe_unretained 声明一个弱应用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了。\n4. __autoreleasing 用来修饰一个函数的参数，这个参数会在函数返回的时候被自动释放。","slug":"内存管理之属性参数与变量关键字","published":1,"updated":"2016-04-12T06:48:52.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9ud001s94suebr38nie","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>自从Apple官方SDK中，引入了<code>ARC</code>的概念后，在iOS开发时的内容管理变得不在是难题，原来的手动管理内容的工作全部交由编译器来做。</p>\n<p>ARC（Atomic Reference Count），简述就是自动引入计数，而我们这篇文章主要叙述的也是<code>Objective-C</code>语言中，影响“引用计数”的属性参数和变量关键字。<br><a id=\"more\"></a></p>\n<h1 id=\"初始化实例\"><a href=\"#初始化实例\" class=\"headerlink\" title=\"初始化实例\"></a>初始化实例</h1><p>在没有引入ARC时，使用<code>@property</code>关键字来生成属性的<code>getters</code>与<code>setters</code>方法，有几个可选的参数：<code>assign</code>（默认），<code>retain</code> ，<code>copy</code>。这几个参数主要影响的也是生成属性的setters方法。举例Person类有个属性为NSString类型的card,示例代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>）Person person = [[Person alloc] init];</span><br><span class=\"line\"><span class=\"number\">2</span>）<span class=\"built_in\">NSString</span> *cardText = <span class=\"string\">@\"number\"</span>;<span class=\"comment\">//@\"number\"堆内存地址：0X668901，引用计数为1,cardText指针地址：0X102221;</span></span><br><span class=\"line\"><span class=\"number\">3</span>）person.card = cardText;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"assign\"><a href=\"#assign\" class=\"headerlink\" title=\"assign\"></a>assign</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSString</span> *card;</span><br></pre></td></tr></table></figure>\n<p>assign参数，对于第三行的属性赋值来说就是简单赋值，不会更改”number”堆内存的引用计数，而且person.card指针的地址和cardText指针地址也是相同的。总结来说，就是一个简单地指针赋值。所以person.card的指针地址也是0X102221,指向的内存地址也是0X668901,而内存地址的引用计数仍然为1。</p>\n<h1 id=\"retain\"><a href=\"#retain\" class=\"headerlink\" title=\"retain\"></a>retain</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, retain) <span class=\"built_in\">NSString</span> *card;</span><br></pre></td></tr></table></figure>\n<p>retain参数，对于第三行的属性赋值来说，就要释放掉person.card以前的内存值，而将开辟新的指针地址，来指向”number” 。所以person.card的指针地址将会变成新的地址，而指向的内容地址就是0X668901，而”number”堆内存的引用计数为2。</p>\n<h1 id=\"Copy\"><a href=\"#Copy\" class=\"headerlink\" title=\"Copy\"></a>Copy</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *card;</span><br></pre></td></tr></table></figure>\n<p>顾名思义，copy参数，就是释放掉旧值，然后新建一块内存。对于第三行的赋值来说就是将”number”拷贝过去，所以person.card的指针地址将会变成新的地址，而person.card指向的堆内存地址也会变成新的地址，而”number”堆内存的引用计数仍然为1。这里额外说明一点，copy参数对于NSString类型的变量会拷贝堆内存的内容，而对于NSArray,NSDictionary等数据类型的变量时，拷贝的也是指针，就是我们所谓的“浅复制”。</p>\n<h1 id=\"ARC-weak、strong\"><a href=\"#ARC-weak、strong\" class=\"headerlink\" title=\"ARC(weak、strong)\"></a>ARC(weak、strong)</h1><p>在Apple官方SDK引入ARC以后，我们就需要在ARC项目中，使用<code>weak</code>和<code>strong</code>参数来代替之前的参数，<code>weak</code>就相当于之前的<code>assign</code>，不同的是当weak类型的指针不使用一块堆内存时，weak类型的指针会置为nil，而较于之前使用assign的好处，就在于使用assign声明的指针不使用一块堆内存时，无法知道其他人是否还会使用，所以内存无法随着指针一起自动释放掉。<code>strong</code>就相当于<code>retain</code>，而默认的参数就是<code>strong</code>，比如第二行的声明，cardText指针的类型也是strong类型。强引用和弱引用的区别就在于当一块堆内存没有任何强指针指向时，就会释放掉内存，并且清除掉所有的弱指针。在iOS开发中，唯一一种使用weak声明指针的情况，就是要避免“retain cycle”，也就是一个父类retain一个子类，而一个子类又retain了父类，造成内存无法释放。</p>\n<h1 id=\"block关键字\"><a href=\"#block关键字\" class=\"headerlink\" title=\"block关键字\"></a>block关键字</h1><p>除了使用@property关键字声明属性时的几个参数可以影响内存管理之外，Objective-C语言也提供了一些关键字，来帮助我们管理一些局部变量：</p>\n<ol>\n<li>__strong 是缺省的关键词。</li>\n<li>__weak 声明了一个可以自动 nil 化的弱引用。</li>\n<li>__unsafe_unretained 声明一个弱应用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了。</li>\n<li>__autoreleasing 用来修饰一个函数的参数，这个参数会在函数返回的时候被自动释放。</li>\n</ol>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>自从Apple官方SDK中，引入了<code>ARC</code>的概念后，在iOS开发时的内容管理变得不在是难题，原来的手动管理内容的工作全部交由编译器来做。</p>\n<p>ARC（Atomic Reference Count），简述就是自动引入计数，而我们这篇文章主要叙述的也是<code>Objective-C</code>语言中，影响“引用计数”的属性参数和变量关键字。<br>","more":"</p>\n<h1 id=\"初始化实例\"><a href=\"#初始化实例\" class=\"headerlink\" title=\"初始化实例\"></a>初始化实例</h1><p>在没有引入ARC时，使用<code>@property</code>关键字来生成属性的<code>getters</code>与<code>setters</code>方法，有几个可选的参数：<code>assign</code>（默认），<code>retain</code> ，<code>copy</code>。这几个参数主要影响的也是生成属性的setters方法。举例Person类有个属性为NSString类型的card,示例代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>）Person person = [[Person alloc] init];</span><br><span class=\"line\"><span class=\"number\">2</span>）<span class=\"built_in\">NSString</span> *cardText = <span class=\"string\">@\"number\"</span>;<span class=\"comment\">//@\"number\"堆内存地址：0X668901，引用计数为1,cardText指针地址：0X102221;</span></span><br><span class=\"line\"><span class=\"number\">3</span>）person.card = cardText;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"assign\"><a href=\"#assign\" class=\"headerlink\" title=\"assign\"></a>assign</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSString</span> *card;</span><br></pre></td></tr></table></figure>\n<p>assign参数，对于第三行的属性赋值来说就是简单赋值，不会更改”number”堆内存的引用计数，而且person.card指针的地址和cardText指针地址也是相同的。总结来说，就是一个简单地指针赋值。所以person.card的指针地址也是0X102221,指向的内存地址也是0X668901,而内存地址的引用计数仍然为1。</p>\n<h1 id=\"retain\"><a href=\"#retain\" class=\"headerlink\" title=\"retain\"></a>retain</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, retain) <span class=\"built_in\">NSString</span> *card;</span><br></pre></td></tr></table></figure>\n<p>retain参数，对于第三行的属性赋值来说，就要释放掉person.card以前的内存值，而将开辟新的指针地址，来指向”number” 。所以person.card的指针地址将会变成新的地址，而指向的内容地址就是0X668901，而”number”堆内存的引用计数为2。</p>\n<h1 id=\"Copy\"><a href=\"#Copy\" class=\"headerlink\" title=\"Copy\"></a>Copy</h1><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *card;</span><br></pre></td></tr></table></figure>\n<p>顾名思义，copy参数，就是释放掉旧值，然后新建一块内存。对于第三行的赋值来说就是将”number”拷贝过去，所以person.card的指针地址将会变成新的地址，而person.card指向的堆内存地址也会变成新的地址，而”number”堆内存的引用计数仍然为1。这里额外说明一点，copy参数对于NSString类型的变量会拷贝堆内存的内容，而对于NSArray,NSDictionary等数据类型的变量时，拷贝的也是指针，就是我们所谓的“浅复制”。</p>\n<h1 id=\"ARC-weak、strong\"><a href=\"#ARC-weak、strong\" class=\"headerlink\" title=\"ARC(weak、strong)\"></a>ARC(weak、strong)</h1><p>在Apple官方SDK引入ARC以后，我们就需要在ARC项目中，使用<code>weak</code>和<code>strong</code>参数来代替之前的参数，<code>weak</code>就相当于之前的<code>assign</code>，不同的是当weak类型的指针不使用一块堆内存时，weak类型的指针会置为nil，而较于之前使用assign的好处，就在于使用assign声明的指针不使用一块堆内存时，无法知道其他人是否还会使用，所以内存无法随着指针一起自动释放掉。<code>strong</code>就相当于<code>retain</code>，而默认的参数就是<code>strong</code>，比如第二行的声明，cardText指针的类型也是strong类型。强引用和弱引用的区别就在于当一块堆内存没有任何强指针指向时，就会释放掉内存，并且清除掉所有的弱指针。在iOS开发中，唯一一种使用weak声明指针的情况，就是要避免“retain cycle”，也就是一个父类retain一个子类，而一个子类又retain了父类，造成内存无法释放。</p>\n<h1 id=\"block关键字\"><a href=\"#block关键字\" class=\"headerlink\" title=\"block关键字\"></a>block关键字</h1><p>除了使用@property关键字声明属性时的几个参数可以影响内存管理之外，Objective-C语言也提供了一些关键字，来帮助我们管理一些局部变量：</p>\n<ol>\n<li>__strong 是缺省的关键词。</li>\n<li>__weak 声明了一个可以自动 nil 化的弱引用。</li>\n<li>__unsafe_unretained 声明一个弱应用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了。</li>\n<li>__autoreleasing 用来修饰一个函数的参数，这个参数会在函数返回的时候被自动释放。</li>\n</ol>"},{"layout":"post","title":"扒一扒TestFlight的那些事","date":"2015-07-07T16:00:00.000Z","_content":"\n# 前言　　\n近几天一直在做`APNS（Apple Push Notification Service）`消息推送。在使用`TestFlight`做不同证书测试的时候，添加我的账号邀请，一直收不到邀请邮件，于是深入了一下对`TestFlight`的研究。关于`TestFlight`的使用操作流程，我首先推荐朋友们看一篇我在CocoaChina上看到的一篇博客:[TestFlight被收购了，那我们怎么使用呢？](http://www.cocoachina.com/ios/20141229/10724.html)，希望正打算研究`TestFlight`操作的朋友们可以从中得到帮助。\n<!-- more -->\n# TestFlight\n苹果在二月份收购了`TestFlight`的母公司`Burstly`，几个月之后在WWDC 2014上就宣布将`TestFlight`集成在`iOS8`的开发组件中。这次收购最明显的影响是——TestFlight终止了对Android的支持。同时中止了`TestFlight` iOS SDK的支持，除非你在之前已经是`TestFlight`的用户。目前，`TestFlight`已经和一些新特性集成进了`iTunes Connect`。而且，`TestFlight不仅支持内部人员的测试，也提供给外部人员测试的支持，预计也将会提供预览崩溃报告的功能，这些特性会给项目团队开发测试提供极大的便利。","source":"_posts/扒一扒TestFlight的那些事.md","raw":"---\nlayout: post\ntitle: 扒一扒TestFlight的那些事\ndate: 2015-07-08\ntags: [TestFlight]\ncategories: [开发心得]\n---\n\n# 前言　　\n近几天一直在做`APNS（Apple Push Notification Service）`消息推送。在使用`TestFlight`做不同证书测试的时候，添加我的账号邀请，一直收不到邀请邮件，于是深入了一下对`TestFlight`的研究。关于`TestFlight`的使用操作流程，我首先推荐朋友们看一篇我在CocoaChina上看到的一篇博客:[TestFlight被收购了，那我们怎么使用呢？](http://www.cocoachina.com/ios/20141229/10724.html)，希望正打算研究`TestFlight`操作的朋友们可以从中得到帮助。\n<!-- more -->\n# TestFlight\n苹果在二月份收购了`TestFlight`的母公司`Burstly`，几个月之后在WWDC 2014上就宣布将`TestFlight`集成在`iOS8`的开发组件中。这次收购最明显的影响是——TestFlight终止了对Android的支持。同时中止了`TestFlight` iOS SDK的支持，除非你在之前已经是`TestFlight`的用户。目前，`TestFlight`已经和一些新特性集成进了`iTunes Connect`。而且，`TestFlight不仅支持内部人员的测试，也提供给外部人员测试的支持，预计也将会提供预览崩溃报告的功能，这些特性会给项目团队开发测试提供极大的便利。","slug":"扒一扒TestFlight的那些事","published":1,"updated":"2016-04-12T06:43:01.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9ui001v94suby4bz21l","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>近几天一直在做<code>APNS（Apple Push Notification Service）</code>消息推送。在使用<code>TestFlight</code>做不同证书测试的时候，添加我的账号邀请，一直收不到邀请邮件，于是深入了一下对<code>TestFlight</code>的研究。关于<code>TestFlight</code>的使用操作流程，我首先推荐朋友们看一篇我在CocoaChina上看到的一篇博客:<a href=\"http://www.cocoachina.com/ios/20141229/10724.html\" target=\"_blank\" rel=\"external\">TestFlight被收购了，那我们怎么使用呢？</a>，希望正打算研究<code>TestFlight</code>操作的朋友们可以从中得到帮助。<br><a id=\"more\"></a></p>\n<h1 id=\"TestFlight\"><a href=\"#TestFlight\" class=\"headerlink\" title=\"TestFlight\"></a>TestFlight</h1><p>苹果在二月份收购了<code>TestFlight</code>的母公司<code>Burstly</code>，几个月之后在WWDC 2014上就宣布将<code>TestFlight</code>集成在<code>iOS8</code>的开发组件中。这次收购最明显的影响是——TestFlight终止了对Android的支持。同时中止了<code>TestFlight</code> iOS SDK的支持，除非你在之前已经是<code>TestFlight</code>的用户。目前，<code>TestFlight</code>已经和一些新特性集成进了<code>iTunes Connect</code>。而且，`TestFlight不仅支持内部人员的测试，也提供给外部人员测试的支持，预计也将会提供预览崩溃报告的功能，这些特性会给项目团队开发测试提供极大的便利。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>近几天一直在做<code>APNS（Apple Push Notification Service）</code>消息推送。在使用<code>TestFlight</code>做不同证书测试的时候，添加我的账号邀请，一直收不到邀请邮件，于是深入了一下对<code>TestFlight</code>的研究。关于<code>TestFlight</code>的使用操作流程，我首先推荐朋友们看一篇我在CocoaChina上看到的一篇博客:<a href=\"http://www.cocoachina.com/ios/20141229/10724.html\">TestFlight被收购了，那我们怎么使用呢？</a>，希望正打算研究<code>TestFlight</code>操作的朋友们可以从中得到帮助。<br>","more":"</p>\n<h1 id=\"TestFlight\"><a href=\"#TestFlight\" class=\"headerlink\" title=\"TestFlight\"></a>TestFlight</h1><p>苹果在二月份收购了<code>TestFlight</code>的母公司<code>Burstly</code>，几个月之后在WWDC 2014上就宣布将<code>TestFlight</code>集成在<code>iOS8</code>的开发组件中。这次收购最明显的影响是——TestFlight终止了对Android的支持。同时中止了<code>TestFlight</code> iOS SDK的支持，除非你在之前已经是<code>TestFlight</code>的用户。目前，<code>TestFlight</code>已经和一些新特性集成进了<code>iTunes Connect</code>。而且，`TestFlight不仅支持内部人员的测试，也提供给外部人员测试的支持，预计也将会提供预览崩溃报告的功能，这些特性会给项目团队开发测试提供极大的便利。</p>"},{"layout":"post","title":"末班车上一个程序猿的年度总结","date":"2015-12-30T16:00:00.000Z","description":"个人年度总结","_content":"\n2015年，一个完全陌生的年份，一个从学生过渡到职场新人的年份，一个不一样的年份！\n\n# 2014-12-31 23:50\n我正埋头敲击着键盘，电脑屏幕上密密麻麻得堆砌着代码。叮的一声，我被打断了自认为`perfect`的思路，微信上有好友发来了消息，“胖子，跨年夜，出来High!”。是的，每个群体中都有一个叫“胖子”的活宝，然而我对这个外号已经从最初的抵触变成现在的默认啦。只是让我内心产生一丝波澜的，并不是这个外号，而是\"跨年夜\"这看似弱小，实则振聋发聩的三个汉字。是呀，马上就是2015年啦！！\n\n时光荏苒，一眨眼，我已经在企业实习了俩个月啦，同时也代表了我在北京真真正正得漂了俩个月啦! 刚入职时对什么都是懵懵懂懂，现在已经进化到做什么都是半梦半醒啦。是的，在我看来，这是非常不小的进步啦！然而，那个时候，并不知道`年度总结`是在搞个什么飞机！为了犒劳自己，我果断的合上屏幕，然后对自己说，是时候出去发泄一下啦！\n<!-- more -->\n# 2015-01-04 10:00\n元旦假期，和朋友们玩的非常High,以至于已经过去一个小时了，还没有进入工作状态。漫不经心的在博客和论坛上逛着，发现大家都在讨论，这三天又发掘和实现了哪些酷炫的动画效果，又开源了哪些好用的工具。再回首，自己喝醉了俩次，嗨歌搞得嗓子火辣辣的疼。前俩天还感觉并不是很疼，可是这会儿，却感觉一直疼到了心尖上！！喝口温水，收拾了一下心情，开始埋头到工作中!\n\n# 2015-06-20 14:00\n火车飞速的在轨道上前进着，俩旁的建筑也在应和着，欢快的奔跑！一路上，我都在回首着在北京工作和生活中的每一个细节。有过抱怨，有过朦胧，有过欢喜! 我最大的感受就是，我又成长了！是的，人无时无刻不在成长！随着火车的渐停，\"石家庄火车站\"这几个字标逐渐映入我的眼帘，久悬不下的心，如飞石落地一般，激起了持久的震颤! 在北京漂泊了八个月，我第一次踏上了故乡的土地。看着迎面走来的小伙伴满脸的笑容，我平复了内心的涟漪，展开了双手，飞步的走上前去，给了他一个深深地拥抱！是的，我太想念这片土地，太想念这片土地上的伙伴们啦!\n\n# 2015-06-28 18:00\n看着远处逐渐黯淡的阳光和驰车远去的伙伴，我忍不住落下了少有的泪水。我即将踏上北上的火车，离开这片养育了我四年的故土！在学校的最后这段日子每天都是忙碌的，只有很少的机会可以和曾经一个课堂听课，一个球场飞驰的伙伴们叙叙旧。办毕业手续，拍毕业照，吃散伙饭，看散伙电影。然而心里每天想的却是我们永远不会散伙，只要一个电话，我会马上飞奔过去，和你深深相拥！\n\n# 2015-07-01 9:00\n如期的再次来到实习单位，看到前台那个警醒的Logo,才感觉到原来它的设计是如此的独特，如此的充满魅力。我独自走到会议室里，等着HR送来需要签字的劳动合同。是的，我就要签订俗称的卖身契啦！一挥笔，几个眉飞色舞的大字跃然纸上，我一刻不停地走到工位，放下背包，拿出所有可用的装备，心里却是可怕的平静！\n\n# 2015-12-31 20:30\n我正埋头敲击着键盘，电脑屏幕上密密麻麻堆砌着的，却不是代码。简书的编辑器全屏展现着，是的，今年我创建了博客网站，学会了Markdown，学会了使用简书发一些文章。大脑飞速转动的同时，手指也在不停地敲击着，思路和逻辑已经在回来的路上组织好了，然而此刻想起来和敲下去，却也是那么的不易。搭车回来的路上，朋友说笑，“这是你今年最后一次坐车啦哟，给个红包当油费呗”。说笑着的同时，心里也盘算着，真的已经北漂一年多了！之前看了几篇前辈们发在简书上的工作总结，多少有些感触。在路上回首这一年中的一些情景，仿佛依然历历在目。到家之后卸下包，打开电脑，开始了这篇文章的编写。\n\n# 总结\n这篇文章给人的第一感觉是在写小说，而我就是小说中的主人公。我只能说，真的可以这么认为，因为我也是这么想的。在结束了长达十六年的学生生涯之后，我仿佛来到了另一个完全不同的世界。在这里，每一天依然需要按时上课(工作)，按时交作业(交付物)。不同的是，你每天的老师都不一样，你每天学习的课堂也不一样。在这里，到处都是可以汲取的知识，到处都是新奇的技术，到处都充满着未知的挑战。对于拥有极端求知欲的我，在这里就仿佛是到了期盼已久的天堂。可能这只是另外一种对无聊乏味得生活的自我安慰。\n\n2015年，已经渐入尾声。2015年是我一生中一个重要的转折点，是我迈入`社会大学`的一个见证，这是一所求知者不用考试就可以进入的学校。有人说这是一所充满竞争，充满压迫的学校，也有人说这是一所充满希望的学校！\n其实在我看来，这是一所到处存在爱与恨的学校，我自信将会在这所学校快乐的度过每一个日夜！\n\n一篇大学生的无聊回忆，一篇职场新人的发奋自白，用以慰藉心灵，无所谓批判与吹捧。\n\n# 2016年，且行且努力！","source":"_posts/末班车上一个程序猿的年度总结.md","raw":"---\nlayout: post\ntitle: 末班车上一个程序猿的年度总结\ndate: 2015-12-31\ndescription: \"个人年度总结\"\ntags: [年度总结]\ncategories: [开发心得]\n---\n\n2015年，一个完全陌生的年份，一个从学生过渡到职场新人的年份，一个不一样的年份！\n\n# 2014-12-31 23:50\n我正埋头敲击着键盘，电脑屏幕上密密麻麻得堆砌着代码。叮的一声，我被打断了自认为`perfect`的思路，微信上有好友发来了消息，“胖子，跨年夜，出来High!”。是的，每个群体中都有一个叫“胖子”的活宝，然而我对这个外号已经从最初的抵触变成现在的默认啦。只是让我内心产生一丝波澜的，并不是这个外号，而是\"跨年夜\"这看似弱小，实则振聋发聩的三个汉字。是呀，马上就是2015年啦！！\n\n时光荏苒，一眨眼，我已经在企业实习了俩个月啦，同时也代表了我在北京真真正正得漂了俩个月啦! 刚入职时对什么都是懵懵懂懂，现在已经进化到做什么都是半梦半醒啦。是的，在我看来，这是非常不小的进步啦！然而，那个时候，并不知道`年度总结`是在搞个什么飞机！为了犒劳自己，我果断的合上屏幕，然后对自己说，是时候出去发泄一下啦！\n<!-- more -->\n# 2015-01-04 10:00\n元旦假期，和朋友们玩的非常High,以至于已经过去一个小时了，还没有进入工作状态。漫不经心的在博客和论坛上逛着，发现大家都在讨论，这三天又发掘和实现了哪些酷炫的动画效果，又开源了哪些好用的工具。再回首，自己喝醉了俩次，嗨歌搞得嗓子火辣辣的疼。前俩天还感觉并不是很疼，可是这会儿，却感觉一直疼到了心尖上！！喝口温水，收拾了一下心情，开始埋头到工作中!\n\n# 2015-06-20 14:00\n火车飞速的在轨道上前进着，俩旁的建筑也在应和着，欢快的奔跑！一路上，我都在回首着在北京工作和生活中的每一个细节。有过抱怨，有过朦胧，有过欢喜! 我最大的感受就是，我又成长了！是的，人无时无刻不在成长！随着火车的渐停，\"石家庄火车站\"这几个字标逐渐映入我的眼帘，久悬不下的心，如飞石落地一般，激起了持久的震颤! 在北京漂泊了八个月，我第一次踏上了故乡的土地。看着迎面走来的小伙伴满脸的笑容，我平复了内心的涟漪，展开了双手，飞步的走上前去，给了他一个深深地拥抱！是的，我太想念这片土地，太想念这片土地上的伙伴们啦!\n\n# 2015-06-28 18:00\n看着远处逐渐黯淡的阳光和驰车远去的伙伴，我忍不住落下了少有的泪水。我即将踏上北上的火车，离开这片养育了我四年的故土！在学校的最后这段日子每天都是忙碌的，只有很少的机会可以和曾经一个课堂听课，一个球场飞驰的伙伴们叙叙旧。办毕业手续，拍毕业照，吃散伙饭，看散伙电影。然而心里每天想的却是我们永远不会散伙，只要一个电话，我会马上飞奔过去，和你深深相拥！\n\n# 2015-07-01 9:00\n如期的再次来到实习单位，看到前台那个警醒的Logo,才感觉到原来它的设计是如此的独特，如此的充满魅力。我独自走到会议室里，等着HR送来需要签字的劳动合同。是的，我就要签订俗称的卖身契啦！一挥笔，几个眉飞色舞的大字跃然纸上，我一刻不停地走到工位，放下背包，拿出所有可用的装备，心里却是可怕的平静！\n\n# 2015-12-31 20:30\n我正埋头敲击着键盘，电脑屏幕上密密麻麻堆砌着的，却不是代码。简书的编辑器全屏展现着，是的，今年我创建了博客网站，学会了Markdown，学会了使用简书发一些文章。大脑飞速转动的同时，手指也在不停地敲击着，思路和逻辑已经在回来的路上组织好了，然而此刻想起来和敲下去，却也是那么的不易。搭车回来的路上，朋友说笑，“这是你今年最后一次坐车啦哟，给个红包当油费呗”。说笑着的同时，心里也盘算着，真的已经北漂一年多了！之前看了几篇前辈们发在简书上的工作总结，多少有些感触。在路上回首这一年中的一些情景，仿佛依然历历在目。到家之后卸下包，打开电脑，开始了这篇文章的编写。\n\n# 总结\n这篇文章给人的第一感觉是在写小说，而我就是小说中的主人公。我只能说，真的可以这么认为，因为我也是这么想的。在结束了长达十六年的学生生涯之后，我仿佛来到了另一个完全不同的世界。在这里，每一天依然需要按时上课(工作)，按时交作业(交付物)。不同的是，你每天的老师都不一样，你每天学习的课堂也不一样。在这里，到处都是可以汲取的知识，到处都是新奇的技术，到处都充满着未知的挑战。对于拥有极端求知欲的我，在这里就仿佛是到了期盼已久的天堂。可能这只是另外一种对无聊乏味得生活的自我安慰。\n\n2015年，已经渐入尾声。2015年是我一生中一个重要的转折点，是我迈入`社会大学`的一个见证，这是一所求知者不用考试就可以进入的学校。有人说这是一所充满竞争，充满压迫的学校，也有人说这是一所充满希望的学校！\n其实在我看来，这是一所到处存在爱与恨的学校，我自信将会在这所学校快乐的度过每一个日夜！\n\n一篇大学生的无聊回忆，一篇职场新人的发奋自白，用以慰藉心灵，无所谓批判与吹捧。\n\n# 2016年，且行且努力！","slug":"末班车上一个程序猿的年度总结","published":1,"updated":"2016-04-12T06:53:16.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9un002094su8scct0kh","content":"<p>2015年，一个完全陌生的年份，一个从学生过渡到职场新人的年份，一个不一样的年份！</p>\n<h1 id=\"2014-12-31-23-50\"><a href=\"#2014-12-31-23-50\" class=\"headerlink\" title=\"2014-12-31 23:50\"></a>2014-12-31 23:50</h1><p>我正埋头敲击着键盘，电脑屏幕上密密麻麻得堆砌着代码。叮的一声，我被打断了自认为<code>perfect</code>的思路，微信上有好友发来了消息，“胖子，跨年夜，出来High!”。是的，每个群体中都有一个叫“胖子”的活宝，然而我对这个外号已经从最初的抵触变成现在的默认啦。只是让我内心产生一丝波澜的，并不是这个外号，而是”跨年夜”这看似弱小，实则振聋发聩的三个汉字。是呀，马上就是2015年啦！！</p>\n<p>时光荏苒，一眨眼，我已经在企业实习了俩个月啦，同时也代表了我在北京真真正正得漂了俩个月啦! 刚入职时对什么都是懵懵懂懂，现在已经进化到做什么都是半梦半醒啦。是的，在我看来，这是非常不小的进步啦！然而，那个时候，并不知道<code>年度总结</code>是在搞个什么飞机！为了犒劳自己，我果断的合上屏幕，然后对自己说，是时候出去发泄一下啦！<br><a id=\"more\"></a></p>\n<h1 id=\"2015-01-04-10-00\"><a href=\"#2015-01-04-10-00\" class=\"headerlink\" title=\"2015-01-04 10:00\"></a>2015-01-04 10:00</h1><p>元旦假期，和朋友们玩的非常High,以至于已经过去一个小时了，还没有进入工作状态。漫不经心的在博客和论坛上逛着，发现大家都在讨论，这三天又发掘和实现了哪些酷炫的动画效果，又开源了哪些好用的工具。再回首，自己喝醉了俩次，嗨歌搞得嗓子火辣辣的疼。前俩天还感觉并不是很疼，可是这会儿，却感觉一直疼到了心尖上！！喝口温水，收拾了一下心情，开始埋头到工作中!</p>\n<h1 id=\"2015-06-20-14-00\"><a href=\"#2015-06-20-14-00\" class=\"headerlink\" title=\"2015-06-20 14:00\"></a>2015-06-20 14:00</h1><p>火车飞速的在轨道上前进着，俩旁的建筑也在应和着，欢快的奔跑！一路上，我都在回首着在北京工作和生活中的每一个细节。有过抱怨，有过朦胧，有过欢喜! 我最大的感受就是，我又成长了！是的，人无时无刻不在成长！随着火车的渐停，”石家庄火车站”这几个字标逐渐映入我的眼帘，久悬不下的心，如飞石落地一般，激起了持久的震颤! 在北京漂泊了八个月，我第一次踏上了故乡的土地。看着迎面走来的小伙伴满脸的笑容，我平复了内心的涟漪，展开了双手，飞步的走上前去，给了他一个深深地拥抱！是的，我太想念这片土地，太想念这片土地上的伙伴们啦!</p>\n<h1 id=\"2015-06-28-18-00\"><a href=\"#2015-06-28-18-00\" class=\"headerlink\" title=\"2015-06-28 18:00\"></a>2015-06-28 18:00</h1><p>看着远处逐渐黯淡的阳光和驰车远去的伙伴，我忍不住落下了少有的泪水。我即将踏上北上的火车，离开这片养育了我四年的故土！在学校的最后这段日子每天都是忙碌的，只有很少的机会可以和曾经一个课堂听课，一个球场飞驰的伙伴们叙叙旧。办毕业手续，拍毕业照，吃散伙饭，看散伙电影。然而心里每天想的却是我们永远不会散伙，只要一个电话，我会马上飞奔过去，和你深深相拥！</p>\n<h1 id=\"2015-07-01-9-00\"><a href=\"#2015-07-01-9-00\" class=\"headerlink\" title=\"2015-07-01 9:00\"></a>2015-07-01 9:00</h1><p>如期的再次来到实习单位，看到前台那个警醒的Logo,才感觉到原来它的设计是如此的独特，如此的充满魅力。我独自走到会议室里，等着HR送来需要签字的劳动合同。是的，我就要签订俗称的卖身契啦！一挥笔，几个眉飞色舞的大字跃然纸上，我一刻不停地走到工位，放下背包，拿出所有可用的装备，心里却是可怕的平静！</p>\n<h1 id=\"2015-12-31-20-30\"><a href=\"#2015-12-31-20-30\" class=\"headerlink\" title=\"2015-12-31 20:30\"></a>2015-12-31 20:30</h1><p>我正埋头敲击着键盘，电脑屏幕上密密麻麻堆砌着的，却不是代码。简书的编辑器全屏展现着，是的，今年我创建了博客网站，学会了Markdown，学会了使用简书发一些文章。大脑飞速转动的同时，手指也在不停地敲击着，思路和逻辑已经在回来的路上组织好了，然而此刻想起来和敲下去，却也是那么的不易。搭车回来的路上，朋友说笑，“这是你今年最后一次坐车啦哟，给个红包当油费呗”。说笑着的同时，心里也盘算着，真的已经北漂一年多了！之前看了几篇前辈们发在简书上的工作总结，多少有些感触。在路上回首这一年中的一些情景，仿佛依然历历在目。到家之后卸下包，打开电脑，开始了这篇文章的编写。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这篇文章给人的第一感觉是在写小说，而我就是小说中的主人公。我只能说，真的可以这么认为，因为我也是这么想的。在结束了长达十六年的学生生涯之后，我仿佛来到了另一个完全不同的世界。在这里，每一天依然需要按时上课(工作)，按时交作业(交付物)。不同的是，你每天的老师都不一样，你每天学习的课堂也不一样。在这里，到处都是可以汲取的知识，到处都是新奇的技术，到处都充满着未知的挑战。对于拥有极端求知欲的我，在这里就仿佛是到了期盼已久的天堂。可能这只是另外一种对无聊乏味得生活的自我安慰。</p>\n<p>2015年，已经渐入尾声。2015年是我一生中一个重要的转折点，是我迈入<code>社会大学</code>的一个见证，这是一所求知者不用考试就可以进入的学校。有人说这是一所充满竞争，充满压迫的学校，也有人说这是一所充满希望的学校！<br>其实在我看来，这是一所到处存在爱与恨的学校，我自信将会在这所学校快乐的度过每一个日夜！</p>\n<p>一篇大学生的无聊回忆，一篇职场新人的发奋自白，用以慰藉心灵，无所谓批判与吹捧。</p>\n<h1 id=\"2016年，且行且努力！\"><a href=\"#2016年，且行且努力！\" class=\"headerlink\" title=\"2016年，且行且努力！\"></a>2016年，且行且努力！</h1>","excerpt":"<p>2015年，一个完全陌生的年份，一个从学生过渡到职场新人的年份，一个不一样的年份！</p>\n<h1 id=\"2014-12-31-23-50\"><a href=\"#2014-12-31-23-50\" class=\"headerlink\" title=\"2014-12-31 23:50\"></a>2014-12-31 23:50</h1><p>我正埋头敲击着键盘，电脑屏幕上密密麻麻得堆砌着代码。叮的一声，我被打断了自认为<code>perfect</code>的思路，微信上有好友发来了消息，“胖子，跨年夜，出来High!”。是的，每个群体中都有一个叫“胖子”的活宝，然而我对这个外号已经从最初的抵触变成现在的默认啦。只是让我内心产生一丝波澜的，并不是这个外号，而是”跨年夜”这看似弱小，实则振聋发聩的三个汉字。是呀，马上就是2015年啦！！</p>\n<p>时光荏苒，一眨眼，我已经在企业实习了俩个月啦，同时也代表了我在北京真真正正得漂了俩个月啦! 刚入职时对什么都是懵懵懂懂，现在已经进化到做什么都是半梦半醒啦。是的，在我看来，这是非常不小的进步啦！然而，那个时候，并不知道<code>年度总结</code>是在搞个什么飞机！为了犒劳自己，我果断的合上屏幕，然后对自己说，是时候出去发泄一下啦！<br>","more":"</p>\n<h1 id=\"2015-01-04-10-00\"><a href=\"#2015-01-04-10-00\" class=\"headerlink\" title=\"2015-01-04 10:00\"></a>2015-01-04 10:00</h1><p>元旦假期，和朋友们玩的非常High,以至于已经过去一个小时了，还没有进入工作状态。漫不经心的在博客和论坛上逛着，发现大家都在讨论，这三天又发掘和实现了哪些酷炫的动画效果，又开源了哪些好用的工具。再回首，自己喝醉了俩次，嗨歌搞得嗓子火辣辣的疼。前俩天还感觉并不是很疼，可是这会儿，却感觉一直疼到了心尖上！！喝口温水，收拾了一下心情，开始埋头到工作中!</p>\n<h1 id=\"2015-06-20-14-00\"><a href=\"#2015-06-20-14-00\" class=\"headerlink\" title=\"2015-06-20 14:00\"></a>2015-06-20 14:00</h1><p>火车飞速的在轨道上前进着，俩旁的建筑也在应和着，欢快的奔跑！一路上，我都在回首着在北京工作和生活中的每一个细节。有过抱怨，有过朦胧，有过欢喜! 我最大的感受就是，我又成长了！是的，人无时无刻不在成长！随着火车的渐停，”石家庄火车站”这几个字标逐渐映入我的眼帘，久悬不下的心，如飞石落地一般，激起了持久的震颤! 在北京漂泊了八个月，我第一次踏上了故乡的土地。看着迎面走来的小伙伴满脸的笑容，我平复了内心的涟漪，展开了双手，飞步的走上前去，给了他一个深深地拥抱！是的，我太想念这片土地，太想念这片土地上的伙伴们啦!</p>\n<h1 id=\"2015-06-28-18-00\"><a href=\"#2015-06-28-18-00\" class=\"headerlink\" title=\"2015-06-28 18:00\"></a>2015-06-28 18:00</h1><p>看着远处逐渐黯淡的阳光和驰车远去的伙伴，我忍不住落下了少有的泪水。我即将踏上北上的火车，离开这片养育了我四年的故土！在学校的最后这段日子每天都是忙碌的，只有很少的机会可以和曾经一个课堂听课，一个球场飞驰的伙伴们叙叙旧。办毕业手续，拍毕业照，吃散伙饭，看散伙电影。然而心里每天想的却是我们永远不会散伙，只要一个电话，我会马上飞奔过去，和你深深相拥！</p>\n<h1 id=\"2015-07-01-9-00\"><a href=\"#2015-07-01-9-00\" class=\"headerlink\" title=\"2015-07-01 9:00\"></a>2015-07-01 9:00</h1><p>如期的再次来到实习单位，看到前台那个警醒的Logo,才感觉到原来它的设计是如此的独特，如此的充满魅力。我独自走到会议室里，等着HR送来需要签字的劳动合同。是的，我就要签订俗称的卖身契啦！一挥笔，几个眉飞色舞的大字跃然纸上，我一刻不停地走到工位，放下背包，拿出所有可用的装备，心里却是可怕的平静！</p>\n<h1 id=\"2015-12-31-20-30\"><a href=\"#2015-12-31-20-30\" class=\"headerlink\" title=\"2015-12-31 20:30\"></a>2015-12-31 20:30</h1><p>我正埋头敲击着键盘，电脑屏幕上密密麻麻堆砌着的，却不是代码。简书的编辑器全屏展现着，是的，今年我创建了博客网站，学会了Markdown，学会了使用简书发一些文章。大脑飞速转动的同时，手指也在不停地敲击着，思路和逻辑已经在回来的路上组织好了，然而此刻想起来和敲下去，却也是那么的不易。搭车回来的路上，朋友说笑，“这是你今年最后一次坐车啦哟，给个红包当油费呗”。说笑着的同时，心里也盘算着，真的已经北漂一年多了！之前看了几篇前辈们发在简书上的工作总结，多少有些感触。在路上回首这一年中的一些情景，仿佛依然历历在目。到家之后卸下包，打开电脑，开始了这篇文章的编写。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这篇文章给人的第一感觉是在写小说，而我就是小说中的主人公。我只能说，真的可以这么认为，因为我也是这么想的。在结束了长达十六年的学生生涯之后，我仿佛来到了另一个完全不同的世界。在这里，每一天依然需要按时上课(工作)，按时交作业(交付物)。不同的是，你每天的老师都不一样，你每天学习的课堂也不一样。在这里，到处都是可以汲取的知识，到处都是新奇的技术，到处都充满着未知的挑战。对于拥有极端求知欲的我，在这里就仿佛是到了期盼已久的天堂。可能这只是另外一种对无聊乏味得生活的自我安慰。</p>\n<p>2015年，已经渐入尾声。2015年是我一生中一个重要的转折点，是我迈入<code>社会大学</code>的一个见证，这是一所求知者不用考试就可以进入的学校。有人说这是一所充满竞争，充满压迫的学校，也有人说这是一所充满希望的学校！<br>其实在我看来，这是一所到处存在爱与恨的学校，我自信将会在这所学校快乐的度过每一个日夜！</p>\n<p>一篇大学生的无聊回忆，一篇职场新人的发奋自白，用以慰藉心灵，无所谓批判与吹捧。</p>\n<h1 id=\"2016年，且行且努力！\"><a href=\"#2016年，且行且努力！\" class=\"headerlink\" title=\"2016年，且行且努力！\"></a>2016年，且行且努力！</h1>"},{"layout":"post","title":"我的第一篇博客","date":"2015-07-01T16:00:00.000Z","_content":"\n# 前言　　\n经过了将近一年的实习期，我终于如愿的正式走上了从事软件开发的道路。在由高中时期初识计算机的乐趣进而到大学时对编程的迷恋，我也可以算得上完成了第一个阶段的目标与梦想。\n\n<!-- more -->\n\n# 创站原由\n这几年的学习生涯，养成了我浏览技术博客，论坛网站和开源社区的习惯。其中记忆里尤为突出的是[唐巧的技术博客](http://blog.devtang.com), [GitHub](http://www.github.com/SeraZheng), [StackOverFlow](http://stackoverflow.com/users/5741944/serazheng)和[CocoaChina](http://www.cocoachina.com)；而让我萌生建立个人技术博客网站的念头的因素也间接和我浏览这些技术网站有关系（在这里，我也算免费的帮他们宣传一把吧，哈哈哈。。。。）。没有很大的自信，所以写出来的东西也不知道会不会有人捧有人骂，就权当做事自己的一个人生记录吧（不喜勿喷。。。。）。\n\n# 志向  　\n时常会在一些个人博客和论坛中看到一些前辈们发表的关于开发者自己写技术文章的看法与心得，因而也颇受感悟和影响。希望我可以一如既往的坚持写下去，将自己学习的点点滴滴和感悟心得在这里作一个记录","source":"_posts/我的第一篇博客.md","raw":"---\nlayout: post\ntitle: 我的第一篇博客\ndate: 2015-07-02\ntags: [开篇博客]\ncategories: [开发心得]\n---\n\n# 前言　　\n经过了将近一年的实习期，我终于如愿的正式走上了从事软件开发的道路。在由高中时期初识计算机的乐趣进而到大学时对编程的迷恋，我也可以算得上完成了第一个阶段的目标与梦想。\n\n<!-- more -->\n\n# 创站原由\n这几年的学习生涯，养成了我浏览技术博客，论坛网站和开源社区的习惯。其中记忆里尤为突出的是[唐巧的技术博客](http://blog.devtang.com), [GitHub](http://www.github.com/SeraZheng), [StackOverFlow](http://stackoverflow.com/users/5741944/serazheng)和[CocoaChina](http://www.cocoachina.com)；而让我萌生建立个人技术博客网站的念头的因素也间接和我浏览这些技术网站有关系（在这里，我也算免费的帮他们宣传一把吧，哈哈哈。。。。）。没有很大的自信，所以写出来的东西也不知道会不会有人捧有人骂，就权当做事自己的一个人生记录吧（不喜勿喷。。。。）。\n\n# 志向  　\n时常会在一些个人博客和论坛中看到一些前辈们发表的关于开发者自己写技术文章的看法与心得，因而也颇受感悟和影响。希望我可以一如既往的坚持写下去，将自己学习的点点滴滴和感悟心得在这里作一个记录","slug":"我的第一篇博客","published":1,"updated":"2016-04-12T06:41:59.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9uo002394sugei85ckm","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>经过了将近一年的实习期，我终于如愿的正式走上了从事软件开发的道路。在由高中时期初识计算机的乐趣进而到大学时对编程的迷恋，我也可以算得上完成了第一个阶段的目标与梦想。</p>\n<a id=\"more\"></a>\n<h1 id=\"创站原由\"><a href=\"#创站原由\" class=\"headerlink\" title=\"创站原由\"></a>创站原由</h1><p>这几年的学习生涯，养成了我浏览技术博客，论坛网站和开源社区的习惯。其中记忆里尤为突出的是<a href=\"http://blog.devtang.com\" target=\"_blank\" rel=\"external\">唐巧的技术博客</a>, <a href=\"http://www.github.com/SeraZheng\" target=\"_blank\" rel=\"external\">GitHub</a>, <a href=\"http://stackoverflow.com/users/5741944/serazheng\" target=\"_blank\" rel=\"external\">StackOverFlow</a>和<a href=\"http://www.cocoachina.com\" target=\"_blank\" rel=\"external\">CocoaChina</a>；而让我萌生建立个人技术博客网站的念头的因素也间接和我浏览这些技术网站有关系（在这里，我也算免费的帮他们宣传一把吧，哈哈哈。。。。）。没有很大的自信，所以写出来的东西也不知道会不会有人捧有人骂，就权当做事自己的一个人生记录吧（不喜勿喷。。。。）。</p>\n<h1 id=\"志向\"><a href=\"#志向\" class=\"headerlink\" title=\"志向  　\"></a>志向  　</h1><p>时常会在一些个人博客和论坛中看到一些前辈们发表的关于开发者自己写技术文章的看法与心得，因而也颇受感悟和影响。希望我可以一如既往的坚持写下去，将自己学习的点点滴滴和感悟心得在这里作一个记录</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>经过了将近一年的实习期，我终于如愿的正式走上了从事软件开发的道路。在由高中时期初识计算机的乐趣进而到大学时对编程的迷恋，我也可以算得上完成了第一个阶段的目标与梦想。</p>","more":"<h1 id=\"创站原由\"><a href=\"#创站原由\" class=\"headerlink\" title=\"创站原由\"></a>创站原由</h1><p>这几年的学习生涯，养成了我浏览技术博客，论坛网站和开源社区的习惯。其中记忆里尤为突出的是<a href=\"http://blog.devtang.com\">唐巧的技术博客</a>, <a href=\"http://www.github.com/SeraZheng\">GitHub</a>, <a href=\"http://stackoverflow.com/users/5741944/serazheng\">StackOverFlow</a>和<a href=\"http://www.cocoachina.com\">CocoaChina</a>；而让我萌生建立个人技术博客网站的念头的因素也间接和我浏览这些技术网站有关系（在这里，我也算免费的帮他们宣传一把吧，哈哈哈。。。。）。没有很大的自信，所以写出来的东西也不知道会不会有人捧有人骂，就权当做事自己的一个人生记录吧（不喜勿喷。。。。）。</p>\n<h1 id=\"志向\"><a href=\"#志向\" class=\"headerlink\" title=\"志向  　\"></a>志向  　</h1><p>时常会在一些个人博客和论坛中看到一些前辈们发表的关于开发者自己写技术文章的看法与心得，因而也颇受感悟和影响。希望我可以一如既往的坚持写下去，将自己学习的点点滴滴和感悟心得在这里作一个记录</p>"},{"layout":"post","title":"浅谈一次练手：GitHub和CocoaPods","date":"2015-07-04T16:00:00.000Z","_content":"\n# 前言　　\n在我最早接触开源社区的时候，许多的前辈都给我推荐了`GitHub`，一个开源代码库和版本控制系统，一个管理软件开发以及发现已有开源代码的首选。`GitHub`上分为`私有`和`开放`俩种项目，私有的项目是需要付费的，我想这也是`GitHub`的一种长期的经营策略。而关于`CocoaPods`,相信做iOS的开发者们都不陌生，否则就该返厂进修啦，哈哈哈。。。\n<!-- more -->\n# CocoaPods和GitHub\n`CocoaPods`作为最近几年流行的第三方库的管理为iOS开发项目提供了大大的便利，而且`CocoaPods`也是托管在`GitHub`上的。而至于`CocoaPods`的安装和使用，我在这里推荐前辈的一篇博客，[唐巧的技术博客------用CocoaPods做iOS程序的依赖管理](http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/)，我自认为没有前辈写的那么漂亮，就不卖弄一番啦。而关于`GitHub`的具体使用在这里也不具体的描述了，网上有太多太多地前辈们总结的帖子，我自认为没有他们写地那么详细和完整，所以就不在这里赘述了。\n \n# 第一个开源项目\n之前刚在GitHub上创建了第一个开源项目[MediaBar](https://github.com/SeraZheng/MediaBar),并发布了release 1.1.0版本，目的一来是熟悉一下GitHub和CocoaPods的使用，二来想根据现有项目的开发回顾一下技术。`MediaBar`是一个`UIToolBar`的子类，之前想继承自`UIView`，这样可以接受大多数人的定制需求，但是考虑到设计的全面性，暂时就先缩小了一下范围。`MediaBar`主要使用了俩个依赖框架，`DTRichTextEditor`和`CTAssetsPickerController`,提供给开发者编辑富文本和选择图片的功能。\n\n# MediaBar　　\n本篇博客的题目叫`“浅谈一次练手:GitHub和CocoaPods”`，其主要的想法是借这次练手的开源项目`MediaBar`，来谈一谈在开发过程中我总结的一点感受。之前并不了解`CocoaPods`，也是在项目中开始渐渐地熟悉使用。然后通过建立自己的Pod，才算真正熟悉了这个管理工具。通过它开发者可以便利地将一些十分有用的第三方库加到自己的项目中，极大简化了自己手动添加依赖库的步骤，相信会有越来越多的项目把它作为依赖管理工具。","source":"_posts/浅谈一次练手：GitHub和CocoaPods.md","raw":"---\nlayout: post\ntitle: 浅谈一次练手：GitHub和CocoaPods\ndate: 2015-07-05\ntags: [GitHub开源]\ncategories: [开发心得]\n---\n\n# 前言　　\n在我最早接触开源社区的时候，许多的前辈都给我推荐了`GitHub`，一个开源代码库和版本控制系统，一个管理软件开发以及发现已有开源代码的首选。`GitHub`上分为`私有`和`开放`俩种项目，私有的项目是需要付费的，我想这也是`GitHub`的一种长期的经营策略。而关于`CocoaPods`,相信做iOS的开发者们都不陌生，否则就该返厂进修啦，哈哈哈。。。\n<!-- more -->\n# CocoaPods和GitHub\n`CocoaPods`作为最近几年流行的第三方库的管理为iOS开发项目提供了大大的便利，而且`CocoaPods`也是托管在`GitHub`上的。而至于`CocoaPods`的安装和使用，我在这里推荐前辈的一篇博客，[唐巧的技术博客------用CocoaPods做iOS程序的依赖管理](http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/)，我自认为没有前辈写的那么漂亮，就不卖弄一番啦。而关于`GitHub`的具体使用在这里也不具体的描述了，网上有太多太多地前辈们总结的帖子，我自认为没有他们写地那么详细和完整，所以就不在这里赘述了。\n \n# 第一个开源项目\n之前刚在GitHub上创建了第一个开源项目[MediaBar](https://github.com/SeraZheng/MediaBar),并发布了release 1.1.0版本，目的一来是熟悉一下GitHub和CocoaPods的使用，二来想根据现有项目的开发回顾一下技术。`MediaBar`是一个`UIToolBar`的子类，之前想继承自`UIView`，这样可以接受大多数人的定制需求，但是考虑到设计的全面性，暂时就先缩小了一下范围。`MediaBar`主要使用了俩个依赖框架，`DTRichTextEditor`和`CTAssetsPickerController`,提供给开发者编辑富文本和选择图片的功能。\n\n# MediaBar　　\n本篇博客的题目叫`“浅谈一次练手:GitHub和CocoaPods”`，其主要的想法是借这次练手的开源项目`MediaBar`，来谈一谈在开发过程中我总结的一点感受。之前并不了解`CocoaPods`，也是在项目中开始渐渐地熟悉使用。然后通过建立自己的Pod，才算真正熟悉了这个管理工具。通过它开发者可以便利地将一些十分有用的第三方库加到自己的项目中，极大简化了自己手动添加依赖库的步骤，相信会有越来越多的项目把它作为依赖管理工具。","slug":"浅谈一次练手：GitHub和CocoaPods","published":1,"updated":"2016-04-12T06:42:36.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9us002794suigydzqdv","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>在我最早接触开源社区的时候，许多的前辈都给我推荐了<code>GitHub</code>，一个开源代码库和版本控制系统，一个管理软件开发以及发现已有开源代码的首选。<code>GitHub</code>上分为<code>私有</code>和<code>开放</code>俩种项目，私有的项目是需要付费的，我想这也是<code>GitHub</code>的一种长期的经营策略。而关于<code>CocoaPods</code>,相信做iOS的开发者们都不陌生，否则就该返厂进修啦，哈哈哈。。。<br><a id=\"more\"></a></p>\n<h1 id=\"CocoaPods和GitHub\"><a href=\"#CocoaPods和GitHub\" class=\"headerlink\" title=\"CocoaPods和GitHub\"></a>CocoaPods和GitHub</h1><p><code>CocoaPods</code>作为最近几年流行的第三方库的管理为iOS开发项目提供了大大的便利，而且<code>CocoaPods</code>也是托管在<code>GitHub</code>上的。而至于<code>CocoaPods</code>的安装和使用，我在这里推荐前辈的一篇博客，<a href=\"http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/\" target=\"_blank\" rel=\"external\">唐巧的技术博客——用CocoaPods做iOS程序的依赖管理</a>，我自认为没有前辈写的那么漂亮，就不卖弄一番啦。而关于<code>GitHub</code>的具体使用在这里也不具体的描述了，网上有太多太多地前辈们总结的帖子，我自认为没有他们写地那么详细和完整，所以就不在这里赘述了。</p>\n<h1 id=\"第一个开源项目\"><a href=\"#第一个开源项目\" class=\"headerlink\" title=\"第一个开源项目\"></a>第一个开源项目</h1><p>之前刚在GitHub上创建了第一个开源项目<a href=\"https://github.com/SeraZheng/MediaBar\" target=\"_blank\" rel=\"external\">MediaBar</a>,并发布了release 1.1.0版本，目的一来是熟悉一下GitHub和CocoaPods的使用，二来想根据现有项目的开发回顾一下技术。<code>MediaBar</code>是一个<code>UIToolBar</code>的子类，之前想继承自<code>UIView</code>，这样可以接受大多数人的定制需求，但是考虑到设计的全面性，暂时就先缩小了一下范围。<code>MediaBar</code>主要使用了俩个依赖框架，<code>DTRichTextEditor</code>和<code>CTAssetsPickerController</code>,提供给开发者编辑富文本和选择图片的功能。</p>\n<h1 id=\"MediaBar\"><a href=\"#MediaBar\" class=\"headerlink\" title=\"MediaBar　　\"></a>MediaBar　　</h1><p>本篇博客的题目叫<code>“浅谈一次练手:GitHub和CocoaPods”</code>，其主要的想法是借这次练手的开源项目<code>MediaBar</code>，来谈一谈在开发过程中我总结的一点感受。之前并不了解<code>CocoaPods</code>，也是在项目中开始渐渐地熟悉使用。然后通过建立自己的Pod，才算真正熟悉了这个管理工具。通过它开发者可以便利地将一些十分有用的第三方库加到自己的项目中，极大简化了自己手动添加依赖库的步骤，相信会有越来越多的项目把它作为依赖管理工具。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　　\"></a>前言　　</h1><p>在我最早接触开源社区的时候，许多的前辈都给我推荐了<code>GitHub</code>，一个开源代码库和版本控制系统，一个管理软件开发以及发现已有开源代码的首选。<code>GitHub</code>上分为<code>私有</code>和<code>开放</code>俩种项目，私有的项目是需要付费的，我想这也是<code>GitHub</code>的一种长期的经营策略。而关于<code>CocoaPods</code>,相信做iOS的开发者们都不陌生，否则就该返厂进修啦，哈哈哈。。。<br>","more":"</p>\n<h1 id=\"CocoaPods和GitHub\"><a href=\"#CocoaPods和GitHub\" class=\"headerlink\" title=\"CocoaPods和GitHub\"></a>CocoaPods和GitHub</h1><p><code>CocoaPods</code>作为最近几年流行的第三方库的管理为iOS开发项目提供了大大的便利，而且<code>CocoaPods</code>也是托管在<code>GitHub</code>上的。而至于<code>CocoaPods</code>的安装和使用，我在这里推荐前辈的一篇博客，<a href=\"http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/\">唐巧的技术博客——用CocoaPods做iOS程序的依赖管理</a>，我自认为没有前辈写的那么漂亮，就不卖弄一番啦。而关于<code>GitHub</code>的具体使用在这里也不具体的描述了，网上有太多太多地前辈们总结的帖子，我自认为没有他们写地那么详细和完整，所以就不在这里赘述了。</p>\n<h1 id=\"第一个开源项目\"><a href=\"#第一个开源项目\" class=\"headerlink\" title=\"第一个开源项目\"></a>第一个开源项目</h1><p>之前刚在GitHub上创建了第一个开源项目<a href=\"https://github.com/SeraZheng/MediaBar\">MediaBar</a>,并发布了release 1.1.0版本，目的一来是熟悉一下GitHub和CocoaPods的使用，二来想根据现有项目的开发回顾一下技术。<code>MediaBar</code>是一个<code>UIToolBar</code>的子类，之前想继承自<code>UIView</code>，这样可以接受大多数人的定制需求，但是考虑到设计的全面性，暂时就先缩小了一下范围。<code>MediaBar</code>主要使用了俩个依赖框架，<code>DTRichTextEditor</code>和<code>CTAssetsPickerController</code>,提供给开发者编辑富文本和选择图片的功能。</p>\n<h1 id=\"MediaBar\"><a href=\"#MediaBar\" class=\"headerlink\" title=\"MediaBar　　\"></a>MediaBar　　</h1><p>本篇博客的题目叫<code>“浅谈一次练手:GitHub和CocoaPods”</code>，其主要的想法是借这次练手的开源项目<code>MediaBar</code>，来谈一谈在开发过程中我总结的一点感受。之前并不了解<code>CocoaPods</code>，也是在项目中开始渐渐地熟悉使用。然后通过建立自己的Pod，才算真正熟悉了这个管理工具。通过它开发者可以便利地将一些十分有用的第三方库加到自己的项目中，极大简化了自己手动添加依赖库的步骤，相信会有越来越多的项目把它作为依赖管理工具。</p>"},{"layout":"post","title":"自动注释VVDocumenter-Xcode和插件管理Alcatraz","date":"2015-07-25T16:00:00.000Z","_content":"\n# 前言　\n在上一篇中，我记录了对于代码注释的一些研究，然后发现有一些`第三方工具`和`Xcode插件`可以帮助我们自动地添加代码注释，这里就介绍一种Xcode的插件`VVDocmenter-Xcode`。\n>引用一下官方的语言，VVDocmenter-Xcode是可以帮助你自主添加生成与appledoc、Doxygen和HeaderDoc这三种文档生成工具都匹配的注释的Xcode插件。而且VVDocmenter-Xcode也是在GitHub上开源的，因此它具有很好的活跃度。\n<!-- more -->\n# VVDocmenter-Xcode安装\n`VVDocmenter-Xcode`支持`Xcode 5`以后的版本，而谈到`VVDocmenter-Xcode`的安装，官方给出了俩种方法，第一种是git clone命令从`GitHub`上将`VVDocmenter-Xcode`项目拷贝到本地，然后在本地build以后重启Xcode，之后你就可以在你自己的项目中使用它。\n\n而`VVDocmenter-Xcode`的使用方法也比较简单，在你想要添加注释的位置直接输入三个“/”，`VVDocmenter-Xcode`就可以帮助你自动识别你想添加的注释的类别，然后生成注释，你只需要将自己的描述加进去就可以了。在这里我们就不在赘述了，官方给出了很好的使用指南。我们在这里重点地讲一下第二种安装方法，就是使用`Alcatraz`。\n\n# Alcatraz  \n`Alcatraz`是一个开源的`Xcode包管理助手`，集成了一些可以安装在Xcode内，提高我们开发效率的`插件`、`模板`和`配色方案`。`Alcatraz`也是支持Xcode 5以后的版本，并且需要在Mac　OS 10.9以后的版本才可以正常使用。而关于`Alcatraz`的安装，在[GitHub----Alcatraz](https://github.com/supermarin/Alcatraz)和[Alcatraz](http://alcatraz.io/)官方网站上都有详细的介绍。\n　\n# Alcatraz安装\n{% codeblock lang:bash %}\ncurl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh\n{% endcodeblock %}\n\n# Alcatraz卸载\n{% codeblock lang:bash %}\nrm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin\n{% endcodeblock %}\n\n# 插件卸载\n卸载通过Alcatraz安装的插件、模板和配色方案：\n{% codeblock lang:bash %}\nrm -rf ~/Library/Application\\ Support/Alcatraz/\n{% endcodeblock %}\n\n# 展示\n安装成功之后，我们就可以正常使用Alcatraz来安装VVDocmenter-Xcode啦！！！\n{% img /images/Alcatraz.png %}","source":"_posts/自动注释VVDocumenter-Xcode和插件管理Alcatraz.md","raw":"---\nlayout: post\ntitle: 自动注释VVDocumenter-Xcode和插件管理Alcatraz\ndate: 2015-07-26\ntags: [注释]\ncategories: [Xcode]\n---\n\n# 前言　\n在上一篇中，我记录了对于代码注释的一些研究，然后发现有一些`第三方工具`和`Xcode插件`可以帮助我们自动地添加代码注释，这里就介绍一种Xcode的插件`VVDocmenter-Xcode`。\n>引用一下官方的语言，VVDocmenter-Xcode是可以帮助你自主添加生成与appledoc、Doxygen和HeaderDoc这三种文档生成工具都匹配的注释的Xcode插件。而且VVDocmenter-Xcode也是在GitHub上开源的，因此它具有很好的活跃度。\n<!-- more -->\n# VVDocmenter-Xcode安装\n`VVDocmenter-Xcode`支持`Xcode 5`以后的版本，而谈到`VVDocmenter-Xcode`的安装，官方给出了俩种方法，第一种是git clone命令从`GitHub`上将`VVDocmenter-Xcode`项目拷贝到本地，然后在本地build以后重启Xcode，之后你就可以在你自己的项目中使用它。\n\n而`VVDocmenter-Xcode`的使用方法也比较简单，在你想要添加注释的位置直接输入三个“/”，`VVDocmenter-Xcode`就可以帮助你自动识别你想添加的注释的类别，然后生成注释，你只需要将自己的描述加进去就可以了。在这里我们就不在赘述了，官方给出了很好的使用指南。我们在这里重点地讲一下第二种安装方法，就是使用`Alcatraz`。\n\n# Alcatraz  \n`Alcatraz`是一个开源的`Xcode包管理助手`，集成了一些可以安装在Xcode内，提高我们开发效率的`插件`、`模板`和`配色方案`。`Alcatraz`也是支持Xcode 5以后的版本，并且需要在Mac　OS 10.9以后的版本才可以正常使用。而关于`Alcatraz`的安装，在[GitHub----Alcatraz](https://github.com/supermarin/Alcatraz)和[Alcatraz](http://alcatraz.io/)官方网站上都有详细的介绍。\n　\n# Alcatraz安装\n{% codeblock lang:bash %}\ncurl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh\n{% endcodeblock %}\n\n# Alcatraz卸载\n{% codeblock lang:bash %}\nrm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin\n{% endcodeblock %}\n\n# 插件卸载\n卸载通过Alcatraz安装的插件、模板和配色方案：\n{% codeblock lang:bash %}\nrm -rf ~/Library/Application\\ Support/Alcatraz/\n{% endcodeblock %}\n\n# 展示\n安装成功之后，我们就可以正常使用Alcatraz来安装VVDocmenter-Xcode啦！！！\n{% img /images/Alcatraz.png %}","slug":"自动注释VVDocumenter-Xcode和插件管理Alcatraz","published":1,"updated":"2016-04-12T06:46:09.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9ut002a94su5n5nf5fs","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　\"></a>前言　</h1><p>在上一篇中，我记录了对于代码注释的一些研究，然后发现有一些<code>第三方工具</code>和<code>Xcode插件</code>可以帮助我们自动地添加代码注释，这里就介绍一种Xcode的插件<code>VVDocmenter-Xcode</code>。</p>\n<blockquote>\n<p>引用一下官方的语言，VVDocmenter-Xcode是可以帮助你自主添加生成与appledoc、Doxygen和HeaderDoc这三种文档生成工具都匹配的注释的Xcode插件。而且VVDocmenter-Xcode也是在GitHub上开源的，因此它具有很好的活跃度。<br><a id=\"more\"></a></p>\n<h1 id=\"VVDocmenter-Xcode安装\"><a href=\"#VVDocmenter-Xcode安装\" class=\"headerlink\" title=\"VVDocmenter-Xcode安装\"></a>VVDocmenter-Xcode安装</h1><p><code>VVDocmenter-Xcode</code>支持<code>Xcode 5</code>以后的版本，而谈到<code>VVDocmenter-Xcode</code>的安装，官方给出了俩种方法，第一种是git clone命令从<code>GitHub</code>上将<code>VVDocmenter-Xcode</code>项目拷贝到本地，然后在本地build以后重启Xcode，之后你就可以在你自己的项目中使用它。</p>\n</blockquote>\n<p>而<code>VVDocmenter-Xcode</code>的使用方法也比较简单，在你想要添加注释的位置直接输入三个“/”，<code>VVDocmenter-Xcode</code>就可以帮助你自动识别你想添加的注释的类别，然后生成注释，你只需要将自己的描述加进去就可以了。在这里我们就不在赘述了，官方给出了很好的使用指南。我们在这里重点地讲一下第二种安装方法，就是使用<code>Alcatraz</code>。</p>\n<h1 id=\"Alcatraz\"><a href=\"#Alcatraz\" class=\"headerlink\" title=\"Alcatraz\"></a>Alcatraz</h1><p><code>Alcatraz</code>是一个开源的<code>Xcode包管理助手</code>，集成了一些可以安装在Xcode内，提高我们开发效率的<code>插件</code>、<code>模板</code>和<code>配色方案</code>。<code>Alcatraz</code>也是支持Xcode 5以后的版本，并且需要在Mac　OS 10.9以后的版本才可以正常使用。而关于<code>Alcatraz</code>的安装，在<a href=\"https://github.com/supermarin/Alcatraz\" target=\"_blank\" rel=\"external\">GitHub—-Alcatraz</a>和<a href=\"http://alcatraz.io/\" target=\"_blank\" rel=\"external\">Alcatraz</a>官方网站上都有详细的介绍。\n　</p>\n<h1 id=\"Alcatraz安装\"><a href=\"#Alcatraz安装\" class=\"headerlink\" title=\"Alcatraz安装\"></a>Alcatraz安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh</span><br></pre></td></tr></table></figure>\n<h1 id=\"Alcatraz卸载\"><a href=\"#Alcatraz卸载\" class=\"headerlink\" title=\"Alcatraz卸载\"></a>Alcatraz卸载</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin</span><br></pre></td></tr></table></figure>\n<h1 id=\"插件卸载\"><a href=\"#插件卸载\" class=\"headerlink\" title=\"插件卸载\"></a>插件卸载</h1><p>卸载通过Alcatraz安装的插件、模板和配色方案：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf ~/Library/Application\\ Support/Alcatraz/</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"展示\"><a href=\"#展示\" class=\"headerlink\" title=\"展示\"></a>展示</h1><p>安装成功之后，我们就可以正常使用Alcatraz来安装VVDocmenter-Xcode啦！！！<br><img src=\"/images/Alcatraz.png\"></p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言　\"></a>前言　</h1><p>在上一篇中，我记录了对于代码注释的一些研究，然后发现有一些<code>第三方工具</code>和<code>Xcode插件</code>可以帮助我们自动地添加代码注释，这里就介绍一种Xcode的插件<code>VVDocmenter-Xcode</code>。</p>\n<blockquote>\n<p>引用一下官方的语言，VVDocmenter-Xcode是可以帮助你自主添加生成与appledoc、Doxygen和HeaderDoc这三种文档生成工具都匹配的注释的Xcode插件。而且VVDocmenter-Xcode也是在GitHub上开源的，因此它具有很好的活跃度。<br>","more":"</p>\n<h1 id=\"VVDocmenter-Xcode安装\"><a href=\"#VVDocmenter-Xcode安装\" class=\"headerlink\" title=\"VVDocmenter-Xcode安装\"></a>VVDocmenter-Xcode安装</h1><p><code>VVDocmenter-Xcode</code>支持<code>Xcode 5</code>以后的版本，而谈到<code>VVDocmenter-Xcode</code>的安装，官方给出了俩种方法，第一种是git clone命令从<code>GitHub</code>上将<code>VVDocmenter-Xcode</code>项目拷贝到本地，然后在本地build以后重启Xcode，之后你就可以在你自己的项目中使用它。</p>\n</blockquote>\n<p>而<code>VVDocmenter-Xcode</code>的使用方法也比较简单，在你想要添加注释的位置直接输入三个“/”，<code>VVDocmenter-Xcode</code>就可以帮助你自动识别你想添加的注释的类别，然后生成注释，你只需要将自己的描述加进去就可以了。在这里我们就不在赘述了，官方给出了很好的使用指南。我们在这里重点地讲一下第二种安装方法，就是使用<code>Alcatraz</code>。</p>\n<h1 id=\"Alcatraz\"><a href=\"#Alcatraz\" class=\"headerlink\" title=\"Alcatraz\"></a>Alcatraz</h1><p><code>Alcatraz</code>是一个开源的<code>Xcode包管理助手</code>，集成了一些可以安装在Xcode内，提高我们开发效率的<code>插件</code>、<code>模板</code>和<code>配色方案</code>。<code>Alcatraz</code>也是支持Xcode 5以后的版本，并且需要在Mac　OS 10.9以后的版本才可以正常使用。而关于<code>Alcatraz</code>的安装，在<a href=\"https://github.com/supermarin/Alcatraz\">GitHub—-Alcatraz</a>和<a href=\"http://alcatraz.io/\">Alcatraz</a>官方网站上都有详细的介绍。\n　</p>\n<h1 id=\"Alcatraz安装\"><a href=\"#Alcatraz安装\" class=\"headerlink\" title=\"Alcatraz安装\"></a>Alcatraz安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh</span><br></pre></td></tr></table></figure>\n<h1 id=\"Alcatraz卸载\"><a href=\"#Alcatraz卸载\" class=\"headerlink\" title=\"Alcatraz卸载\"></a>Alcatraz卸载</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin</span><br></pre></td></tr></table></figure>\n<h1 id=\"插件卸载\"><a href=\"#插件卸载\" class=\"headerlink\" title=\"插件卸载\"></a>插件卸载</h1><p>卸载通过Alcatraz安装的插件、模板和配色方案：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf ~/Library/Application\\ Support/Alcatraz/</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"展示\"><a href=\"#展示\" class=\"headerlink\" title=\"展示\"></a>展示</h1><p>安装成功之后，我们就可以正常使用Alcatraz来安装VVDocmenter-Xcode啦！！！<br><img src=\"/images/Alcatraz.png\"></p>"},{"layout":"post","title":"通过UIActivityViewController实现更多分享服务","date":"2015-12-14T16:00:00.000Z","description":"介绍UIActivityViewController以及如何在iOS系统上实现跨App之间的内容分享","_content":"# 前言\n我在[通过UIDocumentInteractionController预览和分享\"史蒂夫•乔布斯传\"](http://www.jianshu.com/p/3f03897cf98a)这篇文章中，详细讲了`UIDocumentInteractionController`的用途和使用方法。而在`iOS 6 SDK`中,苹果提供了`UIActivityViewController`来让我们可以使用更多地服务。这篇文章，我就来介绍一下怎么通过`UIActivityViewController`实现更多地服务。\n<!-- more -->\n# 简介\n打开`UIActivityViewController`的API文档，我们可以看到`UIActivityViewController`的声明。\n{% codeblock lang:objc %}\nNS_CLASS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED @interface UIActivityViewController : UIViewController\n{% endcodeblock %}\n\n我们可以看出`UIActivityViewController`是在`iOS 6`开始支持的，同样是不能在Apple TV的开发中使用。而且`UIActivityViewController`是直接继承`UIViewController`的，这意味着我们需要自己来展示和解散视图。\n\n# 准备\n我使用在`UIDocumentInteractionController`测试中使用的Demo,GitHub地址是：[ZSDocumentInteractionTest](https://github.com/SeraZheng/ZSDocumentInteractionTest)。然后添加一个新的Button作为`UIActivityViewController`的触发事件，运行程序，就可以看到下面的界面啦(过程自行想象，哈哈)\n\n{% img /images/展示俩个Button.png %}\n\n# 初始化\n接着我们在Button的触发方法里面开始操作`UIActivityViewController`来提供服务。首先，我们需要初始化一个`UIActivityViewController`的实例，`UIActivityViewController`提供了一个初始化方法：\n{% codeblock lang:objc %}\n- (instancetype)initWithActivityItems:(NSArray *)activityItems applicationActivities:(nullable NSArray<__kindof UIActivity *> *)applicationActivities NS_DESIGNATED_INITIALIZER;\n{% endcodeblock %}\n\n官方文档对这俩个参数有详细的解释：\n\n|      参数                  |    描述 |\n|:-----------------|:-----|\n|activityItems\t|The array of data objects on which to perform the activity. The type of objects in the array is variable and dependent on the data your application manages. For example, the data might consist of one or more string or image objects representing the currently selected content.     Instead of actual data objects, the objects in this array can be objects that adopt the UIActivityItemSource protocol, such as UIActivityItemProvider objects. Source and provider objects act as proxies for the corresponding data in situations where you do not want to provide that data until it is needed. Note that you should not resuse an activity view controller object that includes a UIActivityItemProvider object in its activityItems array.This array must not be nil and must contain at least one object.|\n|applicationActivities |An array of UIActivity objects representing the custom services that your application supports. This parameter may be nil.|\n\n\n大概意思是这个方法接收俩个数组类型的参数，第一个数组内的对象代表的是我们想要操作的数据的一些表征，而且这个数组至少需要一个值，比如我们PDF文档的名称，URL；第二个数组指定了`泛型`，数组内的对象必须是`UIActivity`类型的对象，代表的是iOS系统支持的我们自定义的服务，关于这点我在后面`自定义UIActivity服务`的内容中会讲解，现在我们暂时置为`nil`。代码如下：\n{% codeblock lang:objc %}\n- (IBAction)presentPDFActivityView:(id)sender {\n    UIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[@\"Steve Jobs by waiter lsaacson\", [[NSBundle mainBundle] URLForResource:@\"Steve\" withExtension:@\"pdf\"]] applicationActivities:nil];\n{% endcodeblock %}\n# 视图展示\n`UIActivityViewController`是直接继承`UIViewController`的，看到这，你想象可以通过自己的需求来使用不同的方式展示`UIActivityViewController`啦，然而事与愿违。\n\n>官方文档中是这么说的: “When presenting the view controller, you must do so using the appropriate means for the current device. On iPad, you must present the view controller in a popover. On iPhone and iPod touch, you must present it modally”。 大概意思是说，展示`UIActivityViewController`的时候需要根据当前的设备类型选择合适的展示方式，在iPad设备上就必须在'popover'视图里面展示，在其他设备上，必须以模态视图展示。\n\n个人认为开发必须持怀疑和验证的态度，所以我尝试在一个`UINavigationController`中push一个`UIActivityController`,代码如下：\n{% codeblock lang:objc %}\n- (IBAction)presentPDFActivityView:(id)sender {\n    \n    UIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[@\"Steve Jobs by waiter lsaacson\", [[NSBundle mainBundle] URLForResource:@\"Steve\" withExtension:@\"pdf\"]] applicationActivities:nil];\n    [self.navigationController pushViewController:activity animated:YES];\n}\n{% endcodeblock %}\n\n然后运行程序，点击Button，意料之中程序崩溃掉了，给出我们的错误反馈是：\n{% codeblock lang:bash %}\n2015-12-31 15:03:03.733 ZSDocumentInteractionTest[9307:971136] *** Terminating app due to uncaught exception 'NSGenericException', reason: 'UIActivityViewController can only be used modally or as contentViewController in popover on iPad.'\n*** First throw call stack:\n(\n\t0   CoreFoundation                      0x0000000103197e65 __exceptionPreprocess + 165\n\t1   libobjc.A.dylib                     0x0000000102c10deb objc_exception_throw + 48\n\t2   CoreFoundation                      0x0000000103197d9d +[NSException raise:format:] + 205\n\t3   UIKit                               0x0000000103e68e55 -[UIActivityViewController viewDidAppear:] + 533\n\t4   UIKit                               0x00000001036e0949 -[UIViewController _setViewAppearState:isAnimating:] + 830\n\t5   UIKit                               0x00000001036e12cc -[UIViewController _endAppearanceTransition:] + 262\n\t6   UIKit                               0x000000010371bf63 -[UINavigationController navigationTransitionView:didEndTransition:fromView:toView:] + 1290\n\t7   UIKit                               0x0000000103711d24 __49-[UINavigationController _startCustomTransition:]_block_invoke + 233\n\t8   UIKit                               0x0000000103f4ad20 -[_UIViewControllerTransitionContext completeTransition:] + 101\n\t9   UIKit                               0x000000010352cfff __53-[_UINavigationParallaxTransition animateTransition:]_block_invoke95 + 834\n\t10  UIKit                               0x00000001035f1076 -[UIViewAnimationBlockDelegate _didEndBlockAnimation:finished:context:] + 644\n\t11  UIKit                               0x00000001035ce2af -[UIViewAnimationState sendDelegateAnimationDidStop:finished:] + 241\n\t12  UIKit                               0x00000001035ce65e -[UIViewAnimationState animationDidStop:finished:] + 80\n\t13  QuartzCore                          0x00000001070c2fa0 _ZN2CA5Layer23run_animation_callbacksEPv + 308\n\t14  libdispatch.dylib                   0x000000010589f49b _dispatch_client_callout + 8\n\t15  libdispatch.dylib                   0x00000001058872af _dispatch_main_queue_callback_4CF + 1738\n\t16  CoreFoundation                      0x00000001030f7d09 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9\n\t17  CoreFoundation                      0x00000001030b92c9 __CFRunLoopRun + 2073\n\t18  CoreFoundation                      0x00000001030b8828 CFRunLoopRunSpecific + 488\n\t19  GraphicsServices                    0x0000000106954ad2 GSEventRunModal + 161\n\t20  UIKit                               0x0000000103544610 UIApplicationMain + 171\n\t21  ZSDocumentInteractionTest           0x000000010270b6af main + 111\n\t22  libdyld.dylib                       0x00000001058d392d start + 1\n)\nlibc++abi.dylib: terminating with uncaught exception of type NSException\n(lldb) \n{% endcodeblock %}\n\n我们看出错误说明是`\"UIActivityViewController can only be used modally or as contentViewController in popover on iPad.\"`因此我们需要更换一下展示方法，在手机上已一个模态视图的方式展示，而在iPad上则作为`popover`的内容视图展示。代码如下：\n{% codeblock lang:objc %}\n- (IBAction)presentPDFActivityView:(id)sender {\n    \n    UIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[[[NSBundle mainBundle] URLForResource:@\"Steve\" withExtension:@\"pdf\"]] applicationActivities:@[[[ZSCustomActivity alloc] init]]];\n    activity.excludedActivityTypes = @[UIActivityTypeAirDrop];\n    \n    // incorrect usage\n    // [self.navigationController pushViewController:activity animated:YES];\n    \n    UIPopoverPresentationController *popover = activity.popoverPresentationController;\n    if (popover) {\n        popover.sourceView = self.activityButton;\n        popover.permittedArrowDirections = UIPopoverArrowDirectionUp;\n    }\n    \n    [self presentViewController:activity animated:YES completion:NULL];\n}\n{% endcodeblock %}\n再次运行代码，点击Button，就可以看到下面的界面啦(完美展示)\n\n{% img /images/展示UIActivityViewController.png %}\n\n然后我们就可以选择服务来操作和分享`史蒂夫•乔布斯传`啦。\n\n# excludedActivityTypes\n`UIActivityViewController`相比于`UIDocumentInteractionController`优势除了可以添加额外的自定义服务，它还提供了非常好的原生服务的定制化功能。我们可以完全根据自己的需求，控制`UIActivityViewController`提供的系统服务的显示，比如我不想展示`AirDrop`这个功能，而这点在`UIDocumentInteractionController`是做不到的。想做到这一点，就需要使用到`UIActivityViewController`提供的一个属性:\n{% codeblock lang:objc %}\n@property(nullable, nonatomic, copy) NSArray<NSString *> *excludedActivityTypes; // default is nil. activity types listed will not be displayed\n{% endcodeblock %}\n\n正如注释中提到的，`excludedActivityTypes`这个属性包含了所有不想在`UIActivityViewController`中展示的Item服务。`excludedActivityTypes`是一个字符串数组，所包含的内容必须是系统提供的`UIActivity`的`activityType`字符串，而系统提供的字符串如下：\n{% codeblock lang:objc %}\nNSString *const UIActivityTypePostToFacebook;\nNSString *const UIActivityTypePostToTwitter;\nNSString *const UIActivityTypePostToWeibo;\nNSString *const UIActivityTypeMessage;\nNSString *const UIActivityTypeMail;\nNSString *const UIActivityTypePrint;\nNSString *const UIActivityTypeCopyToPasteboard;\nNSString *const UIActivityTypeAssignToContact;\nNSString *const UIActivityTypeSaveToCameraRoll;\nNSString *const UIActivityTypeAddToReadingList;\nNSString *const UIActivityTypePostToFlickr;\nNSString *const UIActivityTypePostToVimeo;\nNSString *const UIActivityTypePostToTencentWeibo;\nNSString *const UIActivityTypeAirDrop;\n{% endcodeblock %}\n如果我们不想展示`AirDrop`功能，我们把`UIActivityTypeAirDrop`添加到`excludedActivityTypes`里面：\n{% codeblock lang:objc %}\nactivity.excludedActivityTypes = @[UIActivityTypeAirDrop];\n{% endcodeblock %}\n运行程序，点击Button，我们可以看到下面的界面发生的变化。\n\n{% img /images/隐藏AirDrop.png %}\n\n# 自定义UIActivity服务\n`UIActivityViewController`相比于`UIDocumentInteractionController`的最大优势就是`UIActivityViewController`所提供的自定义服务，我们可以通过`UIActivity`在`UIActivityViewController`上添加我们自定义的服务。\n\n>官方文档上对UIActivity有一段解释，\"This class must be subclassed before it can be used. The job of an activity object is to act on the data provided to it and to provide some meta information that iOS can display to the user. For more complex services, an activity object can also display a custom user interface and use it to gather additional information from the user.\"。其大概意思是，UIActivity必须通过继承来使用，它主要是操作给用户展示的信息，而且还可以操作展示定制化的界面来获取更多地数据信息。\n\n现在我们打算自定义一个叫`ZS Custom`的服务，所以我们创建一个`ZSCustomActivity`得类来继承`UIActivity`，除此之外，我们必须重写下面的几个方法:\n\n1.activityType\n    {% codeblock lang:objc %}\n    - (nullable NSString *)activityType;       // default returns nil. subclass may override to return custom activity type that is reported to completion handler\n    {% endcodeblock %}\n    这是用来标识自定义服务的一个字符串,而系统提供的服务的标识在上面我们已经提到了；为了迎合iOS SDK中的规范，我给它返回一个`UIActivityTypeZSCustomMine`，定义如下：\n    {% codeblock lang:objc %}\n    NSString *const UIActivityTypeZSCustomMine = @\"ZSCustomActivityMine\";\n\n    - (NSString *)activityType\n    {\n        return UIActivityTypeZSCustomMine;\n    }\n    {% endcodeblock %}\n    \n2.activityTitle\n    {% codeblock lang:objc %}\n    - (nullable NSString *)activityTitle;      // default returns nil. subclass must override and must return non-nil value\n    {% endcodeblock %}\n    \n    在`UIActivityViewController`中给用户展示的服务的名称，比如上面图片中的`\"Copy\"`,`\"Print\"`,我们自定义的服务名称为`ZS Custom`：\n    \n    {% codeblock lang:objc %}\n    - (NSString *)activityTitle\n    {\n        //国际化\n        return NSLocalizedString(@\"ZS Custom\", @\"\");\n    }\n    {% endcodeblock %}\n    \n3.activityImage\n    {% codeblock lang:objc %}\n    - (nullable UIImage *)activityImage;       // default returns nil. subclass must override and must return non-nil value\n    {% endcodeblock %}\n    \n    在`UIActivityViewController`中给用户展示的服务的图标。关于这里的图标，有非常严格的限制：\n    \n    * 首先是图标的背景色，这里推荐最好的完全透明的背景色。\n    \n    >官方文档中是这么解释的，\"The alpha channel of the image is used as a mask to generate the final image that is presented to the user. Any color data in the image itself is ignored. Opaque pixels have a gradient applied to them and this gradient is then laid on top of a standard background. Thus, a completely opaque image would yield a gradient filled rectangle\",意思大概是，在这里颜色数据会被忽略，而透明图层会被当做mask(蒙版图层)，不透明的图片会显示成渐进色填充。\n\n    * 其次是图标的尺寸，在不同的设备需要不同的尺寸，因此需要准备一套图标。\n\n|Device |iOS Version  |Icon Size(pt) |\n|:-----|:---------: |:-------:|\n|iPhone、iPod Touch|iOS 6|< 43x43|\n|iPhone、iPod Touch|iOS 7+|60x60|\n|iPad|iOS 6| < 60x60|\n|iPad|iOS 7+|76x76|\n|Retina| All| @2x|\n    \n4.canPerformWithActivityItems:\n    {% codeblock lang:objc %}\n    - (BOOL)canPerformWithActivityItems:(NSArray *)activityItems;   // override this to return availability of activity based on items. default returns NO\n\n    {% endcodeblock %}\n     指定可以处理的数据类型，如果可以处理则返回`YES`\n     \n5.prepareWithActivityItems:\n    {% codeblock lang:objc %}\n    - (void)prepareWithActivityItems:(NSArray *)activityItems;      // override to extract items and set up your HI. default does nothing\n    {% endcodeblock %}\n    在用户选择展示在`UIActivityViewController`中的自定义服务的图标之后，调用自定义服务处理方法之前的准备工作，都需要在这个方法中指定，比如可以根据数据展示一个界面来获取用户指定的额外数据信息\n    \n6.activityCategory\n\n    {% codeblock lang:objc %}\n    + (UIActivityCategory)activityCategory NS_AVAILABLE_IOS(7_0); //       default is UIActivityCategoryAction.\n    {% endcodeblock %}\n  `UIActivityViewController`中的服务分为了俩种，`   UIActivityCategoryAction`和` UIActivityCategoryShare,``UIActivityCategoryAction`表示在最下面一栏的操作型服务,比如`Copy`、`Print`;`UIActivityCategoryShare`表示在中间一栏的分享型服务，比如一些社交软件。\n\n7.performActivity\n    {% codeblock lang:objc %}\n    - (void)performActivity; // if no view controller, this method is called. call activityDidFinish when done. default calls [self activityDidFinish:NO]\n    {% endcodeblock %}\n     在用户选择展示在`UIActivityViewController`中的自定义服务的图标之后，而且也调用了`prepareWithActivityItems:`,就会调用这个方法执行具体的服务操作\n\n需要的方法都重写好之后，运行程序，点击Button，就可以看到我们自定义的服务图标显示在了`UIActivityViewController`中。\n\n{% img /images/自定义UIActivity.png %}\n\n# 补充之AirDrop\n前面一直提到`AirDrop`,我们在这里额外补充一下`AirDrop`的相关知识点。`AirDrop`是在`iOS 7`中提供的，实现跨设备传输文档的功能。`AirDrop`的实现基于蓝牙创建一种类似WIFI的”点对点网络“，然后实现跨设备传输功能。\n\n只是`AirDrop`的传输是有限制的，我们可以在我们的App中通过`AirDrop`传送内容，却不能实现通过`AirDrop`接收内容，因为，苹果把设备上通过`AirDrop`接收到的内容都放到了自家App上，比如仅仅传送文字时，在接收设备上就会通过`Notes`打开；如果传送图片，在接收设备上就会保存到`Photos`应用中；通过URL传送文件，在接收设备上就会通过`Safari`打开。\n\n只要是有`UIDocumentInteractionController`和`UIActivityViewController`展示的地方，都可以展示`AirDrop`功能。关于`AirDrop`如何连接设备，如何传送，可以到百度经验找完美得教程。","source":"_posts/通过UIActivityViewController实现更多分享服务.md","raw":"---\nlayout: post\ntitle: 通过UIActivityViewController实现更多分享服务\ndate: 2015-12-15\ndescription: \"介绍UIActivityViewController以及如何在iOS系统上实现跨App之间的内容分享\"\ntags: [UTI]\ncategories: [iOS]\n---\n# 前言\n我在[通过UIDocumentInteractionController预览和分享\"史蒂夫•乔布斯传\"](http://www.jianshu.com/p/3f03897cf98a)这篇文章中，详细讲了`UIDocumentInteractionController`的用途和使用方法。而在`iOS 6 SDK`中,苹果提供了`UIActivityViewController`来让我们可以使用更多地服务。这篇文章，我就来介绍一下怎么通过`UIActivityViewController`实现更多地服务。\n<!-- more -->\n# 简介\n打开`UIActivityViewController`的API文档，我们可以看到`UIActivityViewController`的声明。\n{% codeblock lang:objc %}\nNS_CLASS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED @interface UIActivityViewController : UIViewController\n{% endcodeblock %}\n\n我们可以看出`UIActivityViewController`是在`iOS 6`开始支持的，同样是不能在Apple TV的开发中使用。而且`UIActivityViewController`是直接继承`UIViewController`的，这意味着我们需要自己来展示和解散视图。\n\n# 准备\n我使用在`UIDocumentInteractionController`测试中使用的Demo,GitHub地址是：[ZSDocumentInteractionTest](https://github.com/SeraZheng/ZSDocumentInteractionTest)。然后添加一个新的Button作为`UIActivityViewController`的触发事件，运行程序，就可以看到下面的界面啦(过程自行想象，哈哈)\n\n{% img /images/展示俩个Button.png %}\n\n# 初始化\n接着我们在Button的触发方法里面开始操作`UIActivityViewController`来提供服务。首先，我们需要初始化一个`UIActivityViewController`的实例，`UIActivityViewController`提供了一个初始化方法：\n{% codeblock lang:objc %}\n- (instancetype)initWithActivityItems:(NSArray *)activityItems applicationActivities:(nullable NSArray<__kindof UIActivity *> *)applicationActivities NS_DESIGNATED_INITIALIZER;\n{% endcodeblock %}\n\n官方文档对这俩个参数有详细的解释：\n\n|      参数                  |    描述 |\n|:-----------------|:-----|\n|activityItems\t|The array of data objects on which to perform the activity. The type of objects in the array is variable and dependent on the data your application manages. For example, the data might consist of one or more string or image objects representing the currently selected content.     Instead of actual data objects, the objects in this array can be objects that adopt the UIActivityItemSource protocol, such as UIActivityItemProvider objects. Source and provider objects act as proxies for the corresponding data in situations where you do not want to provide that data until it is needed. Note that you should not resuse an activity view controller object that includes a UIActivityItemProvider object in its activityItems array.This array must not be nil and must contain at least one object.|\n|applicationActivities |An array of UIActivity objects representing the custom services that your application supports. This parameter may be nil.|\n\n\n大概意思是这个方法接收俩个数组类型的参数，第一个数组内的对象代表的是我们想要操作的数据的一些表征，而且这个数组至少需要一个值，比如我们PDF文档的名称，URL；第二个数组指定了`泛型`，数组内的对象必须是`UIActivity`类型的对象，代表的是iOS系统支持的我们自定义的服务，关于这点我在后面`自定义UIActivity服务`的内容中会讲解，现在我们暂时置为`nil`。代码如下：\n{% codeblock lang:objc %}\n- (IBAction)presentPDFActivityView:(id)sender {\n    UIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[@\"Steve Jobs by waiter lsaacson\", [[NSBundle mainBundle] URLForResource:@\"Steve\" withExtension:@\"pdf\"]] applicationActivities:nil];\n{% endcodeblock %}\n# 视图展示\n`UIActivityViewController`是直接继承`UIViewController`的，看到这，你想象可以通过自己的需求来使用不同的方式展示`UIActivityViewController`啦，然而事与愿违。\n\n>官方文档中是这么说的: “When presenting the view controller, you must do so using the appropriate means for the current device. On iPad, you must present the view controller in a popover. On iPhone and iPod touch, you must present it modally”。 大概意思是说，展示`UIActivityViewController`的时候需要根据当前的设备类型选择合适的展示方式，在iPad设备上就必须在'popover'视图里面展示，在其他设备上，必须以模态视图展示。\n\n个人认为开发必须持怀疑和验证的态度，所以我尝试在一个`UINavigationController`中push一个`UIActivityController`,代码如下：\n{% codeblock lang:objc %}\n- (IBAction)presentPDFActivityView:(id)sender {\n    \n    UIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[@\"Steve Jobs by waiter lsaacson\", [[NSBundle mainBundle] URLForResource:@\"Steve\" withExtension:@\"pdf\"]] applicationActivities:nil];\n    [self.navigationController pushViewController:activity animated:YES];\n}\n{% endcodeblock %}\n\n然后运行程序，点击Button，意料之中程序崩溃掉了，给出我们的错误反馈是：\n{% codeblock lang:bash %}\n2015-12-31 15:03:03.733 ZSDocumentInteractionTest[9307:971136] *** Terminating app due to uncaught exception 'NSGenericException', reason: 'UIActivityViewController can only be used modally or as contentViewController in popover on iPad.'\n*** First throw call stack:\n(\n\t0   CoreFoundation                      0x0000000103197e65 __exceptionPreprocess + 165\n\t1   libobjc.A.dylib                     0x0000000102c10deb objc_exception_throw + 48\n\t2   CoreFoundation                      0x0000000103197d9d +[NSException raise:format:] + 205\n\t3   UIKit                               0x0000000103e68e55 -[UIActivityViewController viewDidAppear:] + 533\n\t4   UIKit                               0x00000001036e0949 -[UIViewController _setViewAppearState:isAnimating:] + 830\n\t5   UIKit                               0x00000001036e12cc -[UIViewController _endAppearanceTransition:] + 262\n\t6   UIKit                               0x000000010371bf63 -[UINavigationController navigationTransitionView:didEndTransition:fromView:toView:] + 1290\n\t7   UIKit                               0x0000000103711d24 __49-[UINavigationController _startCustomTransition:]_block_invoke + 233\n\t8   UIKit                               0x0000000103f4ad20 -[_UIViewControllerTransitionContext completeTransition:] + 101\n\t9   UIKit                               0x000000010352cfff __53-[_UINavigationParallaxTransition animateTransition:]_block_invoke95 + 834\n\t10  UIKit                               0x00000001035f1076 -[UIViewAnimationBlockDelegate _didEndBlockAnimation:finished:context:] + 644\n\t11  UIKit                               0x00000001035ce2af -[UIViewAnimationState sendDelegateAnimationDidStop:finished:] + 241\n\t12  UIKit                               0x00000001035ce65e -[UIViewAnimationState animationDidStop:finished:] + 80\n\t13  QuartzCore                          0x00000001070c2fa0 _ZN2CA5Layer23run_animation_callbacksEPv + 308\n\t14  libdispatch.dylib                   0x000000010589f49b _dispatch_client_callout + 8\n\t15  libdispatch.dylib                   0x00000001058872af _dispatch_main_queue_callback_4CF + 1738\n\t16  CoreFoundation                      0x00000001030f7d09 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9\n\t17  CoreFoundation                      0x00000001030b92c9 __CFRunLoopRun + 2073\n\t18  CoreFoundation                      0x00000001030b8828 CFRunLoopRunSpecific + 488\n\t19  GraphicsServices                    0x0000000106954ad2 GSEventRunModal + 161\n\t20  UIKit                               0x0000000103544610 UIApplicationMain + 171\n\t21  ZSDocumentInteractionTest           0x000000010270b6af main + 111\n\t22  libdyld.dylib                       0x00000001058d392d start + 1\n)\nlibc++abi.dylib: terminating with uncaught exception of type NSException\n(lldb) \n{% endcodeblock %}\n\n我们看出错误说明是`\"UIActivityViewController can only be used modally or as contentViewController in popover on iPad.\"`因此我们需要更换一下展示方法，在手机上已一个模态视图的方式展示，而在iPad上则作为`popover`的内容视图展示。代码如下：\n{% codeblock lang:objc %}\n- (IBAction)presentPDFActivityView:(id)sender {\n    \n    UIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[[[NSBundle mainBundle] URLForResource:@\"Steve\" withExtension:@\"pdf\"]] applicationActivities:@[[[ZSCustomActivity alloc] init]]];\n    activity.excludedActivityTypes = @[UIActivityTypeAirDrop];\n    \n    // incorrect usage\n    // [self.navigationController pushViewController:activity animated:YES];\n    \n    UIPopoverPresentationController *popover = activity.popoverPresentationController;\n    if (popover) {\n        popover.sourceView = self.activityButton;\n        popover.permittedArrowDirections = UIPopoverArrowDirectionUp;\n    }\n    \n    [self presentViewController:activity animated:YES completion:NULL];\n}\n{% endcodeblock %}\n再次运行代码，点击Button，就可以看到下面的界面啦(完美展示)\n\n{% img /images/展示UIActivityViewController.png %}\n\n然后我们就可以选择服务来操作和分享`史蒂夫•乔布斯传`啦。\n\n# excludedActivityTypes\n`UIActivityViewController`相比于`UIDocumentInteractionController`优势除了可以添加额外的自定义服务，它还提供了非常好的原生服务的定制化功能。我们可以完全根据自己的需求，控制`UIActivityViewController`提供的系统服务的显示，比如我不想展示`AirDrop`这个功能，而这点在`UIDocumentInteractionController`是做不到的。想做到这一点，就需要使用到`UIActivityViewController`提供的一个属性:\n{% codeblock lang:objc %}\n@property(nullable, nonatomic, copy) NSArray<NSString *> *excludedActivityTypes; // default is nil. activity types listed will not be displayed\n{% endcodeblock %}\n\n正如注释中提到的，`excludedActivityTypes`这个属性包含了所有不想在`UIActivityViewController`中展示的Item服务。`excludedActivityTypes`是一个字符串数组，所包含的内容必须是系统提供的`UIActivity`的`activityType`字符串，而系统提供的字符串如下：\n{% codeblock lang:objc %}\nNSString *const UIActivityTypePostToFacebook;\nNSString *const UIActivityTypePostToTwitter;\nNSString *const UIActivityTypePostToWeibo;\nNSString *const UIActivityTypeMessage;\nNSString *const UIActivityTypeMail;\nNSString *const UIActivityTypePrint;\nNSString *const UIActivityTypeCopyToPasteboard;\nNSString *const UIActivityTypeAssignToContact;\nNSString *const UIActivityTypeSaveToCameraRoll;\nNSString *const UIActivityTypeAddToReadingList;\nNSString *const UIActivityTypePostToFlickr;\nNSString *const UIActivityTypePostToVimeo;\nNSString *const UIActivityTypePostToTencentWeibo;\nNSString *const UIActivityTypeAirDrop;\n{% endcodeblock %}\n如果我们不想展示`AirDrop`功能，我们把`UIActivityTypeAirDrop`添加到`excludedActivityTypes`里面：\n{% codeblock lang:objc %}\nactivity.excludedActivityTypes = @[UIActivityTypeAirDrop];\n{% endcodeblock %}\n运行程序，点击Button，我们可以看到下面的界面发生的变化。\n\n{% img /images/隐藏AirDrop.png %}\n\n# 自定义UIActivity服务\n`UIActivityViewController`相比于`UIDocumentInteractionController`的最大优势就是`UIActivityViewController`所提供的自定义服务，我们可以通过`UIActivity`在`UIActivityViewController`上添加我们自定义的服务。\n\n>官方文档上对UIActivity有一段解释，\"This class must be subclassed before it can be used. The job of an activity object is to act on the data provided to it and to provide some meta information that iOS can display to the user. For more complex services, an activity object can also display a custom user interface and use it to gather additional information from the user.\"。其大概意思是，UIActivity必须通过继承来使用，它主要是操作给用户展示的信息，而且还可以操作展示定制化的界面来获取更多地数据信息。\n\n现在我们打算自定义一个叫`ZS Custom`的服务，所以我们创建一个`ZSCustomActivity`得类来继承`UIActivity`，除此之外，我们必须重写下面的几个方法:\n\n1.activityType\n    {% codeblock lang:objc %}\n    - (nullable NSString *)activityType;       // default returns nil. subclass may override to return custom activity type that is reported to completion handler\n    {% endcodeblock %}\n    这是用来标识自定义服务的一个字符串,而系统提供的服务的标识在上面我们已经提到了；为了迎合iOS SDK中的规范，我给它返回一个`UIActivityTypeZSCustomMine`，定义如下：\n    {% codeblock lang:objc %}\n    NSString *const UIActivityTypeZSCustomMine = @\"ZSCustomActivityMine\";\n\n    - (NSString *)activityType\n    {\n        return UIActivityTypeZSCustomMine;\n    }\n    {% endcodeblock %}\n    \n2.activityTitle\n    {% codeblock lang:objc %}\n    - (nullable NSString *)activityTitle;      // default returns nil. subclass must override and must return non-nil value\n    {% endcodeblock %}\n    \n    在`UIActivityViewController`中给用户展示的服务的名称，比如上面图片中的`\"Copy\"`,`\"Print\"`,我们自定义的服务名称为`ZS Custom`：\n    \n    {% codeblock lang:objc %}\n    - (NSString *)activityTitle\n    {\n        //国际化\n        return NSLocalizedString(@\"ZS Custom\", @\"\");\n    }\n    {% endcodeblock %}\n    \n3.activityImage\n    {% codeblock lang:objc %}\n    - (nullable UIImage *)activityImage;       // default returns nil. subclass must override and must return non-nil value\n    {% endcodeblock %}\n    \n    在`UIActivityViewController`中给用户展示的服务的图标。关于这里的图标，有非常严格的限制：\n    \n    * 首先是图标的背景色，这里推荐最好的完全透明的背景色。\n    \n    >官方文档中是这么解释的，\"The alpha channel of the image is used as a mask to generate the final image that is presented to the user. Any color data in the image itself is ignored. Opaque pixels have a gradient applied to them and this gradient is then laid on top of a standard background. Thus, a completely opaque image would yield a gradient filled rectangle\",意思大概是，在这里颜色数据会被忽略，而透明图层会被当做mask(蒙版图层)，不透明的图片会显示成渐进色填充。\n\n    * 其次是图标的尺寸，在不同的设备需要不同的尺寸，因此需要准备一套图标。\n\n|Device |iOS Version  |Icon Size(pt) |\n|:-----|:---------: |:-------:|\n|iPhone、iPod Touch|iOS 6|< 43x43|\n|iPhone、iPod Touch|iOS 7+|60x60|\n|iPad|iOS 6| < 60x60|\n|iPad|iOS 7+|76x76|\n|Retina| All| @2x|\n    \n4.canPerformWithActivityItems:\n    {% codeblock lang:objc %}\n    - (BOOL)canPerformWithActivityItems:(NSArray *)activityItems;   // override this to return availability of activity based on items. default returns NO\n\n    {% endcodeblock %}\n     指定可以处理的数据类型，如果可以处理则返回`YES`\n     \n5.prepareWithActivityItems:\n    {% codeblock lang:objc %}\n    - (void)prepareWithActivityItems:(NSArray *)activityItems;      // override to extract items and set up your HI. default does nothing\n    {% endcodeblock %}\n    在用户选择展示在`UIActivityViewController`中的自定义服务的图标之后，调用自定义服务处理方法之前的准备工作，都需要在这个方法中指定，比如可以根据数据展示一个界面来获取用户指定的额外数据信息\n    \n6.activityCategory\n\n    {% codeblock lang:objc %}\n    + (UIActivityCategory)activityCategory NS_AVAILABLE_IOS(7_0); //       default is UIActivityCategoryAction.\n    {% endcodeblock %}\n  `UIActivityViewController`中的服务分为了俩种，`   UIActivityCategoryAction`和` UIActivityCategoryShare,``UIActivityCategoryAction`表示在最下面一栏的操作型服务,比如`Copy`、`Print`;`UIActivityCategoryShare`表示在中间一栏的分享型服务，比如一些社交软件。\n\n7.performActivity\n    {% codeblock lang:objc %}\n    - (void)performActivity; // if no view controller, this method is called. call activityDidFinish when done. default calls [self activityDidFinish:NO]\n    {% endcodeblock %}\n     在用户选择展示在`UIActivityViewController`中的自定义服务的图标之后，而且也调用了`prepareWithActivityItems:`,就会调用这个方法执行具体的服务操作\n\n需要的方法都重写好之后，运行程序，点击Button，就可以看到我们自定义的服务图标显示在了`UIActivityViewController`中。\n\n{% img /images/自定义UIActivity.png %}\n\n# 补充之AirDrop\n前面一直提到`AirDrop`,我们在这里额外补充一下`AirDrop`的相关知识点。`AirDrop`是在`iOS 7`中提供的，实现跨设备传输文档的功能。`AirDrop`的实现基于蓝牙创建一种类似WIFI的”点对点网络“，然后实现跨设备传输功能。\n\n只是`AirDrop`的传输是有限制的，我们可以在我们的App中通过`AirDrop`传送内容，却不能实现通过`AirDrop`接收内容，因为，苹果把设备上通过`AirDrop`接收到的内容都放到了自家App上，比如仅仅传送文字时，在接收设备上就会通过`Notes`打开；如果传送图片，在接收设备上就会保存到`Photos`应用中；通过URL传送文件，在接收设备上就会通过`Safari`打开。\n\n只要是有`UIDocumentInteractionController`和`UIActivityViewController`展示的地方，都可以展示`AirDrop`功能。关于`AirDrop`如何连接设备，如何传送，可以到百度经验找完美得教程。","slug":"通过UIActivityViewController实现更多分享服务","published":1,"updated":"2016-04-12T06:52:53.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9uy002e94suugchanxc","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>我在<a href=\"http://www.jianshu.com/p/3f03897cf98a\" target=\"_blank\" rel=\"external\">通过UIDocumentInteractionController预览和分享”史蒂夫•乔布斯传”</a>这篇文章中，详细讲了<code>UIDocumentInteractionController</code>的用途和使用方法。而在<code>iOS 6 SDK</code>中,苹果提供了<code>UIActivityViewController</code>来让我们可以使用更多地服务。这篇文章，我就来介绍一下怎么通过<code>UIActivityViewController</code>实现更多地服务。<br><a id=\"more\"></a></p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>打开<code>UIActivityViewController</code>的API文档，我们可以看到<code>UIActivityViewController</code>的声明。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NS_CLASS_AVAILABLE_IOS</span>(<span class=\"number\">6</span>_0) __TVOS_PROHIBITED <span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIActivityViewController</span> : <span class=\"title\">UIViewController</span></span></span><br></pre></td></tr></table></figure></p>\n<p>我们可以看出<code>UIActivityViewController</code>是在<code>iOS 6</code>开始支持的，同样是不能在Apple TV的开发中使用。而且<code>UIActivityViewController</code>是直接继承<code>UIViewController</code>的，这意味着我们需要自己来展示和解散视图。</p>\n<h1 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h1><p>我使用在<code>UIDocumentInteractionController</code>测试中使用的Demo,GitHub地址是：<a href=\"https://github.com/SeraZheng/ZSDocumentInteractionTest\" target=\"_blank\" rel=\"external\">ZSDocumentInteractionTest</a>。然后添加一个新的Button作为<code>UIActivityViewController</code>的触发事件，运行程序，就可以看到下面的界面啦(过程自行想象，哈哈)</p>\n<img src=\"/images/展示俩个Button.png\">\n<h1 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h1><p>接着我们在Button的触发方法里面开始操作<code>UIActivityViewController</code>来提供服务。首先，我们需要初始化一个<code>UIActivityViewController</code>的实例，<code>UIActivityViewController</code>提供了一个初始化方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithActivityItems:(<span class=\"built_in\">NSArray</span> *)activityItems applicationActivities:(nullable <span class=\"built_in\">NSArray</span>&lt;__kindof <span class=\"built_in\">UIActivity</span> *&gt; *)applicationActivities <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure></p>\n<p>官方文档对这俩个参数有详细的解释：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">activityItems</td>\n<td style=\"text-align:left\">The array of data objects on which to perform the activity. The type of objects in the array is variable and dependent on the data your application manages. For example, the data might consist of one or more string or image objects representing the currently selected content.     Instead of actual data objects, the objects in this array can be objects that adopt the UIActivityItemSource protocol, such as UIActivityItemProvider objects. Source and provider objects act as proxies for the corresponding data in situations where you do not want to provide that data until it is needed. Note that you should not resuse an activity view controller object that includes a UIActivityItemProvider object in its activityItems array.This array must not be nil and must contain at least one object.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">applicationActivities</td>\n<td style=\"text-align:left\">An array of UIActivity objects representing the custom services that your application supports. This parameter may be nil.</td>\n</tr>\n</tbody>\n</table>\n<p>大概意思是这个方法接收俩个数组类型的参数，第一个数组内的对象代表的是我们想要操作的数据的一些表征，而且这个数组至少需要一个值，比如我们PDF文档的名称，URL；第二个数组指定了<code>泛型</code>，数组内的对象必须是<code>UIActivity</code>类型的对象，代表的是iOS系统支持的我们自定义的服务，关于这点我在后面<code>自定义UIActivity服务</code>的内容中会讲解，现在我们暂时置为<code>nil</code>。代码如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)presentPDFActivityView:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIActivityViewController</span> *activity = [[<span class=\"built_in\">UIActivityViewController</span> alloc] initWithActivityItems:@[<span class=\"string\">@\"Steve Jobs by waiter lsaacson\"</span>, [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Steve\"</span> withExtension:<span class=\"string\">@\"pdf\"</span>]] applicationActivities:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"视图展示\"><a href=\"#视图展示\" class=\"headerlink\" title=\"视图展示\"></a>视图展示</h1><p><code>UIActivityViewController</code>是直接继承<code>UIViewController</code>的，看到这，你想象可以通过自己的需求来使用不同的方式展示<code>UIActivityViewController</code>啦，然而事与愿违。</p>\n<blockquote>\n<p>官方文档中是这么说的: “When presenting the view controller, you must do so using the appropriate means for the current device. On iPad, you must present the view controller in a popover. On iPhone and iPod touch, you must present it modally”。 大概意思是说，展示<code>UIActivityViewController</code>的时候需要根据当前的设备类型选择合适的展示方式，在iPad设备上就必须在’popover’视图里面展示，在其他设备上，必须以模态视图展示。</p>\n</blockquote>\n<p>个人认为开发必须持怀疑和验证的态度，所以我尝试在一个<code>UINavigationController</code>中push一个<code>UIActivityController</code>,代码如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)presentPDFActivityView:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">UIActivityViewController</span> *activity = [[<span class=\"built_in\">UIActivityViewController</span> alloc] initWithActivityItems:@[<span class=\"string\">@\"Steve Jobs by waiter lsaacson\"</span>, [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Steve\"</span> withExtension:<span class=\"string\">@\"pdf\"</span>]] applicationActivities:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.navigationController pushViewController:activity animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后运行程序，点击Button，意料之中程序崩溃掉了，给出我们的错误反馈是：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2015-12-31 15:03:03.733 ZSDocumentInteractionTest[9307:971136] *** Terminating app due to uncaught exception <span class=\"string\">'NSGenericException'</span>, reason: <span class=\"string\">'UIActivityViewController can only be used modally or as contentViewController in popover on iPad.'</span></span><br><span class=\"line\">*** First throw call stack:</span><br><span class=\"line\">(</span><br><span class=\"line\">\t0   CoreFoundation                      0x0000000103197e65 __exceptionPreprocess + 165</span><br><span class=\"line\">\t1   libobjc.A.dylib                     0x0000000102c10deb objc_exception_throw + 48</span><br><span class=\"line\">\t2   CoreFoundation                      0x0000000103197d9d +[NSException raise:format:] + 205</span><br><span class=\"line\">\t3   UIKit                               0x0000000103e68e55 -[UIActivityViewController viewDidAppear:] + 533</span><br><span class=\"line\">\t4   UIKit                               0x00000001036e0949 -[UIViewController _<span class=\"built_in\">set</span>ViewAppearState:isAnimating:] + 830</span><br><span class=\"line\">\t5   UIKit                               0x00000001036e12cc -[UIViewController _endAppearanceTransition:] + 262</span><br><span class=\"line\">\t6   UIKit                               0x000000010371bf63 -[UINavigationController navigationTransitionView:didEndTransition:fromView:toView:] + 1290</span><br><span class=\"line\">\t7   UIKit                               0x0000000103711d24 __49-[UINavigationController _startCustomTransition:]_block_invoke + 233</span><br><span class=\"line\">\t8   UIKit                               0x0000000103f4ad20 -[_UIViewControllerTransitionContext completeTransition:] + 101</span><br><span class=\"line\">\t9   UIKit                               0x000000010352cfff __53-[_UINavigationParallaxTransition animateTransition:]_block_invoke95 + 834</span><br><span class=\"line\">\t10  UIKit                               0x00000001035f1076 -[UIViewAnimationBlockDelegate _didEndBlockAnimation:finished:context:] + 644</span><br><span class=\"line\">\t11  UIKit                               0x00000001035ce2af -[UIViewAnimationState sendDelegateAnimationDidStop:finished:] + 241</span><br><span class=\"line\">\t12  UIKit                               0x00000001035ce65e -[UIViewAnimationState animationDidStop:finished:] + 80</span><br><span class=\"line\">\t13  QuartzCore                          0x00000001070c2fa0 _ZN2CA5Layer23run_animation_callbacksEPv + 308</span><br><span class=\"line\">\t14  libdispatch.dylib                   0x000000010589f49b _dispatch_client_callout + 8</span><br><span class=\"line\">\t15  libdispatch.dylib                   0x00000001058872af _dispatch_main_queue_callback_4CF + 1738</span><br><span class=\"line\">\t16  CoreFoundation                      0x00000001030f7d09 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9</span><br><span class=\"line\">\t17  CoreFoundation                      0x00000001030b92c9 __CFRunLoopRun + 2073</span><br><span class=\"line\">\t18  CoreFoundation                      0x00000001030b8828 CFRunLoopRunSpecific + 488</span><br><span class=\"line\">\t19  GraphicsServices                    0x0000000106954ad2 GSEventRunModal + 161</span><br><span class=\"line\">\t20  UIKit                               0x0000000103544610 UIApplicationMain + 171</span><br><span class=\"line\">\t21  ZSDocumentInteractionTest           0x000000010270b6af main + 111</span><br><span class=\"line\">\t22  libdyld.dylib                       0x00000001058d392d start + 1</span><br><span class=\"line\">)</span><br><span class=\"line\">libc++abi.dylib: terminating with uncaught exception of <span class=\"built_in\">type</span> NSException</span><br><span class=\"line\">(lldb) </span><br></pre></td></tr></table></figure></p>\n<p>我们看出错误说明是<code>&quot;UIActivityViewController can only be used modally or as contentViewController in popover on iPad.&quot;</code>因此我们需要更换一下展示方法，在手机上已一个模态视图的方式展示，而在iPad上则作为<code>popover</code>的内容视图展示。代码如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)presentPDFActivityView:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">UIActivityViewController</span> *activity = [[<span class=\"built_in\">UIActivityViewController</span> alloc] initWithActivityItems:@[[[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Steve\"</span> withExtension:<span class=\"string\">@\"pdf\"</span>]] applicationActivities:@[[[ZSCustomActivity alloc] init]]];</span><br><span class=\"line\">    activity.excludedActivityTypes = @[<span class=\"built_in\">UIActivityTypeAirDrop</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// incorrect usage</span></span><br><span class=\"line\">    <span class=\"comment\">// [self.navigationController pushViewController:activity animated:YES];</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">UIPopoverPresentationController</span> *popover = activity.popoverPresentationController;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (popover) &#123;</span><br><span class=\"line\">        popover.sourceView = <span class=\"keyword\">self</span>.activityButton;</span><br><span class=\"line\">        popover.permittedArrowDirections = <span class=\"built_in\">UIPopoverArrowDirectionUp</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> presentViewController:activity animated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">NULL</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>再次运行代码，点击Button，就可以看到下面的界面啦(完美展示)</p>\n<img src=\"/images/展示UIActivityViewController.png\">\n<p>然后我们就可以选择服务来操作和分享<code>史蒂夫•乔布斯传</code>啦。</p>\n<h1 id=\"excludedActivityTypes\"><a href=\"#excludedActivityTypes\" class=\"headerlink\" title=\"excludedActivityTypes\"></a>excludedActivityTypes</h1><p><code>UIActivityViewController</code>相比于<code>UIDocumentInteractionController</code>优势除了可以添加额外的自定义服务，它还提供了非常好的原生服务的定制化功能。我们可以完全根据自己的需求，控制<code>UIActivityViewController</code>提供的系统服务的显示，比如我不想展示<code>AirDrop</code>这个功能，而这点在<code>UIDocumentInteractionController</code>是做不到的。想做到这一点，就需要使用到<code>UIActivityViewController</code>提供的一个属性:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span>(nullable, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *excludedActivityTypes; <span class=\"comment\">// default is nil. activity types listed will not be displayed</span></span><br></pre></td></tr></table></figure></p>\n<p>正如注释中提到的，<code>excludedActivityTypes</code>这个属性包含了所有不想在<code>UIActivityViewController</code>中展示的Item服务。<code>excludedActivityTypes</code>是一个字符串数组，所包含的内容必须是系统提供的<code>UIActivity</code>的<code>activityType</code>字符串，而系统提供的字符串如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePostToFacebook</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePostToTwitter</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePostToWeibo</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeMessage</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeMail</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePrint</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeCopyToPasteboard</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeAssignToContact</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeSaveToCameraRoll</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeAddToReadingList</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePostToFlickr</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePostToVimeo</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePostToTencentWeibo</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeAirDrop</span>;</span><br></pre></td></tr></table></figure><br>如果我们不想展示<code>AirDrop</code>功能，我们把<code>UIActivityTypeAirDrop</code>添加到<code>excludedActivityTypes</code>里面：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">activity.excludedActivityTypes = @[<span class=\"built_in\">UIActivityTypeAirDrop</span>];</span><br></pre></td></tr></table></figure><br>运行程序，点击Button，我们可以看到下面的界面发生的变化。</p>\n<img src=\"/images/隐藏AirDrop.png\">\n<h1 id=\"自定义UIActivity服务\"><a href=\"#自定义UIActivity服务\" class=\"headerlink\" title=\"自定义UIActivity服务\"></a>自定义UIActivity服务</h1><p><code>UIActivityViewController</code>相比于<code>UIDocumentInteractionController</code>的最大优势就是<code>UIActivityViewController</code>所提供的自定义服务，我们可以通过<code>UIActivity</code>在<code>UIActivityViewController</code>上添加我们自定义的服务。</p>\n<blockquote>\n<p>官方文档上对UIActivity有一段解释，”This class must be subclassed before it can be used. The job of an activity object is to act on the data provided to it and to provide some meta information that iOS can display to the user. For more complex services, an activity object can also display a custom user interface and use it to gather additional information from the user.”。其大概意思是，UIActivity必须通过继承来使用，它主要是操作给用户展示的信息，而且还可以操作展示定制化的界面来获取更多地数据信息。</p>\n</blockquote>\n<p>现在我们打算自定义一个叫<code>ZS Custom</code>的服务，所以我们创建一个<code>ZSCustomActivity</code>得类来继承<code>UIActivity</code>，除此之外，我们必须重写下面的几个方法:</p>\n<p>1.activityType<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable <span class=\"built_in\">NSString</span> *)activityType;       <span class=\"comment\">// default returns nil. subclass may override to return custom activity type that is reported to completion handler</span></span><br></pre></td></tr></table></figure><br>    这是用来标识自定义服务的一个字符串,而系统提供的服务的标识在上面我们已经提到了；为了迎合iOS SDK中的规范，我给它返回一个<code>UIActivityTypeZSCustomMine</code>，定义如下：<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeZSCustomMine</span> = <span class=\"string\">@\"ZSCustomActivityMine\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)activityType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">UIActivityTypeZSCustomMine</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.activityTitle<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable <span class=\"built_in\">NSString</span> *)activityTitle;      <span class=\"comment\">// default returns nil. subclass must override and must return non-nil value</span></span><br></pre></td></tr></table></figure></p>\n<pre><code>在`UIActivityViewController`中给用户展示的服务的名称，比如上面图片中的`&quot;Copy&quot;`,`&quot;Print&quot;`,我们自定义的服务名称为`ZS Custom`：\n\n{% codeblock lang:objc %}\n    - (NSString *)activityTitle\n    {\n        //国际化\n        return NSLocalizedString(@\"ZS Custom\", @\"\");\n    }\n    {% endcodeblock %}\n</code></pre><p>3.activityImage<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable <span class=\"built_in\">UIImage</span> *)activityImage;       <span class=\"comment\">// default returns nil. subclass must override and must return non-nil value</span></span><br></pre></td></tr></table></figure></p>\n<pre><code>在`UIActivityViewController`中给用户展示的服务的图标。关于这里的图标，有非常严格的限制：\n\n* 首先是图标的背景色，这里推荐最好的完全透明的背景色。\n\n&gt;官方文档中是这么解释的，&quot;The alpha channel of the image is used as a mask to generate the final image that is presented to the user. Any color data in the image itself is ignored. Opaque pixels have a gradient applied to them and this gradient is then laid on top of a standard background. Thus, a completely opaque image would yield a gradient filled rectangle&quot;,意思大概是，在这里颜色数据会被忽略，而透明图层会被当做mask(蒙版图层)，不透明的图片会显示成渐进色填充。\n\n* 其次是图标的尺寸，在不同的设备需要不同的尺寸，因此需要准备一套图标。\n</code></pre><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Device</th>\n<th style=\"text-align:center\">iOS Version</th>\n<th style=\"text-align:center\">Icon Size(pt)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">iPhone、iPod Touch</td>\n<td style=\"text-align:center\">iOS 6</td>\n<td style=\"text-align:center\">&lt; 43x43</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">iPhone、iPod Touch</td>\n<td style=\"text-align:center\">iOS 7+</td>\n<td style=\"text-align:center\">60x60</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">iPad</td>\n<td style=\"text-align:center\">iOS 6</td>\n<td style=\"text-align:center\">&lt; 60x60</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">iPad</td>\n<td style=\"text-align:center\">iOS 7+</td>\n<td style=\"text-align:center\">76x76</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Retina</td>\n<td style=\"text-align:center\">All</td>\n<td style=\"text-align:center\">@2x</td>\n</tr>\n</tbody>\n</table>\n<p>4.canPerformWithActivityItems:<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)canPerformWithActivityItems:(<span class=\"built_in\">NSArray</span> *)activityItems;   <span class=\"comment\">// override this to return availability of activity based on items. default returns NO</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>     指定可以处理的数据类型，如果可以处理则返回<code>YES</code></p>\n<p>5.prepareWithActivityItems:<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)prepareWithActivityItems:(<span class=\"built_in\">NSArray</span> *)activityItems;      <span class=\"comment\">// override to extract items and set up your HI. default does nothing</span></span><br></pre></td></tr></table></figure><br>    在用户选择展示在<code>UIActivityViewController</code>中的自定义服务的图标之后，调用自定义服务处理方法之前的准备工作，都需要在这个方法中指定，比如可以根据数据展示一个界面来获取用户指定的额外数据信息</p>\n<p>6.activityCategory</p>\n<pre><code>{% codeblock lang:objc %}\n    + (UIActivityCategory)activityCategory NS_AVAILABLE_IOS(7_0); //       default is UIActivityCategoryAction.\n    {% endcodeblock %}\n</code></pre><p>  <code>UIActivityViewController</code>中的服务分为了俩种，<code>UIActivityCategoryAction</code>和<code>UIActivityCategoryShare,``UIActivityCategoryAction</code>表示在最下面一栏的操作型服务,比如<code>Copy</code>、<code>Print</code>;<code>UIActivityCategoryShare</code>表示在中间一栏的分享型服务，比如一些社交软件。</p>\n<p>7.performActivity<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)performActivity; <span class=\"comment\">// if no view controller, this method is called. call activityDidFinish when done. default calls [self activityDidFinish:NO]</span></span><br></pre></td></tr></table></figure><br>     在用户选择展示在<code>UIActivityViewController</code>中的自定义服务的图标之后，而且也调用了<code>prepareWithActivityItems:</code>,就会调用这个方法执行具体的服务操作</p>\n<p>需要的方法都重写好之后，运行程序，点击Button，就可以看到我们自定义的服务图标显示在了<code>UIActivityViewController</code>中。</p>\n<img src=\"/images/自定义UIActivity.png\">\n<h1 id=\"补充之AirDrop\"><a href=\"#补充之AirDrop\" class=\"headerlink\" title=\"补充之AirDrop\"></a>补充之AirDrop</h1><p>前面一直提到<code>AirDrop</code>,我们在这里额外补充一下<code>AirDrop</code>的相关知识点。<code>AirDrop</code>是在<code>iOS 7</code>中提供的，实现跨设备传输文档的功能。<code>AirDrop</code>的实现基于蓝牙创建一种类似WIFI的”点对点网络“，然后实现跨设备传输功能。</p>\n<p>只是<code>AirDrop</code>的传输是有限制的，我们可以在我们的App中通过<code>AirDrop</code>传送内容，却不能实现通过<code>AirDrop</code>接收内容，因为，苹果把设备上通过<code>AirDrop</code>接收到的内容都放到了自家App上，比如仅仅传送文字时，在接收设备上就会通过<code>Notes</code>打开；如果传送图片，在接收设备上就会保存到<code>Photos</code>应用中；通过URL传送文件，在接收设备上就会通过<code>Safari</code>打开。</p>\n<p>只要是有<code>UIDocumentInteractionController</code>和<code>UIActivityViewController</code>展示的地方，都可以展示<code>AirDrop</code>功能。关于<code>AirDrop</code>如何连接设备，如何传送，可以到百度经验找完美得教程。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>我在<a href=\"http://www.jianshu.com/p/3f03897cf98a\">通过UIDocumentInteractionController预览和分享”史蒂夫•乔布斯传”</a>这篇文章中，详细讲了<code>UIDocumentInteractionController</code>的用途和使用方法。而在<code>iOS 6 SDK</code>中,苹果提供了<code>UIActivityViewController</code>来让我们可以使用更多地服务。这篇文章，我就来介绍一下怎么通过<code>UIActivityViewController</code>实现更多地服务。<br>","more":"</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>打开<code>UIActivityViewController</code>的API文档，我们可以看到<code>UIActivityViewController</code>的声明。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NS_CLASS_AVAILABLE_IOS</span>(<span class=\"number\">6</span>_0) __TVOS_PROHIBITED <span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIActivityViewController</span> : <span class=\"title\">UIViewController</span></span></span><br></pre></td></tr></table></figure></p>\n<p>我们可以看出<code>UIActivityViewController</code>是在<code>iOS 6</code>开始支持的，同样是不能在Apple TV的开发中使用。而且<code>UIActivityViewController</code>是直接继承<code>UIViewController</code>的，这意味着我们需要自己来展示和解散视图。</p>\n<h1 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h1><p>我使用在<code>UIDocumentInteractionController</code>测试中使用的Demo,GitHub地址是：<a href=\"https://github.com/SeraZheng/ZSDocumentInteractionTest\">ZSDocumentInteractionTest</a>。然后添加一个新的Button作为<code>UIActivityViewController</code>的触发事件，运行程序，就可以看到下面的界面啦(过程自行想象，哈哈)</p>\n<img src=\"/images/展示俩个Button.png\">\n<h1 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h1><p>接着我们在Button的触发方法里面开始操作<code>UIActivityViewController</code>来提供服务。首先，我们需要初始化一个<code>UIActivityViewController</code>的实例，<code>UIActivityViewController</code>提供了一个初始化方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithActivityItems:(<span class=\"built_in\">NSArray</span> *)activityItems applicationActivities:(nullable <span class=\"built_in\">NSArray</span>&lt;__kindof <span class=\"built_in\">UIActivity</span> *&gt; *)applicationActivities <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure></p>\n<p>官方文档对这俩个参数有详细的解释：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">activityItems</td>\n<td style=\"text-align:left\">The array of data objects on which to perform the activity. The type of objects in the array is variable and dependent on the data your application manages. For example, the data might consist of one or more string or image objects representing the currently selected content.     Instead of actual data objects, the objects in this array can be objects that adopt the UIActivityItemSource protocol, such as UIActivityItemProvider objects. Source and provider objects act as proxies for the corresponding data in situations where you do not want to provide that data until it is needed. Note that you should not resuse an activity view controller object that includes a UIActivityItemProvider object in its activityItems array.This array must not be nil and must contain at least one object.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">applicationActivities</td>\n<td style=\"text-align:left\">An array of UIActivity objects representing the custom services that your application supports. This parameter may be nil.</td>\n</tr>\n</tbody>\n</table>\n<p>大概意思是这个方法接收俩个数组类型的参数，第一个数组内的对象代表的是我们想要操作的数据的一些表征，而且这个数组至少需要一个值，比如我们PDF文档的名称，URL；第二个数组指定了<code>泛型</code>，数组内的对象必须是<code>UIActivity</code>类型的对象，代表的是iOS系统支持的我们自定义的服务，关于这点我在后面<code>自定义UIActivity服务</code>的内容中会讲解，现在我们暂时置为<code>nil</code>。代码如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)presentPDFActivityView:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIActivityViewController</span> *activity = [[<span class=\"built_in\">UIActivityViewController</span> alloc] initWithActivityItems:@[<span class=\"string\">@\"Steve Jobs by waiter lsaacson\"</span>, [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Steve\"</span> withExtension:<span class=\"string\">@\"pdf\"</span>]] applicationActivities:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"视图展示\"><a href=\"#视图展示\" class=\"headerlink\" title=\"视图展示\"></a>视图展示</h1><p><code>UIActivityViewController</code>是直接继承<code>UIViewController</code>的，看到这，你想象可以通过自己的需求来使用不同的方式展示<code>UIActivityViewController</code>啦，然而事与愿违。</p>\n<blockquote>\n<p>官方文档中是这么说的: “When presenting the view controller, you must do so using the appropriate means for the current device. On iPad, you must present the view controller in a popover. On iPhone and iPod touch, you must present it modally”。 大概意思是说，展示<code>UIActivityViewController</code>的时候需要根据当前的设备类型选择合适的展示方式，在iPad设备上就必须在’popover’视图里面展示，在其他设备上，必须以模态视图展示。</p>\n</blockquote>\n<p>个人认为开发必须持怀疑和验证的态度，所以我尝试在一个<code>UINavigationController</code>中push一个<code>UIActivityController</code>,代码如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)presentPDFActivityView:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">UIActivityViewController</span> *activity = [[<span class=\"built_in\">UIActivityViewController</span> alloc] initWithActivityItems:@[<span class=\"string\">@\"Steve Jobs by waiter lsaacson\"</span>, [[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Steve\"</span> withExtension:<span class=\"string\">@\"pdf\"</span>]] applicationActivities:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.navigationController pushViewController:activity animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后运行程序，点击Button，意料之中程序崩溃掉了，给出我们的错误反馈是：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2015-12-31 15:03:03.733 ZSDocumentInteractionTest[9307:971136] *** Terminating app due to uncaught exception <span class=\"string\">'NSGenericException'</span>, reason: <span class=\"string\">'UIActivityViewController can only be used modally or as contentViewController in popover on iPad.'</span></span><br><span class=\"line\">*** First throw call stack:</span><br><span class=\"line\">(</span><br><span class=\"line\">\t0   CoreFoundation                      0x0000000103197e65 __exceptionPreprocess + 165</span><br><span class=\"line\">\t1   libobjc.A.dylib                     0x0000000102c10deb objc_exception_throw + 48</span><br><span class=\"line\">\t2   CoreFoundation                      0x0000000103197d9d +[NSException raise:format:] + 205</span><br><span class=\"line\">\t3   UIKit                               0x0000000103e68e55 -[UIActivityViewController viewDidAppear:] + 533</span><br><span class=\"line\">\t4   UIKit                               0x00000001036e0949 -[UIViewController _<span class=\"built_in\">set</span>ViewAppearState:isAnimating:] + 830</span><br><span class=\"line\">\t5   UIKit                               0x00000001036e12cc -[UIViewController _endAppearanceTransition:] + 262</span><br><span class=\"line\">\t6   UIKit                               0x000000010371bf63 -[UINavigationController navigationTransitionView:didEndTransition:fromView:toView:] + 1290</span><br><span class=\"line\">\t7   UIKit                               0x0000000103711d24 __49-[UINavigationController _startCustomTransition:]_block_invoke + 233</span><br><span class=\"line\">\t8   UIKit                               0x0000000103f4ad20 -[_UIViewControllerTransitionContext completeTransition:] + 101</span><br><span class=\"line\">\t9   UIKit                               0x000000010352cfff __53-[_UINavigationParallaxTransition animateTransition:]_block_invoke95 + 834</span><br><span class=\"line\">\t10  UIKit                               0x00000001035f1076 -[UIViewAnimationBlockDelegate _didEndBlockAnimation:finished:context:] + 644</span><br><span class=\"line\">\t11  UIKit                               0x00000001035ce2af -[UIViewAnimationState sendDelegateAnimationDidStop:finished:] + 241</span><br><span class=\"line\">\t12  UIKit                               0x00000001035ce65e -[UIViewAnimationState animationDidStop:finished:] + 80</span><br><span class=\"line\">\t13  QuartzCore                          0x00000001070c2fa0 _ZN2CA5Layer23run_animation_callbacksEPv + 308</span><br><span class=\"line\">\t14  libdispatch.dylib                   0x000000010589f49b _dispatch_client_callout + 8</span><br><span class=\"line\">\t15  libdispatch.dylib                   0x00000001058872af _dispatch_main_queue_callback_4CF + 1738</span><br><span class=\"line\">\t16  CoreFoundation                      0x00000001030f7d09 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9</span><br><span class=\"line\">\t17  CoreFoundation                      0x00000001030b92c9 __CFRunLoopRun + 2073</span><br><span class=\"line\">\t18  CoreFoundation                      0x00000001030b8828 CFRunLoopRunSpecific + 488</span><br><span class=\"line\">\t19  GraphicsServices                    0x0000000106954ad2 GSEventRunModal + 161</span><br><span class=\"line\">\t20  UIKit                               0x0000000103544610 UIApplicationMain + 171</span><br><span class=\"line\">\t21  ZSDocumentInteractionTest           0x000000010270b6af main + 111</span><br><span class=\"line\">\t22  libdyld.dylib                       0x00000001058d392d start + 1</span><br><span class=\"line\">)</span><br><span class=\"line\">libc++abi.dylib: terminating with uncaught exception of <span class=\"built_in\">type</span> NSException</span><br><span class=\"line\">(lldb) </span><br></pre></td></tr></table></figure></p>\n<p>我们看出错误说明是<code>&quot;UIActivityViewController can only be used modally or as contentViewController in popover on iPad.&quot;</code>因此我们需要更换一下展示方法，在手机上已一个模态视图的方式展示，而在iPad上则作为<code>popover</code>的内容视图展示。代码如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)presentPDFActivityView:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">UIActivityViewController</span> *activity = [[<span class=\"built_in\">UIActivityViewController</span> alloc] initWithActivityItems:@[[[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Steve\"</span> withExtension:<span class=\"string\">@\"pdf\"</span>]] applicationActivities:@[[[ZSCustomActivity alloc] init]]];</span><br><span class=\"line\">    activity.excludedActivityTypes = @[<span class=\"built_in\">UIActivityTypeAirDrop</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// incorrect usage</span></span><br><span class=\"line\">    <span class=\"comment\">// [self.navigationController pushViewController:activity animated:YES];</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">UIPopoverPresentationController</span> *popover = activity.popoverPresentationController;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (popover) &#123;</span><br><span class=\"line\">        popover.sourceView = <span class=\"keyword\">self</span>.activityButton;</span><br><span class=\"line\">        popover.permittedArrowDirections = <span class=\"built_in\">UIPopoverArrowDirectionUp</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> presentViewController:activity animated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">NULL</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>再次运行代码，点击Button，就可以看到下面的界面啦(完美展示)</p>\n<img src=\"/images/展示UIActivityViewController.png\">\n<p>然后我们就可以选择服务来操作和分享<code>史蒂夫•乔布斯传</code>啦。</p>\n<h1 id=\"excludedActivityTypes\"><a href=\"#excludedActivityTypes\" class=\"headerlink\" title=\"excludedActivityTypes\"></a>excludedActivityTypes</h1><p><code>UIActivityViewController</code>相比于<code>UIDocumentInteractionController</code>优势除了可以添加额外的自定义服务，它还提供了非常好的原生服务的定制化功能。我们可以完全根据自己的需求，控制<code>UIActivityViewController</code>提供的系统服务的显示，比如我不想展示<code>AirDrop</code>这个功能，而这点在<code>UIDocumentInteractionController</code>是做不到的。想做到这一点，就需要使用到<code>UIActivityViewController</code>提供的一个属性:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span>(nullable, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *excludedActivityTypes; <span class=\"comment\">// default is nil. activity types listed will not be displayed</span></span><br></pre></td></tr></table></figure></p>\n<p>正如注释中提到的，<code>excludedActivityTypes</code>这个属性包含了所有不想在<code>UIActivityViewController</code>中展示的Item服务。<code>excludedActivityTypes</code>是一个字符串数组，所包含的内容必须是系统提供的<code>UIActivity</code>的<code>activityType</code>字符串，而系统提供的字符串如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePostToFacebook</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePostToTwitter</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePostToWeibo</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeMessage</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeMail</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePrint</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeCopyToPasteboard</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeAssignToContact</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeSaveToCameraRoll</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeAddToReadingList</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePostToFlickr</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePostToVimeo</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypePostToTencentWeibo</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeAirDrop</span>;</span><br></pre></td></tr></table></figure><br>如果我们不想展示<code>AirDrop</code>功能，我们把<code>UIActivityTypeAirDrop</code>添加到<code>excludedActivityTypes</code>里面：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">activity.excludedActivityTypes = @[<span class=\"built_in\">UIActivityTypeAirDrop</span>];</span><br></pre></td></tr></table></figure><br>运行程序，点击Button，我们可以看到下面的界面发生的变化。</p>\n<img src=\"/images/隐藏AirDrop.png\">\n<h1 id=\"自定义UIActivity服务\"><a href=\"#自定义UIActivity服务\" class=\"headerlink\" title=\"自定义UIActivity服务\"></a>自定义UIActivity服务</h1><p><code>UIActivityViewController</code>相比于<code>UIDocumentInteractionController</code>的最大优势就是<code>UIActivityViewController</code>所提供的自定义服务，我们可以通过<code>UIActivity</code>在<code>UIActivityViewController</code>上添加我们自定义的服务。</p>\n<blockquote>\n<p>官方文档上对UIActivity有一段解释，”This class must be subclassed before it can be used. The job of an activity object is to act on the data provided to it and to provide some meta information that iOS can display to the user. For more complex services, an activity object can also display a custom user interface and use it to gather additional information from the user.”。其大概意思是，UIActivity必须通过继承来使用，它主要是操作给用户展示的信息，而且还可以操作展示定制化的界面来获取更多地数据信息。</p>\n</blockquote>\n<p>现在我们打算自定义一个叫<code>ZS Custom</code>的服务，所以我们创建一个<code>ZSCustomActivity</code>得类来继承<code>UIActivity</code>，除此之外，我们必须重写下面的几个方法:</p>\n<p>1.activityType<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable <span class=\"built_in\">NSString</span> *)activityType;       <span class=\"comment\">// default returns nil. subclass may override to return custom activity type that is reported to completion handler</span></span><br></pre></td></tr></table></figure><br>    这是用来标识自定义服务的一个字符串,而系统提供的服务的标识在上面我们已经提到了；为了迎合iOS SDK中的规范，我给它返回一个<code>UIActivityTypeZSCustomMine</code>，定义如下：<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">UIActivityTypeZSCustomMine</span> = <span class=\"string\">@\"ZSCustomActivityMine\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)activityType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">UIActivityTypeZSCustomMine</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.activityTitle<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable <span class=\"built_in\">NSString</span> *)activityTitle;      <span class=\"comment\">// default returns nil. subclass must override and must return non-nil value</span></span><br></pre></td></tr></table></figure></p>\n<pre><code>在`UIActivityViewController`中给用户展示的服务的名称，比如上面图片中的`&quot;Copy&quot;`,`&quot;Print&quot;`,我们自定义的服务名称为`ZS Custom`：\n\n{% codeblock lang:objc %}\n    - (NSString *)activityTitle\n    {\n        //国际化\n        return NSLocalizedString(@\"ZS Custom\", @\"\");\n    }\n    {% endcodeblock %}\n</code></pre><p>3.activityImage<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable <span class=\"built_in\">UIImage</span> *)activityImage;       <span class=\"comment\">// default returns nil. subclass must override and must return non-nil value</span></span><br></pre></td></tr></table></figure></p>\n<pre><code>在`UIActivityViewController`中给用户展示的服务的图标。关于这里的图标，有非常严格的限制：\n\n* 首先是图标的背景色，这里推荐最好的完全透明的背景色。\n\n&gt;官方文档中是这么解释的，&quot;The alpha channel of the image is used as a mask to generate the final image that is presented to the user. Any color data in the image itself is ignored. Opaque pixels have a gradient applied to them and this gradient is then laid on top of a standard background. Thus, a completely opaque image would yield a gradient filled rectangle&quot;,意思大概是，在这里颜色数据会被忽略，而透明图层会被当做mask(蒙版图层)，不透明的图片会显示成渐进色填充。\n\n* 其次是图标的尺寸，在不同的设备需要不同的尺寸，因此需要准备一套图标。\n</code></pre><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Device</th>\n<th style=\"text-align:center\">iOS Version</th>\n<th style=\"text-align:center\">Icon Size(pt)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">iPhone、iPod Touch</td>\n<td style=\"text-align:center\">iOS 6</td>\n<td style=\"text-align:center\">&lt; 43x43</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">iPhone、iPod Touch</td>\n<td style=\"text-align:center\">iOS 7+</td>\n<td style=\"text-align:center\">60x60</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">iPad</td>\n<td style=\"text-align:center\">iOS 6</td>\n<td style=\"text-align:center\">&lt; 60x60</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">iPad</td>\n<td style=\"text-align:center\">iOS 7+</td>\n<td style=\"text-align:center\">76x76</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Retina</td>\n<td style=\"text-align:center\">All</td>\n<td style=\"text-align:center\">@2x</td>\n</tr>\n</tbody>\n</table>\n<p>4.canPerformWithActivityItems:<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)canPerformWithActivityItems:(<span class=\"built_in\">NSArray</span> *)activityItems;   <span class=\"comment\">// override this to return availability of activity based on items. default returns NO</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>     指定可以处理的数据类型，如果可以处理则返回<code>YES</code></p>\n<p>5.prepareWithActivityItems:<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)prepareWithActivityItems:(<span class=\"built_in\">NSArray</span> *)activityItems;      <span class=\"comment\">// override to extract items and set up your HI. default does nothing</span></span><br></pre></td></tr></table></figure><br>    在用户选择展示在<code>UIActivityViewController</code>中的自定义服务的图标之后，调用自定义服务处理方法之前的准备工作，都需要在这个方法中指定，比如可以根据数据展示一个界面来获取用户指定的额外数据信息</p>\n<p>6.activityCategory</p>\n<pre><code>{% codeblock lang:objc %}\n    + (UIActivityCategory)activityCategory NS_AVAILABLE_IOS(7_0); //       default is UIActivityCategoryAction.\n    {% endcodeblock %}\n</code></pre><p>  <code>UIActivityViewController</code>中的服务分为了俩种，<code>UIActivityCategoryAction</code>和<code>UIActivityCategoryShare,``UIActivityCategoryAction</code>表示在最下面一栏的操作型服务,比如<code>Copy</code>、<code>Print</code>;<code>UIActivityCategoryShare</code>表示在中间一栏的分享型服务，比如一些社交软件。</p>\n<p>7.performActivity<br>    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)performActivity; <span class=\"comment\">// if no view controller, this method is called. call activityDidFinish when done. default calls [self activityDidFinish:NO]</span></span><br></pre></td></tr></table></figure><br>     在用户选择展示在<code>UIActivityViewController</code>中的自定义服务的图标之后，而且也调用了<code>prepareWithActivityItems:</code>,就会调用这个方法执行具体的服务操作</p>\n<p>需要的方法都重写好之后，运行程序，点击Button，就可以看到我们自定义的服务图标显示在了<code>UIActivityViewController</code>中。</p>\n<img src=\"/images/自定义UIActivity.png\">\n<h1 id=\"补充之AirDrop\"><a href=\"#补充之AirDrop\" class=\"headerlink\" title=\"补充之AirDrop\"></a>补充之AirDrop</h1><p>前面一直提到<code>AirDrop</code>,我们在这里额外补充一下<code>AirDrop</code>的相关知识点。<code>AirDrop</code>是在<code>iOS 7</code>中提供的，实现跨设备传输文档的功能。<code>AirDrop</code>的实现基于蓝牙创建一种类似WIFI的”点对点网络“，然后实现跨设备传输功能。</p>\n<p>只是<code>AirDrop</code>的传输是有限制的，我们可以在我们的App中通过<code>AirDrop</code>传送内容，却不能实现通过<code>AirDrop</code>接收内容，因为，苹果把设备上通过<code>AirDrop</code>接收到的内容都放到了自家App上，比如仅仅传送文字时，在接收设备上就会通过<code>Notes</code>打开；如果传送图片，在接收设备上就会保存到<code>Photos</code>应用中；通过URL传送文件，在接收设备上就会通过<code>Safari</code>打开。</p>\n<p>只要是有<code>UIDocumentInteractionController</code>和<code>UIActivityViewController</code>展示的地方，都可以展示<code>AirDrop</code>功能。关于<code>AirDrop</code>如何连接设备，如何传送，可以到百度经验找完美得教程。</p>"},{"layout":"post","title":"详解苹果提供的UTI(统一类型标识符)","date":"2015-11-19T16:00:00.000Z","description":"解释UTI的概念和相关内容","_content":"\n# 前言\n最近项目中有个需求，在iOS设备上使用iOS系统提供的内容分享功能，从第三方App应用直接分享实体内容到我们的应用中。其大概的原理是这样的，首先为我们的iOS应用注册可以打开document types(文档类型)，然后在第三方应用中，如果它们使用了iOS提供的分享功能，那么就会看到我们的应用程序，点击进行分享。\n\n而关于需求的设计和实现的具体思路，我会在下一篇博客中详细讲解。这篇文章是来讲一下在iOS系统中为了更好的进行类型标识，而提供的一套共用的规范，也就是标题中提到的“Uniform Type Identifier(UTI)”，我把它翻译成“统一类型标识符”,下面统一简称为“UTI”。\n<!-- more -->\n# 官方教程\n网上关于UTI的使用教程少之又少，所以我只是参考了苹果官方文档提供的讲解，这篇博客权当是我对于官方文档的一个理解吧！！自认为很重要的部分，我会贴出来官方文档原文，以便于大家学习理解，不至于被我的歪词所误导，同时也推荐大家从开发者中心上搜一些文档来看，这里推荐几篇：\n\n1.[Cocoa Core Competencies -- Uniform Type Identifier‍](https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/UniformTypeIdentifier.html)\n\n这篇文档提供了一个视图来说明UTI是什么，怎么工作和被谁使用，是个非常好的新手指南。\n   \n2.[Uniform Type Identifier介绍和使用‍](https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-BCGCDHIJ)\n\n这篇文档详细得描述了UTI的基础概念和属性，还有它们的使用方法，内容非常丰富，本文主要参考的就是这篇\n\n3.[System-Declared Uniform Type Identifiers‍](https://developer.apple.com/library/ios/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html#//apple_ref/doc/uid/TP40009259-SW1)\n\n这篇文档提供了在OS X系统中定义的一个UTI的列表，我们可以查看每一种官方提供的UTI的定义和涵义。\n\n4.[UTType Reference‍](https://developer.apple.com/library/ios/documentation/MobileCoreServices/Reference/UTTypeRef/index.html#//apple_ref/doc/uid/TP40008771)\n\n这篇文档提供了对UTI字符串直接操作的函数方法\n\n5.[一步一步为iOS应用添加自定义的document type和新的UTI‍](https://developer.apple.com/library/ios/qa/qa1587/_index.html#//apple_ref/doc/uid/DTS40012659)\n\n顾名思义，这篇文档，讲解的是如何在iOS应用中导入新的UTI和添加自定义的document type。\n\n# 为什么会有UTI\n为什么会有UTI，打个比方，它就像是如今世界各国作为官方语言统讲得英文。为什么这么比喻呢，因为中国人讲母语汉语，法国人讲母语法语，但是如果一个中国人到了法国，而又不懂法语，碰到的法国人不懂汉语，那么他们如何交流沟通呢，这就是英文的用武之地了。而相对而言，苹果操作系统相当于整个世界，各个不同的程序或者服务相当于各个国家，俩个不同的程序想要互通交流，就比如互相发送文件，可是一个使用文件扩展名，一个使用MIME类型，俩者的数据类型不同，无法解析，都互相不认识，那么怎么交流沟通呢?在这样的情景下，UTI就有了用武之地啦，它就充当的是现实世界的英文这个角色。\n\n# UTI概念\nUniform type identifiers(UTIs)提供了在整个系统里面标识数据的一个统一的方式，比如documents(文档)、pasteboard data(剪贴板数据)和bundles(包)。\n\n>而具体到UTI的定义，官方文档是这么说的：“A uniform type identifier is a string that uniquely identifies a class of entities considered to have a ‘type’.”。其大概意思是说，一个统一类型标识符是一个唯一标识一种拥有\"类型\"属性实体的字符串。而且，针对这个“type”，官方文档还给我们提出了例子解释，对于一个文件或者是字节流来说，“type”指的的数据类型；而对于packages和bundles来说，“type”指的就是它们内部的目录层级结构。\n\n# UTI用途\n大多数情况下，一个UTI提供的是系统中所有程序和服务都能够识别并且依赖的一个唯一的标识，这么讲可能有些太抽象，我们使用一下官方文档中给出的例子，比如一个JPEG类型的图片文件，在不同的环境下，可以有下面几种不同的标识方法：\n\n>1. ‘JPEG’, OSType表示,\n2. '.jpg', 文件扩展名\n3. '.jpeg', 文件扩展名\n4. 'image/jpeg', MIME(多用途互联网邮件扩展类型)中的一种类型\n\n而UTI则是用‘public.jpeg’这个字符串标识，完全代替了这些不一致的标签，这个字符串和其他任何一个旧标签都是完全兼容的，而且他们之间可以相互转换。由于UTI可以标识任何类型的实体，所以他们相对于旧标签来说灵活性更强了；使用UTI我们可以表示下面这些实体：\n\n>* Pasteboard data\n* Folders (directories)\n* Bundles\n* Frameworks\n* Streaming data\n* Aliases and symbolic links\n\n# 用法\n\n### 1. 简介\n\nApple给我们提供了在iOS和Mac应用中通用的UTI字符串集合，比如，'public.data'、'public.item'、'public.image'等，这些我们都可以在官方文档中进行查阅他们的涵义。除此之外，我们也可以在应用程序中自定义自己的UTI字符串，比如我们可以定义一个标识特殊文档格式的UTI字符串叫'io.github.serazheng'，如果其他的应用程序想要支持我们这种格式的文档，他们就可以用'io.github.serazheng'来标识我们的文档。\n\n### 2. 字符集\n看到我们上边的举例了，那么我们来说一下定义UTI字符串时所用到的字符集。通常一个UTI字符串是一个包含ASCII字符的Unicode字符串，同时也可以加入罗马字母和阿拉伯数字，如（A-Z）,（a-z），（0-9）还有点号（\".\"）和连接符(\"-\")。而任何包含非法字符的字符串，如包含下划线'_'，都无法作为UTI来标识内容，而且Apple不会有任何错误反馈。\n\n### 3. 语法\n就像我上面的例子一样，UTI的定义和我们开发iOS程序时填写organization时一样，采取的是反域名规则。如下面这几种：\n\n>* com.apple.quicktime-movie\n* com.mycompany.myapp.myspecialfiletype\n* public.html\n* com.apple.pict\n* public.jpeg\n\n而UTI中的域名，如‘com’、‘public’这些，仅仅是用来表示这个UTI字符串在域名层级中的位置，它不会影响任何相似类型的分组。比如，‘public’域名就是大部分应用程序用来标识标准类型的，而目前仅仅只有Apple可以创建‘public’域名的UTI。\n\n另外，我们可能会碰到的是一种‘dyn’域名，是动态域名，意思就是我们使用中，不会指定这种类型的UTI为某一个字符串，然后系统运行过程中，会自动识别帮我们处理。针对这种动态标识，我们是看不到的，但是我们可以通过UTI字符串的操作方式转换成我们的常用类型，比如OSType,MIME类型等。\n\n>官方文档中，对动态标识有个比喻:“You can think of a dynamic identifier as a UTI-compatible wrapper around an otherwise unknown filename extension, MIME type, OSType, and so on”，大概意思就是我们可以把这种动态标识当做是针对普通类型进行了重写包装的，而且是兼容UTI的一种标识。\n\n最后一种就是可以自定义的域名，代表性的就是‘com’域名，Apple也给我们提供了一些他们定义的'com'域名的UTI。\n\n# 顺应性\nUTI相对于其他那些旧标签的一个关键优势就是在于，它可以在一个顺应结构中声明。而用我们面向对象的方式说，UTI就是可继承的，而且是多继承方式。先上图：\n![UTI继承结构](https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/understanding_utis/art/conformance_hierarchy.gif)\n \n\n如上图所示，‘public.html’这个UTI就是继承于‘public.text’这个UTI，因为‘public.html’标识的是HTML文本格式，也属于是文本格式的一种，而文本、图片等等这些内容又都属于是数据的一种，所以他们继承于'public.data'这个UTI。\n\n上面这个UTI继承结构图，指的是UTI中的内容形式的继承结构，此外，原则上来说，指定UTI层次的时候，即可以指定它的功能结构，也可以指定它的物理结构，上图是就是一个内容形式的功能结构图.物理结构指的就是这个UTI的物理实质，比如它标识一个目录，一个文件等，而功能结构指的就是这个UTI的用图，比如同样是文件，它标识的可以是图片、视频等等。 而官方文档也给出了一般指定UTI层次结构的规则：\n\n1. 一个UTI在物理层次上需要继承‘public.item’\n2. 一个UTI在功能层次需要继承非'public.item'之外的UTI。\n\n然而，指定UTI的功能层次并不是强制的，但是这样做是考虑到可以更好地将UTI集成到系统一些特性中，就比如Spotlight应用，就可以把我们指定的功能性UTI和命名属性联系起来。下面是一个UTI功能顺应结构和物理顺应结构图：\n ![UTI功能结构和物理结构](https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/understanding_utis/art/physical_vs_functional.gif)\n \n这个顺应性使得我们的UTI在决定类型上拥有更高的灵活性，不仅避免了大量的条件判断的使用，而且还可以关联你想不到的一些类型。\n\n# 使用UTI\n\n### 1. 应用场景\n在Mac OS中我们开发应用时我们可以经常使用到UTI，但是在开发iOS应用程序时，我们应用到UTI的场景不是很多，这也是现在网上教程偏少得原因。而在iOS开发中，一般我们使用UTI来标识剪贴板的类型。而在具体使用到Apple给我们提供的UTI字符串的时候，我们必须使用在UTCoreTypes.h文件中定义的常量来代替直接使用字符串。关于UIPasteboard的详细使用，大家可以去这篇博客中详细学习一下：[精通UIPasteboard粘贴板](http://blog.csdn.net/zhangao0086/article/details/7580654)。\n\n### 2. 操作方法\n现在我们来看一下苹果提供的一些直接操作UTI的函数方法，简单列举几个。我们可以在MobileCoreServices这个framework中的UIType.h文件中找到，我们也可以仔细的看一下这个framework中的其他文件，都是对UTI的一些定义和声明。\n\n* UITypeEqual\n\n判断俩个UTI是否完全一样，后者是一个动态标签说明是否是另外一个UTI标签说明的子集。\n\n* UITypeConformsTo\n\n判断俩个标签的顺应性，用面向对象的角度理解，就是判断是否是子类。\n\n* UTTypeCreatePreferredIdentifierForTag\n\n通过其他类型标识符，如MIME标识符，转换成UTI，当可以创建多个UTI字符串时，一般返回'public'域名的UTI。\n\n* UTTypeCreateAllIdentifiersForTag\n\n通过其他类型标识符，如MIME标识符，转换成UTI，当可以创建多个UTI字符串时，返回所有的UTIs,让你自己选\n\n* UTTypeCopyPreferredTagWithClass\n\n交换UTI字符串标识\n\n# 自定义UTI\n\n### 1. 用法\n\n苹果允许Mac开发者为他们的Mac App中独有的数据格式自定义新的UTI。它们一般被声明在下面几个文件中\n\n>* Info.plist\n* Application bundles\n* Spotlight Importer bundles\n* Automator action bundles\n\n使用官方给我们的一个UTI声明的例子，Public.jpeg声明：\n{% codeblock lang:xml %}\n<key>UTExportedTypeDeclarations</key>\n        <array>\n            <dict>\n                <key>UTTypeIdentifier</key>\n                <string>public.jpeg</string>\n                <key>UTTypeReferenceURL</key>\n                <string>http://www.w3.org/Graphics/JPEG/</string>\n                <key>UTTypeDescription</key>\n                <string>JPEG image</string>\n                <key>UTTypeIconFile</key>\n                <string>public.jpeg.icns</string>\n                <key>UTTypeConformsTo</key>\n                <array>\n                    <string>public.image</string>\n                    <string>public.data</string>\n                </array>\n                <key>UTTypeTagSpecification</key>\n                <dict>\n                    <key>com.apple.ostype</key>\n                    <string>JPEG</string>\n                    <key>public.filename-extension</key>\n                    <array>\n                        <string>jpeg</string>\n                        <string>jpg</string>\n                    </array>\n                    <key>public.mime-type</key>\n                    <string>image/jpeg</string>\n                </dict>\n            </dict>\n        </array>\n{% endcodeblock %}\n\n一个UTI声明的属性列表：\n\n\n<section>\n    <div style=\"margin-top:1.667em;margin-bottom:1.667em;\">\n        <table border=\"0\" cellspacing=\"0\" cellpadding=\"5\">\n            <tbody>\n                <tr>\n                    <th scope=\"col\" style=\"font-weight:400;background-color:#93A5BB;padding:0.3em 0.667em;font-size:13px;color:#FFFFFF;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#9BB3CD;border-right-width:1px;border-right-style:solid;border-right-color:#9BB3CD;\">\n                        <p style=\"font-weight:700;line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;margin-bottom:0.33em;\">\n                            Key\n                        </p>\n                    </th>\n                    <th scope=\"col\" style=\"font-weight:400;background-color:#93A5BB;padding:0.3em 0.667em;font-size:13px;color:#FFFFFF;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#9BB3CD;border-right-width:1px;border-right-style:solid;border-right-color:#9BB3CD;\">\n                        <p style=\"font-weight:700;line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;margin-bottom:0.33em;\">\n                            Value type\n                        </p>\n                    </th>\n                    <th scope=\"col\" style=\"font-weight:400;background-color:#93A5BB;padding:0.3em 0.667em;font-size:13px;color:#FFFFFF;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#9BB3CD;border-right-width:1px;border-right-style:solid;border-right-color:#9BB3CD;\">\n                        <p style=\"font-weight:700;line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;margin-bottom:0.33em;\">\n                            Description\n                        </p>\n                    </th>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTExportedTypeDeclarations</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            array of dictionaries\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            An array of exported UTI declarations (that is, identifiers owned by the bundle’s publisher).\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTImportedTypeDeclarations</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            array of dictionaries\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            An array of imported UTI declarations (that is, identifiers owned by another company or organization).\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeIdentifier</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            string\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            The UTI for the declared type. This key is required for UTI declarations.\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeTagSpecification</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            dictionary\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            A dictionary defining one or more equivalent type identifiers.\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeConformsTo</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            array of strings\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            The UTIs to which this identifier conforms.\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeIconFile</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            string\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            The name of the bundle icon resource to associate with this UTI.\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeDescription</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            string\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            A user-visible description of this type. You can localize this string by including it in an <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">InfoPlist.strings</code> file.\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeReferenceURL</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            string\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            The URL of a reference document describing this type.\n                        </p>\n                    </td>\n                </tr>\n            </tbody>\n        </table><br />\n    </div>\n</section>\n<section>\n    <a name=\"//apple_ref/doc/uid/TP40001319-CH204-SW4\" title=\"Recommendations for Declaring new Uniform Type Identifiers\" style=\"color:#3366CC;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;font-size:13px;background-color:#FFFFFF;\"></a>\n</section>\n<p>\n    <br />\n </p>\n\n而且自定义的UTI必须指定UTExportedTypeDeclarations或者UTImportedTypeDeclarations，这样如果是你定义的UTI，第三方应用程序和服务都可以使用，而如果是其他人定义的UTI，那么加入到你的项目中后，你就可以看到这种类型的数据。\n\n\n>而官方文档中有一句话:“If both imported and exported declarations for a UTI exist, the exported declaration takes precedence over imported one”，我的理解是，被导出去得UTI声明所有人是定义UTI的发布者，也就是你的项目，而被导入的UTI声明所有人就是其他人，所以就是说如果对于一个UTI来说，俩种类型的声明都存在，则自己定义的UTI声明优先使用。\n\n### 2. 自定义UTI的建议\n1. 你的UTI字符串必须是唯一的。以‘com.’开头的反域名命名方式是确保唯一性的简单有效的方法。\n2. 如果你的代码依赖于第三方App，UTI类型或许不会在系统中展示，你应该在bundle中声明为导入类型\n3. 如果你的UTI类型是一个或多个已存在的UTI类型的子类，则必须给它添加顺应性，让它继承于某个父类。最好是继承于‘public’类型。","source":"_posts/详解苹果提供的UTI(统一类型标识符).md","raw":"---\nlayout: post\ntitle: 详解苹果提供的UTI(统一类型标识符)\ndate: 2015-11-20\ndescription: \"解释UTI的概念和相关内容\"\ntags: [UTI]\ncategories: [iOS]\n---\n\n# 前言\n最近项目中有个需求，在iOS设备上使用iOS系统提供的内容分享功能，从第三方App应用直接分享实体内容到我们的应用中。其大概的原理是这样的，首先为我们的iOS应用注册可以打开document types(文档类型)，然后在第三方应用中，如果它们使用了iOS提供的分享功能，那么就会看到我们的应用程序，点击进行分享。\n\n而关于需求的设计和实现的具体思路，我会在下一篇博客中详细讲解。这篇文章是来讲一下在iOS系统中为了更好的进行类型标识，而提供的一套共用的规范，也就是标题中提到的“Uniform Type Identifier(UTI)”，我把它翻译成“统一类型标识符”,下面统一简称为“UTI”。\n<!-- more -->\n# 官方教程\n网上关于UTI的使用教程少之又少，所以我只是参考了苹果官方文档提供的讲解，这篇博客权当是我对于官方文档的一个理解吧！！自认为很重要的部分，我会贴出来官方文档原文，以便于大家学习理解，不至于被我的歪词所误导，同时也推荐大家从开发者中心上搜一些文档来看，这里推荐几篇：\n\n1.[Cocoa Core Competencies -- Uniform Type Identifier‍](https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/UniformTypeIdentifier.html)\n\n这篇文档提供了一个视图来说明UTI是什么，怎么工作和被谁使用，是个非常好的新手指南。\n   \n2.[Uniform Type Identifier介绍和使用‍](https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-BCGCDHIJ)\n\n这篇文档详细得描述了UTI的基础概念和属性，还有它们的使用方法，内容非常丰富，本文主要参考的就是这篇\n\n3.[System-Declared Uniform Type Identifiers‍](https://developer.apple.com/library/ios/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html#//apple_ref/doc/uid/TP40009259-SW1)\n\n这篇文档提供了在OS X系统中定义的一个UTI的列表，我们可以查看每一种官方提供的UTI的定义和涵义。\n\n4.[UTType Reference‍](https://developer.apple.com/library/ios/documentation/MobileCoreServices/Reference/UTTypeRef/index.html#//apple_ref/doc/uid/TP40008771)\n\n这篇文档提供了对UTI字符串直接操作的函数方法\n\n5.[一步一步为iOS应用添加自定义的document type和新的UTI‍](https://developer.apple.com/library/ios/qa/qa1587/_index.html#//apple_ref/doc/uid/DTS40012659)\n\n顾名思义，这篇文档，讲解的是如何在iOS应用中导入新的UTI和添加自定义的document type。\n\n# 为什么会有UTI\n为什么会有UTI，打个比方，它就像是如今世界各国作为官方语言统讲得英文。为什么这么比喻呢，因为中国人讲母语汉语，法国人讲母语法语，但是如果一个中国人到了法国，而又不懂法语，碰到的法国人不懂汉语，那么他们如何交流沟通呢，这就是英文的用武之地了。而相对而言，苹果操作系统相当于整个世界，各个不同的程序或者服务相当于各个国家，俩个不同的程序想要互通交流，就比如互相发送文件，可是一个使用文件扩展名，一个使用MIME类型，俩者的数据类型不同，无法解析，都互相不认识，那么怎么交流沟通呢?在这样的情景下，UTI就有了用武之地啦，它就充当的是现实世界的英文这个角色。\n\n# UTI概念\nUniform type identifiers(UTIs)提供了在整个系统里面标识数据的一个统一的方式，比如documents(文档)、pasteboard data(剪贴板数据)和bundles(包)。\n\n>而具体到UTI的定义，官方文档是这么说的：“A uniform type identifier is a string that uniquely identifies a class of entities considered to have a ‘type’.”。其大概意思是说，一个统一类型标识符是一个唯一标识一种拥有\"类型\"属性实体的字符串。而且，针对这个“type”，官方文档还给我们提出了例子解释，对于一个文件或者是字节流来说，“type”指的的数据类型；而对于packages和bundles来说，“type”指的就是它们内部的目录层级结构。\n\n# UTI用途\n大多数情况下，一个UTI提供的是系统中所有程序和服务都能够识别并且依赖的一个唯一的标识，这么讲可能有些太抽象，我们使用一下官方文档中给出的例子，比如一个JPEG类型的图片文件，在不同的环境下，可以有下面几种不同的标识方法：\n\n>1. ‘JPEG’, OSType表示,\n2. '.jpg', 文件扩展名\n3. '.jpeg', 文件扩展名\n4. 'image/jpeg', MIME(多用途互联网邮件扩展类型)中的一种类型\n\n而UTI则是用‘public.jpeg’这个字符串标识，完全代替了这些不一致的标签，这个字符串和其他任何一个旧标签都是完全兼容的，而且他们之间可以相互转换。由于UTI可以标识任何类型的实体，所以他们相对于旧标签来说灵活性更强了；使用UTI我们可以表示下面这些实体：\n\n>* Pasteboard data\n* Folders (directories)\n* Bundles\n* Frameworks\n* Streaming data\n* Aliases and symbolic links\n\n# 用法\n\n### 1. 简介\n\nApple给我们提供了在iOS和Mac应用中通用的UTI字符串集合，比如，'public.data'、'public.item'、'public.image'等，这些我们都可以在官方文档中进行查阅他们的涵义。除此之外，我们也可以在应用程序中自定义自己的UTI字符串，比如我们可以定义一个标识特殊文档格式的UTI字符串叫'io.github.serazheng'，如果其他的应用程序想要支持我们这种格式的文档，他们就可以用'io.github.serazheng'来标识我们的文档。\n\n### 2. 字符集\n看到我们上边的举例了，那么我们来说一下定义UTI字符串时所用到的字符集。通常一个UTI字符串是一个包含ASCII字符的Unicode字符串，同时也可以加入罗马字母和阿拉伯数字，如（A-Z）,（a-z），（0-9）还有点号（\".\"）和连接符(\"-\")。而任何包含非法字符的字符串，如包含下划线'_'，都无法作为UTI来标识内容，而且Apple不会有任何错误反馈。\n\n### 3. 语法\n就像我上面的例子一样，UTI的定义和我们开发iOS程序时填写organization时一样，采取的是反域名规则。如下面这几种：\n\n>* com.apple.quicktime-movie\n* com.mycompany.myapp.myspecialfiletype\n* public.html\n* com.apple.pict\n* public.jpeg\n\n而UTI中的域名，如‘com’、‘public’这些，仅仅是用来表示这个UTI字符串在域名层级中的位置，它不会影响任何相似类型的分组。比如，‘public’域名就是大部分应用程序用来标识标准类型的，而目前仅仅只有Apple可以创建‘public’域名的UTI。\n\n另外，我们可能会碰到的是一种‘dyn’域名，是动态域名，意思就是我们使用中，不会指定这种类型的UTI为某一个字符串，然后系统运行过程中，会自动识别帮我们处理。针对这种动态标识，我们是看不到的，但是我们可以通过UTI字符串的操作方式转换成我们的常用类型，比如OSType,MIME类型等。\n\n>官方文档中，对动态标识有个比喻:“You can think of a dynamic identifier as a UTI-compatible wrapper around an otherwise unknown filename extension, MIME type, OSType, and so on”，大概意思就是我们可以把这种动态标识当做是针对普通类型进行了重写包装的，而且是兼容UTI的一种标识。\n\n最后一种就是可以自定义的域名，代表性的就是‘com’域名，Apple也给我们提供了一些他们定义的'com'域名的UTI。\n\n# 顺应性\nUTI相对于其他那些旧标签的一个关键优势就是在于，它可以在一个顺应结构中声明。而用我们面向对象的方式说，UTI就是可继承的，而且是多继承方式。先上图：\n![UTI继承结构](https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/understanding_utis/art/conformance_hierarchy.gif)\n \n\n如上图所示，‘public.html’这个UTI就是继承于‘public.text’这个UTI，因为‘public.html’标识的是HTML文本格式，也属于是文本格式的一种，而文本、图片等等这些内容又都属于是数据的一种，所以他们继承于'public.data'这个UTI。\n\n上面这个UTI继承结构图，指的是UTI中的内容形式的继承结构，此外，原则上来说，指定UTI层次的时候，即可以指定它的功能结构，也可以指定它的物理结构，上图是就是一个内容形式的功能结构图.物理结构指的就是这个UTI的物理实质，比如它标识一个目录，一个文件等，而功能结构指的就是这个UTI的用图，比如同样是文件，它标识的可以是图片、视频等等。 而官方文档也给出了一般指定UTI层次结构的规则：\n\n1. 一个UTI在物理层次上需要继承‘public.item’\n2. 一个UTI在功能层次需要继承非'public.item'之外的UTI。\n\n然而，指定UTI的功能层次并不是强制的，但是这样做是考虑到可以更好地将UTI集成到系统一些特性中，就比如Spotlight应用，就可以把我们指定的功能性UTI和命名属性联系起来。下面是一个UTI功能顺应结构和物理顺应结构图：\n ![UTI功能结构和物理结构](https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/understanding_utis/art/physical_vs_functional.gif)\n \n这个顺应性使得我们的UTI在决定类型上拥有更高的灵活性，不仅避免了大量的条件判断的使用，而且还可以关联你想不到的一些类型。\n\n# 使用UTI\n\n### 1. 应用场景\n在Mac OS中我们开发应用时我们可以经常使用到UTI，但是在开发iOS应用程序时，我们应用到UTI的场景不是很多，这也是现在网上教程偏少得原因。而在iOS开发中，一般我们使用UTI来标识剪贴板的类型。而在具体使用到Apple给我们提供的UTI字符串的时候，我们必须使用在UTCoreTypes.h文件中定义的常量来代替直接使用字符串。关于UIPasteboard的详细使用，大家可以去这篇博客中详细学习一下：[精通UIPasteboard粘贴板](http://blog.csdn.net/zhangao0086/article/details/7580654)。\n\n### 2. 操作方法\n现在我们来看一下苹果提供的一些直接操作UTI的函数方法，简单列举几个。我们可以在MobileCoreServices这个framework中的UIType.h文件中找到，我们也可以仔细的看一下这个framework中的其他文件，都是对UTI的一些定义和声明。\n\n* UITypeEqual\n\n判断俩个UTI是否完全一样，后者是一个动态标签说明是否是另外一个UTI标签说明的子集。\n\n* UITypeConformsTo\n\n判断俩个标签的顺应性，用面向对象的角度理解，就是判断是否是子类。\n\n* UTTypeCreatePreferredIdentifierForTag\n\n通过其他类型标识符，如MIME标识符，转换成UTI，当可以创建多个UTI字符串时，一般返回'public'域名的UTI。\n\n* UTTypeCreateAllIdentifiersForTag\n\n通过其他类型标识符，如MIME标识符，转换成UTI，当可以创建多个UTI字符串时，返回所有的UTIs,让你自己选\n\n* UTTypeCopyPreferredTagWithClass\n\n交换UTI字符串标识\n\n# 自定义UTI\n\n### 1. 用法\n\n苹果允许Mac开发者为他们的Mac App中独有的数据格式自定义新的UTI。它们一般被声明在下面几个文件中\n\n>* Info.plist\n* Application bundles\n* Spotlight Importer bundles\n* Automator action bundles\n\n使用官方给我们的一个UTI声明的例子，Public.jpeg声明：\n{% codeblock lang:xml %}\n<key>UTExportedTypeDeclarations</key>\n        <array>\n            <dict>\n                <key>UTTypeIdentifier</key>\n                <string>public.jpeg</string>\n                <key>UTTypeReferenceURL</key>\n                <string>http://www.w3.org/Graphics/JPEG/</string>\n                <key>UTTypeDescription</key>\n                <string>JPEG image</string>\n                <key>UTTypeIconFile</key>\n                <string>public.jpeg.icns</string>\n                <key>UTTypeConformsTo</key>\n                <array>\n                    <string>public.image</string>\n                    <string>public.data</string>\n                </array>\n                <key>UTTypeTagSpecification</key>\n                <dict>\n                    <key>com.apple.ostype</key>\n                    <string>JPEG</string>\n                    <key>public.filename-extension</key>\n                    <array>\n                        <string>jpeg</string>\n                        <string>jpg</string>\n                    </array>\n                    <key>public.mime-type</key>\n                    <string>image/jpeg</string>\n                </dict>\n            </dict>\n        </array>\n{% endcodeblock %}\n\n一个UTI声明的属性列表：\n\n\n<section>\n    <div style=\"margin-top:1.667em;margin-bottom:1.667em;\">\n        <table border=\"0\" cellspacing=\"0\" cellpadding=\"5\">\n            <tbody>\n                <tr>\n                    <th scope=\"col\" style=\"font-weight:400;background-color:#93A5BB;padding:0.3em 0.667em;font-size:13px;color:#FFFFFF;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#9BB3CD;border-right-width:1px;border-right-style:solid;border-right-color:#9BB3CD;\">\n                        <p style=\"font-weight:700;line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;margin-bottom:0.33em;\">\n                            Key\n                        </p>\n                    </th>\n                    <th scope=\"col\" style=\"font-weight:400;background-color:#93A5BB;padding:0.3em 0.667em;font-size:13px;color:#FFFFFF;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#9BB3CD;border-right-width:1px;border-right-style:solid;border-right-color:#9BB3CD;\">\n                        <p style=\"font-weight:700;line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;margin-bottom:0.33em;\">\n                            Value type\n                        </p>\n                    </th>\n                    <th scope=\"col\" style=\"font-weight:400;background-color:#93A5BB;padding:0.3em 0.667em;font-size:13px;color:#FFFFFF;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#9BB3CD;border-right-width:1px;border-right-style:solid;border-right-color:#9BB3CD;\">\n                        <p style=\"font-weight:700;line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;margin-bottom:0.33em;\">\n                            Description\n                        </p>\n                    </th>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTExportedTypeDeclarations</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            array of dictionaries\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            An array of exported UTI declarations (that is, identifiers owned by the bundle’s publisher).\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTImportedTypeDeclarations</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            array of dictionaries\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            An array of imported UTI declarations (that is, identifiers owned by another company or organization).\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeIdentifier</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            string\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            The UTI for the declared type. This key is required for UTI declarations.\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeTagSpecification</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            dictionary\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            A dictionary defining one or more equivalent type identifiers.\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeConformsTo</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            array of strings\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            The UTIs to which this identifier conforms.\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeIconFile</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            string\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            The name of the bundle icon resource to associate with this UTI.\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeDescription</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            string\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            A user-visible description of this type. You can localize this string by including it in an <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">InfoPlist.strings</code> file.\n                        </p>\n                    </td>\n                </tr>\n                <tr>\n                    <td scope=\"row\">\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeReferenceURL</code>\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            string\n                        </p>\n                    </td>\n                    <td>\n                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\">\n                            The URL of a reference document describing this type.\n                        </p>\n                    </td>\n                </tr>\n            </tbody>\n        </table><br />\n    </div>\n</section>\n<section>\n    <a name=\"//apple_ref/doc/uid/TP40001319-CH204-SW4\" title=\"Recommendations for Declaring new Uniform Type Identifiers\" style=\"color:#3366CC;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;font-size:13px;background-color:#FFFFFF;\"></a>\n</section>\n<p>\n    <br />\n </p>\n\n而且自定义的UTI必须指定UTExportedTypeDeclarations或者UTImportedTypeDeclarations，这样如果是你定义的UTI，第三方应用程序和服务都可以使用，而如果是其他人定义的UTI，那么加入到你的项目中后，你就可以看到这种类型的数据。\n\n\n>而官方文档中有一句话:“If both imported and exported declarations for a UTI exist, the exported declaration takes precedence over imported one”，我的理解是，被导出去得UTI声明所有人是定义UTI的发布者，也就是你的项目，而被导入的UTI声明所有人就是其他人，所以就是说如果对于一个UTI来说，俩种类型的声明都存在，则自己定义的UTI声明优先使用。\n\n### 2. 自定义UTI的建议\n1. 你的UTI字符串必须是唯一的。以‘com.’开头的反域名命名方式是确保唯一性的简单有效的方法。\n2. 如果你的代码依赖于第三方App，UTI类型或许不会在系统中展示，你应该在bundle中声明为导入类型\n3. 如果你的UTI类型是一个或多个已存在的UTI类型的子类，则必须给它添加顺应性，让它继承于某个父类。最好是继承于‘public’类型。","slug":"详解苹果提供的UTI(统一类型标识符)","published":1,"updated":"2016-04-12T06:51:58.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9v1002h94sua54bphxj","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近项目中有个需求，在iOS设备上使用iOS系统提供的内容分享功能，从第三方App应用直接分享实体内容到我们的应用中。其大概的原理是这样的，首先为我们的iOS应用注册可以打开document types(文档类型)，然后在第三方应用中，如果它们使用了iOS提供的分享功能，那么就会看到我们的应用程序，点击进行分享。</p>\n<p>而关于需求的设计和实现的具体思路，我会在下一篇博客中详细讲解。这篇文章是来讲一下在iOS系统中为了更好的进行类型标识，而提供的一套共用的规范，也就是标题中提到的“Uniform Type Identifier(UTI)”，我把它翻译成“统一类型标识符”,下面统一简称为“UTI”。<br><a id=\"more\"></a></p>\n<h1 id=\"官方教程\"><a href=\"#官方教程\" class=\"headerlink\" title=\"官方教程\"></a>官方教程</h1><p>网上关于UTI的使用教程少之又少，所以我只是参考了苹果官方文档提供的讲解，这篇博客权当是我对于官方文档的一个理解吧！！自认为很重要的部分，我会贴出来官方文档原文，以便于大家学习理解，不至于被我的歪词所误导，同时也推荐大家从开发者中心上搜一些文档来看，这里推荐几篇：</p>\n<p>1.<a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/UniformTypeIdentifier.html\" target=\"_blank\" rel=\"external\">Cocoa Core Competencies – Uniform Type Identifier‍</a></p>\n<p>这篇文档提供了一个视图来说明UTI是什么，怎么工作和被谁使用，是个非常好的新手指南。</p>\n<p>2.<a href=\"https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-BCGCDHIJ\" target=\"_blank\" rel=\"external\">Uniform Type Identifier介绍和使用‍</a></p>\n<p>这篇文档详细得描述了UTI的基础概念和属性，还有它们的使用方法，内容非常丰富，本文主要参考的就是这篇</p>\n<p>3.<a href=\"https://developer.apple.com/library/ios/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html#//apple_ref/doc/uid/TP40009259-SW1\" target=\"_blank\" rel=\"external\">System-Declared Uniform Type Identifiers‍</a></p>\n<p>这篇文档提供了在OS X系统中定义的一个UTI的列表，我们可以查看每一种官方提供的UTI的定义和涵义。</p>\n<p>4.<a href=\"https://developer.apple.com/library/ios/documentation/MobileCoreServices/Reference/UTTypeRef/index.html#//apple_ref/doc/uid/TP40008771\" target=\"_blank\" rel=\"external\">UTType Reference‍</a></p>\n<p>这篇文档提供了对UTI字符串直接操作的函数方法</p>\n<p>5.<a href=\"https://developer.apple.com/library/ios/qa/qa1587/_index.html#//apple_ref/doc/uid/DTS40012659\" target=\"_blank\" rel=\"external\">一步一步为iOS应用添加自定义的document type和新的UTI‍</a></p>\n<p>顾名思义，这篇文档，讲解的是如何在iOS应用中导入新的UTI和添加自定义的document type。</p>\n<h1 id=\"为什么会有UTI\"><a href=\"#为什么会有UTI\" class=\"headerlink\" title=\"为什么会有UTI\"></a>为什么会有UTI</h1><p>为什么会有UTI，打个比方，它就像是如今世界各国作为官方语言统讲得英文。为什么这么比喻呢，因为中国人讲母语汉语，法国人讲母语法语，但是如果一个中国人到了法国，而又不懂法语，碰到的法国人不懂汉语，那么他们如何交流沟通呢，这就是英文的用武之地了。而相对而言，苹果操作系统相当于整个世界，各个不同的程序或者服务相当于各个国家，俩个不同的程序想要互通交流，就比如互相发送文件，可是一个使用文件扩展名，一个使用MIME类型，俩者的数据类型不同，无法解析，都互相不认识，那么怎么交流沟通呢?在这样的情景下，UTI就有了用武之地啦，它就充当的是现实世界的英文这个角色。</p>\n<h1 id=\"UTI概念\"><a href=\"#UTI概念\" class=\"headerlink\" title=\"UTI概念\"></a>UTI概念</h1><p>Uniform type identifiers(UTIs)提供了在整个系统里面标识数据的一个统一的方式，比如documents(文档)、pasteboard data(剪贴板数据)和bundles(包)。</p>\n<blockquote>\n<p>而具体到UTI的定义，官方文档是这么说的：“A uniform type identifier is a string that uniquely identifies a class of entities considered to have a ‘type’.”。其大概意思是说，一个统一类型标识符是一个唯一标识一种拥有”类型”属性实体的字符串。而且，针对这个“type”，官方文档还给我们提出了例子解释，对于一个文件或者是字节流来说，“type”指的的数据类型；而对于packages和bundles来说，“type”指的就是它们内部的目录层级结构。</p>\n</blockquote>\n<h1 id=\"UTI用途\"><a href=\"#UTI用途\" class=\"headerlink\" title=\"UTI用途\"></a>UTI用途</h1><p>大多数情况下，一个UTI提供的是系统中所有程序和服务都能够识别并且依赖的一个唯一的标识，这么讲可能有些太抽象，我们使用一下官方文档中给出的例子，比如一个JPEG类型的图片文件，在不同的环境下，可以有下面几种不同的标识方法：</p>\n<blockquote>\n<ol>\n<li>‘JPEG’, OSType表示,</li>\n<li>‘.jpg’, 文件扩展名</li>\n<li>‘.jpeg’, 文件扩展名</li>\n<li>‘image/jpeg’, MIME(多用途互联网邮件扩展类型)中的一种类型</li>\n</ol>\n</blockquote>\n<p>而UTI则是用‘public.jpeg’这个字符串标识，完全代替了这些不一致的标签，这个字符串和其他任何一个旧标签都是完全兼容的，而且他们之间可以相互转换。由于UTI可以标识任何类型的实体，所以他们相对于旧标签来说灵活性更强了；使用UTI我们可以表示下面这些实体：</p>\n<blockquote>\n<ul>\n<li>Pasteboard data</li>\n<li>Folders (directories)</li>\n<li>Bundles</li>\n<li>Frameworks</li>\n<li>Streaming data</li>\n<li>Aliases and symbolic links</li>\n</ul>\n</blockquote>\n<h1 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h1><h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>Apple给我们提供了在iOS和Mac应用中通用的UTI字符串集合，比如，’public.data’、’public.item’、’public.image’等，这些我们都可以在官方文档中进行查阅他们的涵义。除此之外，我们也可以在应用程序中自定义自己的UTI字符串，比如我们可以定义一个标识特殊文档格式的UTI字符串叫’io.github.serazheng’，如果其他的应用程序想要支持我们这种格式的文档，他们就可以用’io.github.serazheng’来标识我们的文档。</p>\n<h3 id=\"2-字符集\"><a href=\"#2-字符集\" class=\"headerlink\" title=\"2. 字符集\"></a>2. 字符集</h3><p>看到我们上边的举例了，那么我们来说一下定义UTI字符串时所用到的字符集。通常一个UTI字符串是一个包含ASCII字符的Unicode字符串，同时也可以加入罗马字母和阿拉伯数字，如（A-Z）,（a-z），（0-9）还有点号（”.”）和连接符(“-“)。而任何包含非法字符的字符串，如包含下划线’_’，都无法作为UTI来标识内容，而且Apple不会有任何错误反馈。</p>\n<h3 id=\"3-语法\"><a href=\"#3-语法\" class=\"headerlink\" title=\"3. 语法\"></a>3. 语法</h3><p>就像我上面的例子一样，UTI的定义和我们开发iOS程序时填写organization时一样，采取的是反域名规则。如下面这几种：</p>\n<blockquote>\n<ul>\n<li>com.apple.quicktime-movie</li>\n<li>com.mycompany.myapp.myspecialfiletype</li>\n<li>public.html</li>\n<li>com.apple.pict</li>\n<li>public.jpeg</li>\n</ul>\n</blockquote>\n<p>而UTI中的域名，如‘com’、‘public’这些，仅仅是用来表示这个UTI字符串在域名层级中的位置，它不会影响任何相似类型的分组。比如，‘public’域名就是大部分应用程序用来标识标准类型的，而目前仅仅只有Apple可以创建‘public’域名的UTI。</p>\n<p>另外，我们可能会碰到的是一种‘dyn’域名，是动态域名，意思就是我们使用中，不会指定这种类型的UTI为某一个字符串，然后系统运行过程中，会自动识别帮我们处理。针对这种动态标识，我们是看不到的，但是我们可以通过UTI字符串的操作方式转换成我们的常用类型，比如OSType,MIME类型等。</p>\n<blockquote>\n<p>官方文档中，对动态标识有个比喻:“You can think of a dynamic identifier as a UTI-compatible wrapper around an otherwise unknown filename extension, MIME type, OSType, and so on”，大概意思就是我们可以把这种动态标识当做是针对普通类型进行了重写包装的，而且是兼容UTI的一种标识。</p>\n</blockquote>\n<p>最后一种就是可以自定义的域名，代表性的就是‘com’域名，Apple也给我们提供了一些他们定义的’com’域名的UTI。</p>\n<h1 id=\"顺应性\"><a href=\"#顺应性\" class=\"headerlink\" title=\"顺应性\"></a>顺应性</h1><p>UTI相对于其他那些旧标签的一个关键优势就是在于，它可以在一个顺应结构中声明。而用我们面向对象的方式说，UTI就是可继承的，而且是多继承方式。先上图：<br><img src=\"https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/understanding_utis/art/conformance_hierarchy.gif\" alt=\"UTI继承结构\"></p>\n<p>如上图所示，‘public.html’这个UTI就是继承于‘public.text’这个UTI，因为‘public.html’标识的是HTML文本格式，也属于是文本格式的一种，而文本、图片等等这些内容又都属于是数据的一种，所以他们继承于’public.data’这个UTI。</p>\n<p>上面这个UTI继承结构图，指的是UTI中的内容形式的继承结构，此外，原则上来说，指定UTI层次的时候，即可以指定它的功能结构，也可以指定它的物理结构，上图是就是一个内容形式的功能结构图.物理结构指的就是这个UTI的物理实质，比如它标识一个目录，一个文件等，而功能结构指的就是这个UTI的用图，比如同样是文件，它标识的可以是图片、视频等等。 而官方文档也给出了一般指定UTI层次结构的规则：</p>\n<ol>\n<li>一个UTI在物理层次上需要继承‘public.item’</li>\n<li>一个UTI在功能层次需要继承非’public.item’之外的UTI。</li>\n</ol>\n<p>然而，指定UTI的功能层次并不是强制的，但是这样做是考虑到可以更好地将UTI集成到系统一些特性中，就比如Spotlight应用，就可以把我们指定的功能性UTI和命名属性联系起来。下面是一个UTI功能顺应结构和物理顺应结构图：<br> <img src=\"https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/understanding_utis/art/physical_vs_functional.gif\" alt=\"UTI功能结构和物理结构\"></p>\n<p>这个顺应性使得我们的UTI在决定类型上拥有更高的灵活性，不仅避免了大量的条件判断的使用，而且还可以关联你想不到的一些类型。</p>\n<h1 id=\"使用UTI\"><a href=\"#使用UTI\" class=\"headerlink\" title=\"使用UTI\"></a>使用UTI</h1><h3 id=\"1-应用场景\"><a href=\"#1-应用场景\" class=\"headerlink\" title=\"1. 应用场景\"></a>1. 应用场景</h3><p>在Mac OS中我们开发应用时我们可以经常使用到UTI，但是在开发iOS应用程序时，我们应用到UTI的场景不是很多，这也是现在网上教程偏少得原因。而在iOS开发中，一般我们使用UTI来标识剪贴板的类型。而在具体使用到Apple给我们提供的UTI字符串的时候，我们必须使用在UTCoreTypes.h文件中定义的常量来代替直接使用字符串。关于UIPasteboard的详细使用，大家可以去这篇博客中详细学习一下：<a href=\"http://blog.csdn.net/zhangao0086/article/details/7580654\" target=\"_blank\" rel=\"external\">精通UIPasteboard粘贴板</a>。</p>\n<h3 id=\"2-操作方法\"><a href=\"#2-操作方法\" class=\"headerlink\" title=\"2. 操作方法\"></a>2. 操作方法</h3><p>现在我们来看一下苹果提供的一些直接操作UTI的函数方法，简单列举几个。我们可以在MobileCoreServices这个framework中的UIType.h文件中找到，我们也可以仔细的看一下这个framework中的其他文件，都是对UTI的一些定义和声明。</p>\n<ul>\n<li>UITypeEqual</li>\n</ul>\n<p>判断俩个UTI是否完全一样，后者是一个动态标签说明是否是另外一个UTI标签说明的子集。</p>\n<ul>\n<li>UITypeConformsTo</li>\n</ul>\n<p>判断俩个标签的顺应性，用面向对象的角度理解，就是判断是否是子类。</p>\n<ul>\n<li>UTTypeCreatePreferredIdentifierForTag</li>\n</ul>\n<p>通过其他类型标识符，如MIME标识符，转换成UTI，当可以创建多个UTI字符串时，一般返回’public’域名的UTI。</p>\n<ul>\n<li>UTTypeCreateAllIdentifiersForTag</li>\n</ul>\n<p>通过其他类型标识符，如MIME标识符，转换成UTI，当可以创建多个UTI字符串时，返回所有的UTIs,让你自己选</p>\n<ul>\n<li>UTTypeCopyPreferredTagWithClass</li>\n</ul>\n<p>交换UTI字符串标识</p>\n<h1 id=\"自定义UTI\"><a href=\"#自定义UTI\" class=\"headerlink\" title=\"自定义UTI\"></a>自定义UTI</h1><h3 id=\"1-用法\"><a href=\"#1-用法\" class=\"headerlink\" title=\"1. 用法\"></a>1. 用法</h3><p>苹果允许Mac开发者为他们的Mac App中独有的数据格式自定义新的UTI。它们一般被声明在下面几个文件中</p>\n<blockquote>\n<ul>\n<li>Info.plist</li>\n<li>Application bundles</li>\n<li>Spotlight Importer bundles</li>\n<li>Automator action bundles</li>\n</ul>\n</blockquote>\n<p>使用官方给我们的一个UTI声明的例子，Public.jpeg声明：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTExportedTypeDeclarations<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTTypeIdentifier<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>public.jpeg<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTTypeReferenceURL<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>http://www.w3.org/Graphics/JPEG/<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTTypeDescription<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>JPEG image<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTTypeIconFile<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>public.jpeg.icns<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTTypeConformsTo<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>public.image<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>public.data<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTTypeTagSpecification<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>com.apple.ostype<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>JPEG<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>public.filename-extension<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>jpeg<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>jpg<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>public.mime-type<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>image/jpeg<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>一个UTI声明的属性列表：</p>\n<p><section><br>    <div style=\"margin-top:1.667em;margin-bottom:1.667em;\"><br>        <table border=\"0\" cellspacing=\"0\" cellpadding=\"5\"><br>            <tbody><br>                <tr><br>                    <th scope=\"col\" style=\"font-weight:400;background-color:#93A5BB;padding:0.3em 0.667em;font-size:13px;color:#FFFFFF;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#9BB3CD;border-right-width:1px;border-right-style:solid;border-right-color:#9BB3CD;\"><br>                        <p style=\"font-weight:700;line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;margin-bottom:0.33em;\"><br>                            Key<br>                        </p><br>                    </th><br>                    <th scope=\"col\" style=\"font-weight:400;background-color:#93A5BB;padding:0.3em 0.667em;font-size:13px;color:#FFFFFF;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#9BB3CD;border-right-width:1px;border-right-style:solid;border-right-color:#9BB3CD;\"><br>                        <p style=\"font-weight:700;line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;margin-bottom:0.33em;\"><br>                            Value type<br>                        </p><br>                    </th><br>                    <th scope=\"col\" style=\"font-weight:400;background-color:#93A5BB;padding:0.3em 0.667em;font-size:13px;color:#FFFFFF;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#9BB3CD;border-right-width:1px;border-right-style:solid;border-right-color:#9BB3CD;\"><br>                        <p style=\"font-weight:700;line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;margin-bottom:0.33em;\"><br>                            Description<br>                        </p><br>                    </th><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTExportedTypeDeclarations</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            array of dictionaries<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            An array of exported UTI declarations (that is, identifiers owned by the bundle’s publisher).<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTImportedTypeDeclarations</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            array of dictionaries<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            An array of imported UTI declarations (that is, identifiers owned by another company or organization).<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeIdentifier</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            string<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            The UTI for the declared type. This key is required for UTI declarations.<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeTagSpecification</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            dictionary<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            A dictionary defining one or more equivalent type identifiers.<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeConformsTo</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            array of strings<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            The UTIs to which this identifier conforms.<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeIconFile</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            string<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            The name of the bundle icon resource to associate with this UTI.<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeDescription</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            string<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            A user-visible description of this type. You can localize this string by including it in an <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">InfoPlist.strings</code> file.<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeReferenceURL</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            string<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            The URL of a reference document describing this type.<br>                        </p><br>                    </td><br>                </tr><br>            </tbody><br>        </table><br><br>    </div><br></section></p>\n<p><section><br>    <a name=\"//apple_ref/doc/uid/TP40001319-CH204-SW4\" title=\"Recommendations for Declaring new Uniform Type Identifiers\" style=\"color:#3366CC;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;font-size:13px;background-color:#FFFFFF;\"></a><br></section></p>\n<p><br>    <br><br> </p>\n\n<p>而且自定义的UTI必须指定UTExportedTypeDeclarations或者UTImportedTypeDeclarations，这样如果是你定义的UTI，第三方应用程序和服务都可以使用，而如果是其他人定义的UTI，那么加入到你的项目中后，你就可以看到这种类型的数据。</p>\n<blockquote>\n<p>而官方文档中有一句话:“If both imported and exported declarations for a UTI exist, the exported declaration takes precedence over imported one”，我的理解是，被导出去得UTI声明所有人是定义UTI的发布者，也就是你的项目，而被导入的UTI声明所有人就是其他人，所以就是说如果对于一个UTI来说，俩种类型的声明都存在，则自己定义的UTI声明优先使用。</p>\n</blockquote>\n<h3 id=\"2-自定义UTI的建议\"><a href=\"#2-自定义UTI的建议\" class=\"headerlink\" title=\"2. 自定义UTI的建议\"></a>2. 自定义UTI的建议</h3><ol>\n<li>你的UTI字符串必须是唯一的。以‘com.’开头的反域名命名方式是确保唯一性的简单有效的方法。</li>\n<li>如果你的代码依赖于第三方App，UTI类型或许不会在系统中展示，你应该在bundle中声明为导入类型</li>\n<li>如果你的UTI类型是一个或多个已存在的UTI类型的子类，则必须给它添加顺应性，让它继承于某个父类。最好是继承于‘public’类型。</li>\n</ol>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近项目中有个需求，在iOS设备上使用iOS系统提供的内容分享功能，从第三方App应用直接分享实体内容到我们的应用中。其大概的原理是这样的，首先为我们的iOS应用注册可以打开document types(文档类型)，然后在第三方应用中，如果它们使用了iOS提供的分享功能，那么就会看到我们的应用程序，点击进行分享。</p>\n<p>而关于需求的设计和实现的具体思路，我会在下一篇博客中详细讲解。这篇文章是来讲一下在iOS系统中为了更好的进行类型标识，而提供的一套共用的规范，也就是标题中提到的“Uniform Type Identifier(UTI)”，我把它翻译成“统一类型标识符”,下面统一简称为“UTI”。<br>","more":"</p>\n<h1 id=\"官方教程\"><a href=\"#官方教程\" class=\"headerlink\" title=\"官方教程\"></a>官方教程</h1><p>网上关于UTI的使用教程少之又少，所以我只是参考了苹果官方文档提供的讲解，这篇博客权当是我对于官方文档的一个理解吧！！自认为很重要的部分，我会贴出来官方文档原文，以便于大家学习理解，不至于被我的歪词所误导，同时也推荐大家从开发者中心上搜一些文档来看，这里推荐几篇：</p>\n<p>1.<a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/UniformTypeIdentifier.html\">Cocoa Core Competencies – Uniform Type Identifier‍</a></p>\n<p>这篇文档提供了一个视图来说明UTI是什么，怎么工作和被谁使用，是个非常好的新手指南。</p>\n<p>2.<a href=\"https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-BCGCDHIJ\">Uniform Type Identifier介绍和使用‍</a></p>\n<p>这篇文档详细得描述了UTI的基础概念和属性，还有它们的使用方法，内容非常丰富，本文主要参考的就是这篇</p>\n<p>3.<a href=\"https://developer.apple.com/library/ios/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html#//apple_ref/doc/uid/TP40009259-SW1\">System-Declared Uniform Type Identifiers‍</a></p>\n<p>这篇文档提供了在OS X系统中定义的一个UTI的列表，我们可以查看每一种官方提供的UTI的定义和涵义。</p>\n<p>4.<a href=\"https://developer.apple.com/library/ios/documentation/MobileCoreServices/Reference/UTTypeRef/index.html#//apple_ref/doc/uid/TP40008771\">UTType Reference‍</a></p>\n<p>这篇文档提供了对UTI字符串直接操作的函数方法</p>\n<p>5.<a href=\"https://developer.apple.com/library/ios/qa/qa1587/_index.html#//apple_ref/doc/uid/DTS40012659\">一步一步为iOS应用添加自定义的document type和新的UTI‍</a></p>\n<p>顾名思义，这篇文档，讲解的是如何在iOS应用中导入新的UTI和添加自定义的document type。</p>\n<h1 id=\"为什么会有UTI\"><a href=\"#为什么会有UTI\" class=\"headerlink\" title=\"为什么会有UTI\"></a>为什么会有UTI</h1><p>为什么会有UTI，打个比方，它就像是如今世界各国作为官方语言统讲得英文。为什么这么比喻呢，因为中国人讲母语汉语，法国人讲母语法语，但是如果一个中国人到了法国，而又不懂法语，碰到的法国人不懂汉语，那么他们如何交流沟通呢，这就是英文的用武之地了。而相对而言，苹果操作系统相当于整个世界，各个不同的程序或者服务相当于各个国家，俩个不同的程序想要互通交流，就比如互相发送文件，可是一个使用文件扩展名，一个使用MIME类型，俩者的数据类型不同，无法解析，都互相不认识，那么怎么交流沟通呢?在这样的情景下，UTI就有了用武之地啦，它就充当的是现实世界的英文这个角色。</p>\n<h1 id=\"UTI概念\"><a href=\"#UTI概念\" class=\"headerlink\" title=\"UTI概念\"></a>UTI概念</h1><p>Uniform type identifiers(UTIs)提供了在整个系统里面标识数据的一个统一的方式，比如documents(文档)、pasteboard data(剪贴板数据)和bundles(包)。</p>\n<blockquote>\n<p>而具体到UTI的定义，官方文档是这么说的：“A uniform type identifier is a string that uniquely identifies a class of entities considered to have a ‘type’.”。其大概意思是说，一个统一类型标识符是一个唯一标识一种拥有”类型”属性实体的字符串。而且，针对这个“type”，官方文档还给我们提出了例子解释，对于一个文件或者是字节流来说，“type”指的的数据类型；而对于packages和bundles来说，“type”指的就是它们内部的目录层级结构。</p>\n</blockquote>\n<h1 id=\"UTI用途\"><a href=\"#UTI用途\" class=\"headerlink\" title=\"UTI用途\"></a>UTI用途</h1><p>大多数情况下，一个UTI提供的是系统中所有程序和服务都能够识别并且依赖的一个唯一的标识，这么讲可能有些太抽象，我们使用一下官方文档中给出的例子，比如一个JPEG类型的图片文件，在不同的环境下，可以有下面几种不同的标识方法：</p>\n<blockquote>\n<ol>\n<li>‘JPEG’, OSType表示,</li>\n<li>‘.jpg’, 文件扩展名</li>\n<li>‘.jpeg’, 文件扩展名</li>\n<li>‘image/jpeg’, MIME(多用途互联网邮件扩展类型)中的一种类型</li>\n</ol>\n</blockquote>\n<p>而UTI则是用‘public.jpeg’这个字符串标识，完全代替了这些不一致的标签，这个字符串和其他任何一个旧标签都是完全兼容的，而且他们之间可以相互转换。由于UTI可以标识任何类型的实体，所以他们相对于旧标签来说灵活性更强了；使用UTI我们可以表示下面这些实体：</p>\n<blockquote>\n<ul>\n<li>Pasteboard data</li>\n<li>Folders (directories)</li>\n<li>Bundles</li>\n<li>Frameworks</li>\n<li>Streaming data</li>\n<li>Aliases and symbolic links</li>\n</ul>\n</blockquote>\n<h1 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h1><h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><p>Apple给我们提供了在iOS和Mac应用中通用的UTI字符串集合，比如，’public.data’、’public.item’、’public.image’等，这些我们都可以在官方文档中进行查阅他们的涵义。除此之外，我们也可以在应用程序中自定义自己的UTI字符串，比如我们可以定义一个标识特殊文档格式的UTI字符串叫’io.github.serazheng’，如果其他的应用程序想要支持我们这种格式的文档，他们就可以用’io.github.serazheng’来标识我们的文档。</p>\n<h3 id=\"2-字符集\"><a href=\"#2-字符集\" class=\"headerlink\" title=\"2. 字符集\"></a>2. 字符集</h3><p>看到我们上边的举例了，那么我们来说一下定义UTI字符串时所用到的字符集。通常一个UTI字符串是一个包含ASCII字符的Unicode字符串，同时也可以加入罗马字母和阿拉伯数字，如（A-Z）,（a-z），（0-9）还有点号（”.”）和连接符(“-“)。而任何包含非法字符的字符串，如包含下划线’_’，都无法作为UTI来标识内容，而且Apple不会有任何错误反馈。</p>\n<h3 id=\"3-语法\"><a href=\"#3-语法\" class=\"headerlink\" title=\"3. 语法\"></a>3. 语法</h3><p>就像我上面的例子一样，UTI的定义和我们开发iOS程序时填写organization时一样，采取的是反域名规则。如下面这几种：</p>\n<blockquote>\n<ul>\n<li>com.apple.quicktime-movie</li>\n<li>com.mycompany.myapp.myspecialfiletype</li>\n<li>public.html</li>\n<li>com.apple.pict</li>\n<li>public.jpeg</li>\n</ul>\n</blockquote>\n<p>而UTI中的域名，如‘com’、‘public’这些，仅仅是用来表示这个UTI字符串在域名层级中的位置，它不会影响任何相似类型的分组。比如，‘public’域名就是大部分应用程序用来标识标准类型的，而目前仅仅只有Apple可以创建‘public’域名的UTI。</p>\n<p>另外，我们可能会碰到的是一种‘dyn’域名，是动态域名，意思就是我们使用中，不会指定这种类型的UTI为某一个字符串，然后系统运行过程中，会自动识别帮我们处理。针对这种动态标识，我们是看不到的，但是我们可以通过UTI字符串的操作方式转换成我们的常用类型，比如OSType,MIME类型等。</p>\n<blockquote>\n<p>官方文档中，对动态标识有个比喻:“You can think of a dynamic identifier as a UTI-compatible wrapper around an otherwise unknown filename extension, MIME type, OSType, and so on”，大概意思就是我们可以把这种动态标识当做是针对普通类型进行了重写包装的，而且是兼容UTI的一种标识。</p>\n</blockquote>\n<p>最后一种就是可以自定义的域名，代表性的就是‘com’域名，Apple也给我们提供了一些他们定义的’com’域名的UTI。</p>\n<h1 id=\"顺应性\"><a href=\"#顺应性\" class=\"headerlink\" title=\"顺应性\"></a>顺应性</h1><p>UTI相对于其他那些旧标签的一个关键优势就是在于，它可以在一个顺应结构中声明。而用我们面向对象的方式说，UTI就是可继承的，而且是多继承方式。先上图：<br><img src=\"https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/understanding_utis/art/conformance_hierarchy.gif\" alt=\"UTI继承结构\"></p>\n<p>如上图所示，‘public.html’这个UTI就是继承于‘public.text’这个UTI，因为‘public.html’标识的是HTML文本格式，也属于是文本格式的一种，而文本、图片等等这些内容又都属于是数据的一种，所以他们继承于’public.data’这个UTI。</p>\n<p>上面这个UTI继承结构图，指的是UTI中的内容形式的继承结构，此外，原则上来说，指定UTI层次的时候，即可以指定它的功能结构，也可以指定它的物理结构，上图是就是一个内容形式的功能结构图.物理结构指的就是这个UTI的物理实质，比如它标识一个目录，一个文件等，而功能结构指的就是这个UTI的用图，比如同样是文件，它标识的可以是图片、视频等等。 而官方文档也给出了一般指定UTI层次结构的规则：</p>\n<ol>\n<li>一个UTI在物理层次上需要继承‘public.item’</li>\n<li>一个UTI在功能层次需要继承非’public.item’之外的UTI。</li>\n</ol>\n<p>然而，指定UTI的功能层次并不是强制的，但是这样做是考虑到可以更好地将UTI集成到系统一些特性中，就比如Spotlight应用，就可以把我们指定的功能性UTI和命名属性联系起来。下面是一个UTI功能顺应结构和物理顺应结构图：<br> <img src=\"https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/understanding_utis/art/physical_vs_functional.gif\" alt=\"UTI功能结构和物理结构\"></p>\n<p>这个顺应性使得我们的UTI在决定类型上拥有更高的灵活性，不仅避免了大量的条件判断的使用，而且还可以关联你想不到的一些类型。</p>\n<h1 id=\"使用UTI\"><a href=\"#使用UTI\" class=\"headerlink\" title=\"使用UTI\"></a>使用UTI</h1><h3 id=\"1-应用场景\"><a href=\"#1-应用场景\" class=\"headerlink\" title=\"1. 应用场景\"></a>1. 应用场景</h3><p>在Mac OS中我们开发应用时我们可以经常使用到UTI，但是在开发iOS应用程序时，我们应用到UTI的场景不是很多，这也是现在网上教程偏少得原因。而在iOS开发中，一般我们使用UTI来标识剪贴板的类型。而在具体使用到Apple给我们提供的UTI字符串的时候，我们必须使用在UTCoreTypes.h文件中定义的常量来代替直接使用字符串。关于UIPasteboard的详细使用，大家可以去这篇博客中详细学习一下：<a href=\"http://blog.csdn.net/zhangao0086/article/details/7580654\">精通UIPasteboard粘贴板</a>。</p>\n<h3 id=\"2-操作方法\"><a href=\"#2-操作方法\" class=\"headerlink\" title=\"2. 操作方法\"></a>2. 操作方法</h3><p>现在我们来看一下苹果提供的一些直接操作UTI的函数方法，简单列举几个。我们可以在MobileCoreServices这个framework中的UIType.h文件中找到，我们也可以仔细的看一下这个framework中的其他文件，都是对UTI的一些定义和声明。</p>\n<ul>\n<li>UITypeEqual</li>\n</ul>\n<p>判断俩个UTI是否完全一样，后者是一个动态标签说明是否是另外一个UTI标签说明的子集。</p>\n<ul>\n<li>UITypeConformsTo</li>\n</ul>\n<p>判断俩个标签的顺应性，用面向对象的角度理解，就是判断是否是子类。</p>\n<ul>\n<li>UTTypeCreatePreferredIdentifierForTag</li>\n</ul>\n<p>通过其他类型标识符，如MIME标识符，转换成UTI，当可以创建多个UTI字符串时，一般返回’public’域名的UTI。</p>\n<ul>\n<li>UTTypeCreateAllIdentifiersForTag</li>\n</ul>\n<p>通过其他类型标识符，如MIME标识符，转换成UTI，当可以创建多个UTI字符串时，返回所有的UTIs,让你自己选</p>\n<ul>\n<li>UTTypeCopyPreferredTagWithClass</li>\n</ul>\n<p>交换UTI字符串标识</p>\n<h1 id=\"自定义UTI\"><a href=\"#自定义UTI\" class=\"headerlink\" title=\"自定义UTI\"></a>自定义UTI</h1><h3 id=\"1-用法\"><a href=\"#1-用法\" class=\"headerlink\" title=\"1. 用法\"></a>1. 用法</h3><p>苹果允许Mac开发者为他们的Mac App中独有的数据格式自定义新的UTI。它们一般被声明在下面几个文件中</p>\n<blockquote>\n<ul>\n<li>Info.plist</li>\n<li>Application bundles</li>\n<li>Spotlight Importer bundles</li>\n<li>Automator action bundles</li>\n</ul>\n</blockquote>\n<p>使用官方给我们的一个UTI声明的例子，Public.jpeg声明：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTExportedTypeDeclarations<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTTypeIdentifier<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>public.jpeg<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTTypeReferenceURL<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>http://www.w3.org/Graphics/JPEG/<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTTypeDescription<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>JPEG image<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTTypeIconFile<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>public.jpeg.icns<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTTypeConformsTo<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>public.image<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>public.data<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>UTTypeTagSpecification<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>com.apple.ostype<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>JPEG<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>public.filename-extension<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>jpeg<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>jpg<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>public.mime-type<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>image/jpeg<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>一个UTI声明的属性列表：</p>\n<p><section><br>    <div style=\"margin-top:1.667em;margin-bottom:1.667em;\"><br>        <table border=\"0\" cellspacing=\"0\" cellpadding=\"5\"><br>            <tbody><br>                <tr><br>                    <th scope=\"col\" style=\"font-weight:400;background-color:#93A5BB;padding:0.3em 0.667em;font-size:13px;color:#FFFFFF;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#9BB3CD;border-right-width:1px;border-right-style:solid;border-right-color:#9BB3CD;\"><br>                        <p style=\"font-weight:700;line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;margin-bottom:0.33em;\"><br>                            Key<br>                        </p><br>                    </th><br>                    <th scope=\"col\" style=\"font-weight:400;background-color:#93A5BB;padding:0.3em 0.667em;font-size:13px;color:#FFFFFF;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#9BB3CD;border-right-width:1px;border-right-style:solid;border-right-color:#9BB3CD;\"><br>                        <p style=\"font-weight:700;line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;margin-bottom:0.33em;\"><br>                            Value type<br>                        </p><br>                    </th><br>                    <th scope=\"col\" style=\"font-weight:400;background-color:#93A5BB;padding:0.3em 0.667em;font-size:13px;color:#FFFFFF;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#9BB3CD;border-right-width:1px;border-right-style:solid;border-right-color:#9BB3CD;\"><br>                        <p style=\"font-weight:700;line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;margin-bottom:0.33em;\"><br>                            Description<br>                        </p><br>                    </th><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTExportedTypeDeclarations</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            array of dictionaries<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            An array of exported UTI declarations (that is, identifiers owned by the bundle’s publisher).<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTImportedTypeDeclarations</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            array of dictionaries<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            An array of imported UTI declarations (that is, identifiers owned by another company or organization).<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeIdentifier</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            string<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            The UTI for the declared type. This key is required for UTI declarations.<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeTagSpecification</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            dictionary<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            A dictionary defining one or more equivalent type identifiers.<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeConformsTo</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            array of strings<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            The UTIs to which this identifier conforms.<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeIconFile</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            string<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            The name of the bundle icon resource to associate with this UTI.<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeDescription</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            string<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            A user-visible description of this type. You can localize this string by including it in an <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">InfoPlist.strings</code> file.<br>                        </p><br>                    </td><br>                </tr><br>                <tr><br>                    <td scope=\"row\"><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            <code style=\"font-family:Courier, Consolas, monospace;color:#666666;\">UTTypeReferenceURL</code><br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            string<br>                        </p><br>                    </td><br>                    <td><br>                        <p style=\"line-height:normal;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;\"><br>                            The URL of a reference document describing this type.<br>                        </p><br>                    </td><br>                </tr><br>            </tbody><br>        </table><br /><br>    </div><br></section></p>\n<p><section><br>    <a name=\"//apple_ref/doc/uid/TP40001319-CH204-SW4\" title=\"Recommendations for Declaring new Uniform Type Identifiers\" style=\"color:#3366CC;font-family:'Lucida Grande', 'Lucida Sans Unicode', Helvetica, Arial, Verdana, sans-serif;font-size:13px;background-color:#FFFFFF;\"></a><br></section></p>\n<p><br>    <br /><br> </p>\n\n<p>而且自定义的UTI必须指定UTExportedTypeDeclarations或者UTImportedTypeDeclarations，这样如果是你定义的UTI，第三方应用程序和服务都可以使用，而如果是其他人定义的UTI，那么加入到你的项目中后，你就可以看到这种类型的数据。</p>\n<blockquote>\n<p>而官方文档中有一句话:“If both imported and exported declarations for a UTI exist, the exported declaration takes precedence over imported one”，我的理解是，被导出去得UTI声明所有人是定义UTI的发布者，也就是你的项目，而被导入的UTI声明所有人就是其他人，所以就是说如果对于一个UTI来说，俩种类型的声明都存在，则自己定义的UTI声明优先使用。</p>\n</blockquote>\n<h3 id=\"2-自定义UTI的建议\"><a href=\"#2-自定义UTI的建议\" class=\"headerlink\" title=\"2. 自定义UTI的建议\"></a>2. 自定义UTI的建议</h3><ol>\n<li>你的UTI字符串必须是唯一的。以‘com.’开头的反域名命名方式是确保唯一性的简单有效的方法。</li>\n<li>如果你的代码依赖于第三方App，UTI类型或许不会在系统中展示，你应该在bundle中声明为导入类型</li>\n<li>如果你的UTI类型是一个或多个已存在的UTI类型的子类，则必须给它添加顺应性，让它继承于某个父类。最好是继承于‘public’类型。</li>\n</ol>"},{"layout":"post","title":"重写prepareForReuse来重用UITableViewCell","date":"2015-08-14T16:00:00.000Z","description":"描述为什么重写prepareForReuse以及如何重用UITableViewCell","_content":"\n# 前言\n借用一下Apple官方的话,`\"出于性能考虑，一个表视图的单元必须是可复用的\"`。重用cell的机制是利用缓冲池，将可重用的cell保存起来，显示cell时，先从缓冲池中取，如果缓冲池中没有此类的cell，也就是没有可重用的cell，此时就会重新初始化一份cell，并且加到缓冲池中。\n<!-- more -->\n# 获取可重用的cell\n而取出缓冲池中的cell，需要用到`dequeueReusableCellwithIdentifier:`方法：\n{% codeblock lang:objc %}\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath(NSIndexPath*)indexPath  {\n    UITableViewCellStyle style = UITableViewCellStyleSubtitle;\n    staticNSString *cellID = @\"cell\";\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID];\n    if (cell == nil) {\n        cell = [[[UITableViewCellalloc] initWithStyle:style reuseIdentifier:@\"cell\"] autorelease];\n        cell.detailTextLabel.text = [NSString stringWithFormat:@\"Cell %d\",++count]; //当分配内存时标记\n    }\n    cell.textLabel.text = [NSString stringWithFormat:@\"Cell %d\",[indexPath row] + 1];  //当新显示一个Cell时标记\n    return cell;\n}\n{% endcodeblock %}\n\n# prepareForReuse调用时机\n在重用cell的时候，如果每个cell中都有不同的子视图或者是需要发送不同的网络请求，此时在应用`dequeueReusableCellWithIdentifier:`方法时就会出现视图重叠的情况，针对于此种情况，我们就需要在自定义的cell中重写`prepareForReuse`方法。因为当屏幕滚动导致一个cell消失，另外一个cell显示时，系统就会发出`prepareForReuse`的通知，此时，我们需要在重载的`prepareForReuse`方法中，将所有的子视图隐藏，并且将内容置空。这样就不会出现重叠现象。","source":"_posts/重写prepareForReuse来重用UITableViewCell.md","raw":"---\nlayout: post\ntitle: 重写prepareForReuse来重用UITableViewCell\ndate: 2015-08-15\ndescription: \"描述为什么重写prepareForReuse以及如何重用UITableViewCell\"\ntags: [UIKit]\ncategories: [iOS]\n---\n\n# 前言\n借用一下Apple官方的话,`\"出于性能考虑，一个表视图的单元必须是可复用的\"`。重用cell的机制是利用缓冲池，将可重用的cell保存起来，显示cell时，先从缓冲池中取，如果缓冲池中没有此类的cell，也就是没有可重用的cell，此时就会重新初始化一份cell，并且加到缓冲池中。\n<!-- more -->\n# 获取可重用的cell\n而取出缓冲池中的cell，需要用到`dequeueReusableCellwithIdentifier:`方法：\n{% codeblock lang:objc %}\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath(NSIndexPath*)indexPath  {\n    UITableViewCellStyle style = UITableViewCellStyleSubtitle;\n    staticNSString *cellID = @\"cell\";\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID];\n    if (cell == nil) {\n        cell = [[[UITableViewCellalloc] initWithStyle:style reuseIdentifier:@\"cell\"] autorelease];\n        cell.detailTextLabel.text = [NSString stringWithFormat:@\"Cell %d\",++count]; //当分配内存时标记\n    }\n    cell.textLabel.text = [NSString stringWithFormat:@\"Cell %d\",[indexPath row] + 1];  //当新显示一个Cell时标记\n    return cell;\n}\n{% endcodeblock %}\n\n# prepareForReuse调用时机\n在重用cell的时候，如果每个cell中都有不同的子视图或者是需要发送不同的网络请求，此时在应用`dequeueReusableCellWithIdentifier:`方法时就会出现视图重叠的情况，针对于此种情况，我们就需要在自定义的cell中重写`prepareForReuse`方法。因为当屏幕滚动导致一个cell消失，另外一个cell显示时，系统就会发出`prepareForReuse`的通知，此时，我们需要在重载的`prepareForReuse`方法中，将所有的子视图隐藏，并且将内容置空。这样就不会出现重叠现象。","slug":"重写prepareForReuse来重用UITableViewCell","published":1,"updated":"2016-04-12T06:48:30.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9v4002l94sulw02qhcr","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>借用一下Apple官方的话,<code>&quot;出于性能考虑，一个表视图的单元必须是可复用的&quot;</code>。重用cell的机制是利用缓冲池，将可重用的cell保存起来，显示cell时，先从缓冲池中取，如果缓冲池中没有此类的cell，也就是没有可重用的cell，此时就会重新初始化一份cell，并且加到缓冲池中。<br><a id=\"more\"></a></p>\n<h1 id=\"获取可重用的cell\"><a href=\"#获取可重用的cell\" class=\"headerlink\" title=\"获取可重用的cell\"></a>获取可重用的cell</h1><p>而取出缓冲池中的cell，需要用到<code>dequeueReusableCellwithIdentifier:</code>方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath(<span class=\"built_in\">NSIndexPath</span>*)indexPath  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UITableViewCellStyle</span> style = <span class=\"built_in\">UITableViewCellStyleSubtitle</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span><span class=\"built_in\">NSString</span> *cellID = <span class=\"string\">@\"cell\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:cellID];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cell == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        cell = [[[<span class=\"built_in\">UITableViewCellalloc</span>] initWithStyle:style reuseIdentifier:<span class=\"string\">@\"cell\"</span>] autorelease];</span><br><span class=\"line\">        cell.detailTextLabel.text = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Cell %d\"</span>,++count]; <span class=\"comment\">//当分配内存时标记</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cell.textLabel.text = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Cell %d\"</span>,[indexPath row] + <span class=\"number\">1</span>];  <span class=\"comment\">//当新显示一个Cell时标记</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"prepareForReuse调用时机\"><a href=\"#prepareForReuse调用时机\" class=\"headerlink\" title=\"prepareForReuse调用时机\"></a>prepareForReuse调用时机</h1><p>在重用cell的时候，如果每个cell中都有不同的子视图或者是需要发送不同的网络请求，此时在应用<code>dequeueReusableCellWithIdentifier:</code>方法时就会出现视图重叠的情况，针对于此种情况，我们就需要在自定义的cell中重写<code>prepareForReuse</code>方法。因为当屏幕滚动导致一个cell消失，另外一个cell显示时，系统就会发出<code>prepareForReuse</code>的通知，此时，我们需要在重载的<code>prepareForReuse</code>方法中，将所有的子视图隐藏，并且将内容置空。这样就不会出现重叠现象。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>借用一下Apple官方的话,<code>&quot;出于性能考虑，一个表视图的单元必须是可复用的&quot;</code>。重用cell的机制是利用缓冲池，将可重用的cell保存起来，显示cell时，先从缓冲池中取，如果缓冲池中没有此类的cell，也就是没有可重用的cell，此时就会重新初始化一份cell，并且加到缓冲池中。<br>","more":"</p>\n<h1 id=\"获取可重用的cell\"><a href=\"#获取可重用的cell\" class=\"headerlink\" title=\"获取可重用的cell\"></a>获取可重用的cell</h1><p>而取出缓冲池中的cell，需要用到<code>dequeueReusableCellwithIdentifier:</code>方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath(<span class=\"built_in\">NSIndexPath</span>*)indexPath  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UITableViewCellStyle</span> style = <span class=\"built_in\">UITableViewCellStyleSubtitle</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span><span class=\"built_in\">NSString</span> *cellID = <span class=\"string\">@\"cell\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:cellID];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cell == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        cell = [[[<span class=\"built_in\">UITableViewCellalloc</span>] initWithStyle:style reuseIdentifier:<span class=\"string\">@\"cell\"</span>] autorelease];</span><br><span class=\"line\">        cell.detailTextLabel.text = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Cell %d\"</span>,++count]; <span class=\"comment\">//当分配内存时标记</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cell.textLabel.text = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"Cell %d\"</span>,[indexPath row] + <span class=\"number\">1</span>];  <span class=\"comment\">//当新显示一个Cell时标记</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"prepareForReuse调用时机\"><a href=\"#prepareForReuse调用时机\" class=\"headerlink\" title=\"prepareForReuse调用时机\"></a>prepareForReuse调用时机</h1><p>在重用cell的时候，如果每个cell中都有不同的子视图或者是需要发送不同的网络请求，此时在应用<code>dequeueReusableCellWithIdentifier:</code>方法时就会出现视图重叠的情况，针对于此种情况，我们就需要在自定义的cell中重写<code>prepareForReuse</code>方法。因为当屏幕滚动导致一个cell消失，另外一个cell显示时，系统就会发出<code>prepareForReuse</code>的通知，此时，我们需要在重载的<code>prepareForReuse</code>方法中，将所有的子视图隐藏，并且将内容置空。这样就不会出现重叠现象。</p>"},{"layout":"post","title":"通过UIDocumentInteractionController预览和分享","date":"2015-12-04T16:00:00.000Z","description":"介绍UIDocumentInteractionController以及如何在iOS系统上实现跨App之间的内容分享","_content":"\n# 前言\n朋友分享推荐给我一本PDF格式的`史蒂夫•乔布斯传`，阅读了几篇，很受感触，于是想把他分享给大家欣赏阅读。早起闲来无事，正好就接着写篇文章来分享一下！我在“[iOS实现App之间的内容分享](http://www.jianshu.com/p/88a08d66894f)”这篇文章中详细讲解了通过注册UTI的方式让我们的App支持分享，也简单地说了一下App内部怎么处理分享。同时，我也指出了在iOS系统跨App分享内容的几种常用技术，比如`URL Scheme`,`AirDrop`, `UIDocumentInteractionController`,`UIActivityViewController`这几种。这一篇文章，我们来谈一下最基础的原始方法，怎么通过使用`UIDocumentInteractionController`来预览、操作和分享`史蒂夫•乔布斯传`。\n<!-- more -->\n# 简介\n从iOS SDK的API文档中，我们可以找到`UIDocumentInteractionController`的声明:\n{% codeblock lang:objc %}\nNS_CLASS_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED @interface UIDocumentInteractionController : NSObject <UIActionSheetDelegate>\n{% endcodeblock %}\n\n由此声明我们可以得知，`UIDocumentInteractionController`是从iOS 3.2的SDK开始支持的，它是直接继承的`NSObject`，而不是我们想象的`UIViewController`，因此我们需要使用`UIDocumentInteractionController`提供的方法来展示它，而且我们还可以看出它是不能在Apple TV 的开发中使用的。遍观`UIDocumentInteractionController`的属性和方法可以看出，`UIDocumentInteractionController`主要给我们提供了三种用途，我会在下面的内容中逐条的讲解`UIDocumentInteraction`的每一种用途的具体使用：\n\n1. 展示一个可以操作我们分享的文档类型的第三方App列表\n2. 在第一条展示列表的基础上添加额外的操作，比如`复制`，`打印`，`预览`，`保存`等。\n3. 结合`Quick Look`框架直接展示文档内容\n\n# 准备阶段\n首先我创建了一个新的应用方便演示和截图，我把它命名为`ZSDocumentInteractionTest`，然后拖入PDF格式的`史蒂夫•乔布斯传`到`ZSDocumentInteractionTest`项目的bundle中。然后在`Storyboard`的`ViewController`中添加了一个Button作为`UIDocumentInteractionController`的触发操作(这些操作都比较简单，就不在这里用图展示啦)。运行程序，我们就可以看到Button啦，截图如下。然后我们就可以在Button的触发方法中，操作`UIDocumentInteractionController`来显示或者分享我们的`史蒂夫•乔布斯传`啦，具体的应用详情可以参考GitHub上的Demo：[ZSDocumentInteractionTest](https://github.com/SeraZheng/ZSDocumentInteractionTest)。\n\n{% img /images/显示Button.png %}\n\n# 初始化\n不管我们使用哪种`UIDocumentInteractionController`的展示方式和用途，都需要给`UIDocumentInteractionController`指定文档的URL，所以我们通常使用下面的初始化方式，给`UIDocumentInteractionController`指定`文件的URL`。\n{% codeblock lang:objc %}\n- (IBAction)presentPDFDocumentInteraction:(id)sender {\n    UIDocumentInteractionController *documentController = [UIDocumentInteractionController interactionControllerWithURL:[[NSBundle mainBundle] URLForResource:@\"Steve\" withExtension:@\"pdf\"]];\n}\n{% endcodeblock %}\n\n# 展示第三方App列表\n我们先实现`UIDocumentInteractionController`的第一个用途，展示可以操作PDF文件的第三方App列表。我们需要使用`UIDocumentInteractionController`提供的方法：\n{% codeblock lang:objc %}\n- (BOOL)presentOpenInMenuFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated;\n{% endcodeblock %}\n\n我在Button的触发方法中添加下面的代码,意思就是让`UIDocumentInteractionController`的View在当前控制器视图上显示：\n{% codeblock lang:objc %}\n    [documentController presentOpenInMenuFromRect:self.view.bounds inView:self.view animated:YES];\n{% endcodeblock %}\n\n运行程序，点击Button，我们可以开始第一次展示测试啦。\n\n# 第一次展示测试\n一切准备就绪之后，我开始进行`UIDocumentInteractionController`的测试，点击Button，就可以看到下面的界面啦。这说明我们的第一步成功了!!(真棒)\n\n{% img /images/展示图标.png %}\n\n简单介绍一下这个界面，这个视图中的第一行列表显示`AirDrop`，是苹果在`iOS 7`提供的一种跨设备分享的技术，我会在后边的文章中讲解。视图中的第二行列表就是整个iOS系统中，可以操作PDF文档的应用程序列表，还包括了苹果在`iOS 8`提供的`Share Extension`图标，关于`Share Extension`，我会在后边的文章中讲解。视图中的第三行列表，就是现实设备可选的操作，如`Copy`,`Print`中，这里什么操作都没有，并不是说没有可执行的操作，而是我们没有让他显示出来。\n\n接着我试着点击QQ图标，打算把`史蒂夫•乔布斯传`分享给我的好友，然而意外发生了，`ZSDocumentInteractionTest`崩溃掉啦，而且还给出我们一段错误提示：\n{% codeblock lang:bash %}\n2015-12-30 19:00:40.078 ZSDocumentInteractionTest[1254:344240] *** Assertion failure in -[_UIOpenWithAppActivity performActivity], /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit/UIKit-3512.29.5/UIDocumentInteractionController.m:408\n2015-12-30 19:00:40.079 ZSDocumentInteractionTest[1254:344240] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'UIDocumentInteractionController has gone away prematurely!'\n*** First throw call stack:\n(0x248e185b 0x35fa2dff 0x248e1731 0x25672ddb 0x290638c9 0x292695bb 0x28d5aefd 0x28d5e1a1 0x28b42107 0x28a50a55 0x28a50531 0x28a5042b 0x282e05cf 0x1acd03 0x1b17c9 0x248a4535 0x248a2a2f 0x247f50d9 0x247f4ecd 0x2db6aaf9 0x28a7e2dd 0x780ad 0x366f0873)\nlibc++abi.dylib: terminating with uncaught exception of type NSException\n{% endcodeblock %}\n\n我看到错误提示竟然指向了`UIDocumentInteractionController.m`文件，而且错误提示是`NSInternalInconsistencyException`(内部不一致)和\"UIDocumentInteractionController has gone away prematurely!\"(UIDocumentInteractionController过早地被释放掉啦)。由此我想出这个应该是内存过早释放的一个错误，然后我查阅了一下Apple Developer上的文档，原来，在ARC环境下展示`UIDocumentInteractionController`时，当我的函数方法调用完毕，退栈之后，`UIDocumentInteractionController`的实例就被释放掉了，展示出来的这个View由`Quick Look`框架来操作，并不会对`UIDocumentInteractionController`产生引用。当点击View上面的Button时，内部操作仍然会继续访问这个`UIDocumentInteractionController`实例，就会报出上述错误。\n\n错误原因找到了，那么解决原理也就清楚了，只要不让`UIDocumentInteractionController`实例过早释放就可以啦。我们可以将`UIDocumentInteractionController`声明为一个`strong`类型的实例属性，然后修改一下Button触发方法就可以啦。(仍然不理解的朋友可以去GitHub上下载Demo测试)\n{% codeblock lang:objc %}\n@interface ViewController ()\n@property (nonatomic, strong) UIDocumentInteractionController *documentController;\n@end\n{% endcodeblock %}\n\n我在Button的触发方法中添加下面方法的调用,为了方便区分和理解，我把代码封装成了私有实例方法：\n{% codeblock lang:objc %}\n- (void)presentOpenInMenu\n{\n    // display third-party apps\n    [self.documentController presentOpenInMenuFromRect:self.view.bounds inView:self.view animated:YES];\n}\n\n- (IBAction)presentPGNDocumentInteraction:(id)sender {\n    _documentController = [UIDocumentInteractionController interactionControllerWithURL:[[NSBundle mainBundle] URLForResource:@\"Steve\" withExtension:@\"pdf\"]];\n    [self presentOpenInMenu];\n}\n{% endcodeblock %}\n\n修改完之后，运行程序，然后点击Button，看到第一次测试时展示出来的图片啦。然后再点QQ图标，就可以正确地跳转到QQ程序中，选择好友就可以分享`史蒂夫•乔布斯传`啦。（QQ接收分享页面就不展示了，想试验的可以手动测试下)\n\n# 展示可选操作\n我们可以看到第一步图示里面只有App图标，第二行操作列表中只有一个`More`。所以我们来展示`UIDocumentInteractionController`的第二种用途，在第一步的基础之上，显示附加的操作选项，。这需要我们使用`UIDocumentInteractionController`提供的另外一种展示方法：\n{% codeblock lang:objc %}\n- (BOOL)presentOptionsMenuFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated;\n{% endcodeblock %}\n我们在Button的触发方法中添加下面方法的调用：\n{% codeblock lang:objc %}\n- (void)presentOptionsMenu\n{\n    // display third-party apps as well as actions, such as Copy, Print, Save Image, Quick Look\n    [_documentController presentOptionsMenuFromRect:self.view.bounds inView:self.view animated:YES];\n}\n{% endcodeblock %}\n运行程序，点击Button,我们可以看到下面的界面，多了`Copy`和`Print`的操作。`Copy`操作可以将文件拷贝到系统粘贴板中，而`Print`操作则是关联打印机进行打印操作的。（在这里我就不展示这俩种操作的具体界面啦！）\n\n{% img /images/附加操作.png %}\n\n如果`UIDocumentInteractionController`关联的是一个图片文件，这个界面还会提供一个`Save Image`的操作，用来直接保存图片到系统的`Photos`中，此外这个界面还提供了一个`Quick Look`操作，可以让我们直接预览`乔布斯自传`PDF文档，只不过需要我们再多写点代码，为了文章的合理性和结构性，我决定在下面的标题内容中讲解。(先卖个小关子！！)\n\n# 直接预览\n`UIDocumentInteractionController`第三种预览文档内容的用途非常重要，而且也是常见的。我会详细地说一下如何通过`UIDocumentInteractionController`实现预览`史蒂夫•乔布斯传`。首先你需要为`UIDocumentInteractionController`指定一个delegate，并且实现下面的代理方法：\n{% codeblock lang:objc %}\n- (UIViewController *)documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)controller;\n{% endcodeblock %}\n\n这个代理方法主要是用来指定`UIDocumentInteractionController`要显示的视图所在的父视图容器。这样`UIDocumentInteractionController`才清楚在哪里展示`Quick Look`预览内容， 我在这里就指定Button所在的UIViewController来做`UIDocumentInteractionController`的代理对象，并且实现上面的代理方法。在Button的触发方法中添加下面的代码\n\n{% codeblock lang:objc %}\n_documentController.delegate = self;\n{% endcodeblock %}\n然后实现代理方法：\n{% codeblock lang:objc %}\n- (UIViewController *)documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)controller\n{\n    return self;\n}\n{% endcodeblock %}\n`UIDocumentInteractionController`是继承自`NSObject`的，因而为了能够实现直接预览，我们需要用到`UIDocumentInteractionController`提供的展示预览的方法，\n{% codeblock lang:objc %}\n- (BOOL)presentPreviewAnimated:(BOOL)animated;\n{% endcodeblock %}\n这个方法是以模态窗口通过Quick Look框架全屏显示PDF的内容，所以我们在Button的触发方法中添加下面方法的调用：\n{% codeblock lang:objc %}\n- (void)presentPreview\n{\n    // display PDF contents by Quick Look framework\n    [self.documentController presentPreviewAnimated:YES];\n}\n{% endcodeblock %}\n然后运行程序，点击Button，弹出了一个新视图，可以看到`史蒂夫•乔布斯传`的内容，如下图\n{% img /images/直接预览.png %}\n\n# 展示预览操作\n通过上面的操作我们就可以欣赏阅读我们想看的`史蒂夫•乔布斯传`啦，不过别忘记我们上面还卖了一个小关子，就是在展示可选操的时候，除了`Copy `，`Print`，其实我们还可以展示`Quick Look`这个预览操作。为什么我要卖关子呢，因为我是一个相信因果循环的人，我组织文章的逻辑是由浅入深，我设想通过一步步铺垫来展开`UIDocumentInteractionController`所有特性。\n\n好啦，回归正题！我们想要实现显示`Quick Look`预览操作，其大部分的工作在`直接预览`这一小节中都做完了，比如指定代理对象，然后实现这个代理方法来指定`UIDocumentInteractionController`的父视图容器：\n\n{% codeblock lang:objc %}\n- (UIViewController *)documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)controller;\n{% endcodeblock %}\n\n由于我们已经做完了所有准备，在这一步，我们只需要将直接展示`史蒂夫•乔布斯传`内容的方法替换为下面这段，展示`可选操作列表`的方法,就可以啦！\n{% codeblock lang:objc %}\n- (void)presentOptionsMenu\n{\n    // display third-party apps as well as actions, such as Copy, Print, Save Image, Quick Look\n    [_documentController presentOptionsMenuFromRect:self.view.bounds inView:self.view animated:YES];\n}\n{% endcodeblock %}\n然后我们运行程序，点击Button，就可以看到`Quick Look`操作已经显示出来啦！如下图：\n{% img /images/QuickLook.png %}\n\n如果我们点击这个`Quick Look`操作，就可以看到直接预览内容时所展示的界面啦。好啦，通过`UIDocumentInteractionController`实现`史蒂夫•乔布斯传`的预览和分享就到此结束啦。我会在下面的章节中，讲解通过其他技术实现`乔布斯自传`的分享和操作。","source":"_posts/通过UIDocumentInteractionController预览和分享.md","raw":"---\nlayout: post\ntitle: 通过UIDocumentInteractionController预览和分享\ndate: 2015-12-05\ndescription: \"介绍UIDocumentInteractionController以及如何在iOS系统上实现跨App之间的内容分享\"\ntags: [UTI]\ncategories: [iOS]\n---\n\n# 前言\n朋友分享推荐给我一本PDF格式的`史蒂夫•乔布斯传`，阅读了几篇，很受感触，于是想把他分享给大家欣赏阅读。早起闲来无事，正好就接着写篇文章来分享一下！我在“[iOS实现App之间的内容分享](http://www.jianshu.com/p/88a08d66894f)”这篇文章中详细讲解了通过注册UTI的方式让我们的App支持分享，也简单地说了一下App内部怎么处理分享。同时，我也指出了在iOS系统跨App分享内容的几种常用技术，比如`URL Scheme`,`AirDrop`, `UIDocumentInteractionController`,`UIActivityViewController`这几种。这一篇文章，我们来谈一下最基础的原始方法，怎么通过使用`UIDocumentInteractionController`来预览、操作和分享`史蒂夫•乔布斯传`。\n<!-- more -->\n# 简介\n从iOS SDK的API文档中，我们可以找到`UIDocumentInteractionController`的声明:\n{% codeblock lang:objc %}\nNS_CLASS_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED @interface UIDocumentInteractionController : NSObject <UIActionSheetDelegate>\n{% endcodeblock %}\n\n由此声明我们可以得知，`UIDocumentInteractionController`是从iOS 3.2的SDK开始支持的，它是直接继承的`NSObject`，而不是我们想象的`UIViewController`，因此我们需要使用`UIDocumentInteractionController`提供的方法来展示它，而且我们还可以看出它是不能在Apple TV 的开发中使用的。遍观`UIDocumentInteractionController`的属性和方法可以看出，`UIDocumentInteractionController`主要给我们提供了三种用途，我会在下面的内容中逐条的讲解`UIDocumentInteraction`的每一种用途的具体使用：\n\n1. 展示一个可以操作我们分享的文档类型的第三方App列表\n2. 在第一条展示列表的基础上添加额外的操作，比如`复制`，`打印`，`预览`，`保存`等。\n3. 结合`Quick Look`框架直接展示文档内容\n\n# 准备阶段\n首先我创建了一个新的应用方便演示和截图，我把它命名为`ZSDocumentInteractionTest`，然后拖入PDF格式的`史蒂夫•乔布斯传`到`ZSDocumentInteractionTest`项目的bundle中。然后在`Storyboard`的`ViewController`中添加了一个Button作为`UIDocumentInteractionController`的触发操作(这些操作都比较简单，就不在这里用图展示啦)。运行程序，我们就可以看到Button啦，截图如下。然后我们就可以在Button的触发方法中，操作`UIDocumentInteractionController`来显示或者分享我们的`史蒂夫•乔布斯传`啦，具体的应用详情可以参考GitHub上的Demo：[ZSDocumentInteractionTest](https://github.com/SeraZheng/ZSDocumentInteractionTest)。\n\n{% img /images/显示Button.png %}\n\n# 初始化\n不管我们使用哪种`UIDocumentInteractionController`的展示方式和用途，都需要给`UIDocumentInteractionController`指定文档的URL，所以我们通常使用下面的初始化方式，给`UIDocumentInteractionController`指定`文件的URL`。\n{% codeblock lang:objc %}\n- (IBAction)presentPDFDocumentInteraction:(id)sender {\n    UIDocumentInteractionController *documentController = [UIDocumentInteractionController interactionControllerWithURL:[[NSBundle mainBundle] URLForResource:@\"Steve\" withExtension:@\"pdf\"]];\n}\n{% endcodeblock %}\n\n# 展示第三方App列表\n我们先实现`UIDocumentInteractionController`的第一个用途，展示可以操作PDF文件的第三方App列表。我们需要使用`UIDocumentInteractionController`提供的方法：\n{% codeblock lang:objc %}\n- (BOOL)presentOpenInMenuFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated;\n{% endcodeblock %}\n\n我在Button的触发方法中添加下面的代码,意思就是让`UIDocumentInteractionController`的View在当前控制器视图上显示：\n{% codeblock lang:objc %}\n    [documentController presentOpenInMenuFromRect:self.view.bounds inView:self.view animated:YES];\n{% endcodeblock %}\n\n运行程序，点击Button，我们可以开始第一次展示测试啦。\n\n# 第一次展示测试\n一切准备就绪之后，我开始进行`UIDocumentInteractionController`的测试，点击Button，就可以看到下面的界面啦。这说明我们的第一步成功了!!(真棒)\n\n{% img /images/展示图标.png %}\n\n简单介绍一下这个界面，这个视图中的第一行列表显示`AirDrop`，是苹果在`iOS 7`提供的一种跨设备分享的技术，我会在后边的文章中讲解。视图中的第二行列表就是整个iOS系统中，可以操作PDF文档的应用程序列表，还包括了苹果在`iOS 8`提供的`Share Extension`图标，关于`Share Extension`，我会在后边的文章中讲解。视图中的第三行列表，就是现实设备可选的操作，如`Copy`,`Print`中，这里什么操作都没有，并不是说没有可执行的操作，而是我们没有让他显示出来。\n\n接着我试着点击QQ图标，打算把`史蒂夫•乔布斯传`分享给我的好友，然而意外发生了，`ZSDocumentInteractionTest`崩溃掉啦，而且还给出我们一段错误提示：\n{% codeblock lang:bash %}\n2015-12-30 19:00:40.078 ZSDocumentInteractionTest[1254:344240] *** Assertion failure in -[_UIOpenWithAppActivity performActivity], /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit/UIKit-3512.29.5/UIDocumentInteractionController.m:408\n2015-12-30 19:00:40.079 ZSDocumentInteractionTest[1254:344240] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'UIDocumentInteractionController has gone away prematurely!'\n*** First throw call stack:\n(0x248e185b 0x35fa2dff 0x248e1731 0x25672ddb 0x290638c9 0x292695bb 0x28d5aefd 0x28d5e1a1 0x28b42107 0x28a50a55 0x28a50531 0x28a5042b 0x282e05cf 0x1acd03 0x1b17c9 0x248a4535 0x248a2a2f 0x247f50d9 0x247f4ecd 0x2db6aaf9 0x28a7e2dd 0x780ad 0x366f0873)\nlibc++abi.dylib: terminating with uncaught exception of type NSException\n{% endcodeblock %}\n\n我看到错误提示竟然指向了`UIDocumentInteractionController.m`文件，而且错误提示是`NSInternalInconsistencyException`(内部不一致)和\"UIDocumentInteractionController has gone away prematurely!\"(UIDocumentInteractionController过早地被释放掉啦)。由此我想出这个应该是内存过早释放的一个错误，然后我查阅了一下Apple Developer上的文档，原来，在ARC环境下展示`UIDocumentInteractionController`时，当我的函数方法调用完毕，退栈之后，`UIDocumentInteractionController`的实例就被释放掉了，展示出来的这个View由`Quick Look`框架来操作，并不会对`UIDocumentInteractionController`产生引用。当点击View上面的Button时，内部操作仍然会继续访问这个`UIDocumentInteractionController`实例，就会报出上述错误。\n\n错误原因找到了，那么解决原理也就清楚了，只要不让`UIDocumentInteractionController`实例过早释放就可以啦。我们可以将`UIDocumentInteractionController`声明为一个`strong`类型的实例属性，然后修改一下Button触发方法就可以啦。(仍然不理解的朋友可以去GitHub上下载Demo测试)\n{% codeblock lang:objc %}\n@interface ViewController ()\n@property (nonatomic, strong) UIDocumentInteractionController *documentController;\n@end\n{% endcodeblock %}\n\n我在Button的触发方法中添加下面方法的调用,为了方便区分和理解，我把代码封装成了私有实例方法：\n{% codeblock lang:objc %}\n- (void)presentOpenInMenu\n{\n    // display third-party apps\n    [self.documentController presentOpenInMenuFromRect:self.view.bounds inView:self.view animated:YES];\n}\n\n- (IBAction)presentPGNDocumentInteraction:(id)sender {\n    _documentController = [UIDocumentInteractionController interactionControllerWithURL:[[NSBundle mainBundle] URLForResource:@\"Steve\" withExtension:@\"pdf\"]];\n    [self presentOpenInMenu];\n}\n{% endcodeblock %}\n\n修改完之后，运行程序，然后点击Button，看到第一次测试时展示出来的图片啦。然后再点QQ图标，就可以正确地跳转到QQ程序中，选择好友就可以分享`史蒂夫•乔布斯传`啦。（QQ接收分享页面就不展示了，想试验的可以手动测试下)\n\n# 展示可选操作\n我们可以看到第一步图示里面只有App图标，第二行操作列表中只有一个`More`。所以我们来展示`UIDocumentInteractionController`的第二种用途，在第一步的基础之上，显示附加的操作选项，。这需要我们使用`UIDocumentInteractionController`提供的另外一种展示方法：\n{% codeblock lang:objc %}\n- (BOOL)presentOptionsMenuFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated;\n{% endcodeblock %}\n我们在Button的触发方法中添加下面方法的调用：\n{% codeblock lang:objc %}\n- (void)presentOptionsMenu\n{\n    // display third-party apps as well as actions, such as Copy, Print, Save Image, Quick Look\n    [_documentController presentOptionsMenuFromRect:self.view.bounds inView:self.view animated:YES];\n}\n{% endcodeblock %}\n运行程序，点击Button,我们可以看到下面的界面，多了`Copy`和`Print`的操作。`Copy`操作可以将文件拷贝到系统粘贴板中，而`Print`操作则是关联打印机进行打印操作的。（在这里我就不展示这俩种操作的具体界面啦！）\n\n{% img /images/附加操作.png %}\n\n如果`UIDocumentInteractionController`关联的是一个图片文件，这个界面还会提供一个`Save Image`的操作，用来直接保存图片到系统的`Photos`中，此外这个界面还提供了一个`Quick Look`操作，可以让我们直接预览`乔布斯自传`PDF文档，只不过需要我们再多写点代码，为了文章的合理性和结构性，我决定在下面的标题内容中讲解。(先卖个小关子！！)\n\n# 直接预览\n`UIDocumentInteractionController`第三种预览文档内容的用途非常重要，而且也是常见的。我会详细地说一下如何通过`UIDocumentInteractionController`实现预览`史蒂夫•乔布斯传`。首先你需要为`UIDocumentInteractionController`指定一个delegate，并且实现下面的代理方法：\n{% codeblock lang:objc %}\n- (UIViewController *)documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)controller;\n{% endcodeblock %}\n\n这个代理方法主要是用来指定`UIDocumentInteractionController`要显示的视图所在的父视图容器。这样`UIDocumentInteractionController`才清楚在哪里展示`Quick Look`预览内容， 我在这里就指定Button所在的UIViewController来做`UIDocumentInteractionController`的代理对象，并且实现上面的代理方法。在Button的触发方法中添加下面的代码\n\n{% codeblock lang:objc %}\n_documentController.delegate = self;\n{% endcodeblock %}\n然后实现代理方法：\n{% codeblock lang:objc %}\n- (UIViewController *)documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)controller\n{\n    return self;\n}\n{% endcodeblock %}\n`UIDocumentInteractionController`是继承自`NSObject`的，因而为了能够实现直接预览，我们需要用到`UIDocumentInteractionController`提供的展示预览的方法，\n{% codeblock lang:objc %}\n- (BOOL)presentPreviewAnimated:(BOOL)animated;\n{% endcodeblock %}\n这个方法是以模态窗口通过Quick Look框架全屏显示PDF的内容，所以我们在Button的触发方法中添加下面方法的调用：\n{% codeblock lang:objc %}\n- (void)presentPreview\n{\n    // display PDF contents by Quick Look framework\n    [self.documentController presentPreviewAnimated:YES];\n}\n{% endcodeblock %}\n然后运行程序，点击Button，弹出了一个新视图，可以看到`史蒂夫•乔布斯传`的内容，如下图\n{% img /images/直接预览.png %}\n\n# 展示预览操作\n通过上面的操作我们就可以欣赏阅读我们想看的`史蒂夫•乔布斯传`啦，不过别忘记我们上面还卖了一个小关子，就是在展示可选操的时候，除了`Copy `，`Print`，其实我们还可以展示`Quick Look`这个预览操作。为什么我要卖关子呢，因为我是一个相信因果循环的人，我组织文章的逻辑是由浅入深，我设想通过一步步铺垫来展开`UIDocumentInteractionController`所有特性。\n\n好啦，回归正题！我们想要实现显示`Quick Look`预览操作，其大部分的工作在`直接预览`这一小节中都做完了，比如指定代理对象，然后实现这个代理方法来指定`UIDocumentInteractionController`的父视图容器：\n\n{% codeblock lang:objc %}\n- (UIViewController *)documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)controller;\n{% endcodeblock %}\n\n由于我们已经做完了所有准备，在这一步，我们只需要将直接展示`史蒂夫•乔布斯传`内容的方法替换为下面这段，展示`可选操作列表`的方法,就可以啦！\n{% codeblock lang:objc %}\n- (void)presentOptionsMenu\n{\n    // display third-party apps as well as actions, such as Copy, Print, Save Image, Quick Look\n    [_documentController presentOptionsMenuFromRect:self.view.bounds inView:self.view animated:YES];\n}\n{% endcodeblock %}\n然后我们运行程序，点击Button，就可以看到`Quick Look`操作已经显示出来啦！如下图：\n{% img /images/QuickLook.png %}\n\n如果我们点击这个`Quick Look`操作，就可以看到直接预览内容时所展示的界面啦。好啦，通过`UIDocumentInteractionController`实现`史蒂夫•乔布斯传`的预览和分享就到此结束啦。我会在下面的章节中，讲解通过其他技术实现`乔布斯自传`的分享和操作。","slug":"通过UIDocumentInteractionController预览和分享","published":1,"updated":"2016-04-12T07:06:29.000Z","comments":1,"photos":[],"link":"","_id":"cimx4v9va002o94su1xjdjyks","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>朋友分享推荐给我一本PDF格式的<code>史蒂夫•乔布斯传</code>，阅读了几篇，很受感触，于是想把他分享给大家欣赏阅读。早起闲来无事，正好就接着写篇文章来分享一下！我在“<a href=\"http://www.jianshu.com/p/88a08d66894f\" target=\"_blank\" rel=\"external\">iOS实现App之间的内容分享</a>”这篇文章中详细讲解了通过注册UTI的方式让我们的App支持分享，也简单地说了一下App内部怎么处理分享。同时，我也指出了在iOS系统跨App分享内容的几种常用技术，比如<code>URL Scheme</code>,<code>AirDrop</code>, <code>UIDocumentInteractionController</code>,<code>UIActivityViewController</code>这几种。这一篇文章，我们来谈一下最基础的原始方法，怎么通过使用<code>UIDocumentInteractionController</code>来预览、操作和分享<code>史蒂夫•乔布斯传</code>。<br><a id=\"more\"></a></p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>从iOS SDK的API文档中，我们可以找到<code>UIDocumentInteractionController</code>的声明:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NS_CLASS_AVAILABLE_IOS</span>(<span class=\"number\">3</span>_2) __TVOS_PROHIBITED <span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIDocumentInteractionController</span> : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">UIActionSheetDelegate</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>由此声明我们可以得知，<code>UIDocumentInteractionController</code>是从iOS 3.2的SDK开始支持的，它是直接继承的<code>NSObject</code>，而不是我们想象的<code>UIViewController</code>，因此我们需要使用<code>UIDocumentInteractionController</code>提供的方法来展示它，而且我们还可以看出它是不能在Apple TV 的开发中使用的。遍观<code>UIDocumentInteractionController</code>的属性和方法可以看出，<code>UIDocumentInteractionController</code>主要给我们提供了三种用途，我会在下面的内容中逐条的讲解<code>UIDocumentInteraction</code>的每一种用途的具体使用：</p>\n<ol>\n<li>展示一个可以操作我们分享的文档类型的第三方App列表</li>\n<li>在第一条展示列表的基础上添加额外的操作，比如<code>复制</code>，<code>打印</code>，<code>预览</code>，<code>保存</code>等。</li>\n<li>结合<code>Quick Look</code>框架直接展示文档内容</li>\n</ol>\n<h1 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h1><p>首先我创建了一个新的应用方便演示和截图，我把它命名为<code>ZSDocumentInteractionTest</code>，然后拖入PDF格式的<code>史蒂夫•乔布斯传</code>到<code>ZSDocumentInteractionTest</code>项目的bundle中。然后在<code>Storyboard</code>的<code>ViewController</code>中添加了一个Button作为<code>UIDocumentInteractionController</code>的触发操作(这些操作都比较简单，就不在这里用图展示啦)。运行程序，我们就可以看到Button啦，截图如下。然后我们就可以在Button的触发方法中，操作<code>UIDocumentInteractionController</code>来显示或者分享我们的<code>史蒂夫•乔布斯传</code>啦，具体的应用详情可以参考GitHub上的Demo：<a href=\"https://github.com/SeraZheng/ZSDocumentInteractionTest\" target=\"_blank\" rel=\"external\">ZSDocumentInteractionTest</a>。</p>\n<img src=\"/images/显示Button.png\">\n<h1 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h1><p>不管我们使用哪种<code>UIDocumentInteractionController</code>的展示方式和用途，都需要给<code>UIDocumentInteractionController</code>指定文档的URL，所以我们通常使用下面的初始化方式，给<code>UIDocumentInteractionController</code>指定<code>文件的URL</code>。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)presentPDFDocumentInteraction:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIDocumentInteractionController</span> *documentController = [<span class=\"built_in\">UIDocumentInteractionController</span> interactionControllerWithURL:[[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Steve\"</span> withExtension:<span class=\"string\">@\"pdf\"</span>]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"展示第三方App列表\"><a href=\"#展示第三方App列表\" class=\"headerlink\" title=\"展示第三方App列表\"></a>展示第三方App列表</h1><p>我们先实现<code>UIDocumentInteractionController</code>的第一个用途，展示可以操作PDF文件的第三方App列表。我们需要使用<code>UIDocumentInteractionController</code>提供的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentOpenInMenuFromRect:(<span class=\"built_in\">CGRect</span>)rect inView:(<span class=\"built_in\">UIView</span> *)view animated:(<span class=\"built_in\">BOOL</span>)animated;</span><br></pre></td></tr></table></figure></p>\n<p>我在Button的触发方法中添加下面的代码,意思就是让<code>UIDocumentInteractionController</code>的View在当前控制器视图上显示：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[documentController presentOpenInMenuFromRect:<span class=\"keyword\">self</span>.view.bounds inView:<span class=\"keyword\">self</span>.view animated:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure></p>\n<p>运行程序，点击Button，我们可以开始第一次展示测试啦。</p>\n<h1 id=\"第一次展示测试\"><a href=\"#第一次展示测试\" class=\"headerlink\" title=\"第一次展示测试\"></a>第一次展示测试</h1><p>一切准备就绪之后，我开始进行<code>UIDocumentInteractionController</code>的测试，点击Button，就可以看到下面的界面啦。这说明我们的第一步成功了!!(真棒)</p>\n<img src=\"/images/展示图标.png\">\n<p>简单介绍一下这个界面，这个视图中的第一行列表显示<code>AirDrop</code>，是苹果在<code>iOS 7</code>提供的一种跨设备分享的技术，我会在后边的文章中讲解。视图中的第二行列表就是整个iOS系统中，可以操作PDF文档的应用程序列表，还包括了苹果在<code>iOS 8</code>提供的<code>Share Extension</code>图标，关于<code>Share Extension</code>，我会在后边的文章中讲解。视图中的第三行列表，就是现实设备可选的操作，如<code>Copy</code>,<code>Print</code>中，这里什么操作都没有，并不是说没有可执行的操作，而是我们没有让他显示出来。</p>\n<p>接着我试着点击QQ图标，打算把<code>史蒂夫•乔布斯传</code>分享给我的好友，然而意外发生了，<code>ZSDocumentInteractionTest</code>崩溃掉啦，而且还给出我们一段错误提示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2015-12-30 19:00:40.078 ZSDocumentInteractionTest[1254:344240] *** Assertion failure <span class=\"keyword\">in</span> -[_UIOpenWithAppActivity performActivity], /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit/UIKit-3512.29.5/UIDocumentInteractionController.m:408</span><br><span class=\"line\">2015-12-30 19:00:40.079 ZSDocumentInteractionTest[1254:344240] *** Terminating app due to uncaught exception <span class=\"string\">'NSInternalInconsistencyException'</span>, reason: <span class=\"string\">'UIDocumentInteractionController has gone away prematurely!'</span></span><br><span class=\"line\">*** First throw call stack:</span><br><span class=\"line\">(0x248e185b 0x35fa2dff 0x248e1731 0x25672ddb 0x290638c9 0x292695bb 0x28d5aefd 0x28d5e1a1 0x28b42107 0x28a50a55 0x28a50531 0x28a5042b 0x282e05cf 0x1acd03 0x1b17c9 0x248a4535 0x248a2a2f 0x247f50d9 0x247f4ecd 0x2db6aaf9 0x28a7e2dd 0x780ad 0x366f0873)</span><br><span class=\"line\">libc++abi.dylib: terminating with uncaught exception of <span class=\"built_in\">type</span> NSException</span><br></pre></td></tr></table></figure></p>\n<p>我看到错误提示竟然指向了<code>UIDocumentInteractionController.m</code>文件，而且错误提示是<code>NSInternalInconsistencyException</code>(内部不一致)和”UIDocumentInteractionController has gone away prematurely!”(UIDocumentInteractionController过早地被释放掉啦)。由此我想出这个应该是内存过早释放的一个错误，然后我查阅了一下Apple Developer上的文档，原来，在ARC环境下展示<code>UIDocumentInteractionController</code>时，当我的函数方法调用完毕，退栈之后，<code>UIDocumentInteractionController</code>的实例就被释放掉了，展示出来的这个View由<code>Quick Look</code>框架来操作，并不会对<code>UIDocumentInteractionController</code>产生引用。当点击View上面的Button时，内部操作仍然会继续访问这个<code>UIDocumentInteractionController</code>实例，就会报出上述错误。</p>\n<p>错误原因找到了，那么解决原理也就清楚了，只要不让<code>UIDocumentInteractionController</code>实例过早释放就可以啦。我们可以将<code>UIDocumentInteractionController</code>声明为一个<code>strong</code>类型的实例属性，然后修改一下Button触发方法就可以啦。(仍然不理解的朋友可以去GitHub上下载Demo测试)<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIDocumentInteractionController</span> *documentController;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>我在Button的触发方法中添加下面方法的调用,为了方便区分和理解，我把代码封装成了私有实例方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)presentOpenInMenu</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// display third-party apps</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.documentController presentOpenInMenuFromRect:<span class=\"keyword\">self</span>.view.bounds inView:<span class=\"keyword\">self</span>.view animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)presentPGNDocumentInteraction:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    _documentController = [<span class=\"built_in\">UIDocumentInteractionController</span> interactionControllerWithURL:[[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Steve\"</span> withExtension:<span class=\"string\">@\"pdf\"</span>]];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> presentOpenInMenu];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改完之后，运行程序，然后点击Button，看到第一次测试时展示出来的图片啦。然后再点QQ图标，就可以正确地跳转到QQ程序中，选择好友就可以分享<code>史蒂夫•乔布斯传</code>啦。（QQ接收分享页面就不展示了，想试验的可以手动测试下)</p>\n<h1 id=\"展示可选操作\"><a href=\"#展示可选操作\" class=\"headerlink\" title=\"展示可选操作\"></a>展示可选操作</h1><p>我们可以看到第一步图示里面只有App图标，第二行操作列表中只有一个<code>More</code>。所以我们来展示<code>UIDocumentInteractionController</code>的第二种用途，在第一步的基础之上，显示附加的操作选项，。这需要我们使用<code>UIDocumentInteractionController</code>提供的另外一种展示方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentOptionsMenuFromRect:(<span class=\"built_in\">CGRect</span>)rect inView:(<span class=\"built_in\">UIView</span> *)view animated:(<span class=\"built_in\">BOOL</span>)animated;</span><br></pre></td></tr></table></figure><br>我们在Button的触发方法中添加下面方法的调用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)presentOptionsMenu</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// display third-party apps as well as actions, such as Copy, Print, Save Image, Quick Look</span></span><br><span class=\"line\">    [_documentController presentOptionsMenuFromRect:<span class=\"keyword\">self</span>.view.bounds inView:<span class=\"keyword\">self</span>.view animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>运行程序，点击Button,我们可以看到下面的界面，多了<code>Copy</code>和<code>Print</code>的操作。<code>Copy</code>操作可以将文件拷贝到系统粘贴板中，而<code>Print</code>操作则是关联打印机进行打印操作的。（在这里我就不展示这俩种操作的具体界面啦！）</p>\n<img src=\"/images/附加操作.png\">\n<p>如果<code>UIDocumentInteractionController</code>关联的是一个图片文件，这个界面还会提供一个<code>Save Image</code>的操作，用来直接保存图片到系统的<code>Photos</code>中，此外这个界面还提供了一个<code>Quick Look</code>操作，可以让我们直接预览<code>乔布斯自传</code>PDF文档，只不过需要我们再多写点代码，为了文章的合理性和结构性，我决定在下面的标题内容中讲解。(先卖个小关子！！)</p>\n<h1 id=\"直接预览\"><a href=\"#直接预览\" class=\"headerlink\" title=\"直接预览\"></a>直接预览</h1><p><code>UIDocumentInteractionController</code>第三种预览文档内容的用途非常重要，而且也是常见的。我会详细地说一下如何通过<code>UIDocumentInteractionController</code>实现预览<code>史蒂夫•乔布斯传</code>。首先你需要为<code>UIDocumentInteractionController</code>指定一个delegate，并且实现下面的代理方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *)documentInteractionControllerViewControllerForPreview:(<span class=\"built_in\">UIDocumentInteractionController</span> *)controller;</span><br></pre></td></tr></table></figure></p>\n<p>这个代理方法主要是用来指定<code>UIDocumentInteractionController</code>要显示的视图所在的父视图容器。这样<code>UIDocumentInteractionController</code>才清楚在哪里展示<code>Quick Look</code>预览内容， 我在这里就指定Button所在的UIViewController来做<code>UIDocumentInteractionController</code>的代理对象，并且实现上面的代理方法。在Button的触发方法中添加下面的代码</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_documentController.delegate = <span class=\"keyword\">self</span>;</span><br></pre></td></tr></table></figure>\n<p>然后实现代理方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *)documentInteractionControllerViewControllerForPreview:(<span class=\"built_in\">UIDocumentInteractionController</span> *)controller</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>UIDocumentInteractionController</code>是继承自<code>NSObject</code>的，因而为了能够实现直接预览，我们需要用到<code>UIDocumentInteractionController</code>提供的展示预览的方法，<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentPreviewAnimated:(<span class=\"built_in\">BOOL</span>)animated;</span><br></pre></td></tr></table></figure><br>这个方法是以模态窗口通过Quick Look框架全屏显示PDF的内容，所以我们在Button的触发方法中添加下面方法的调用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)presentPreview</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// display PDF contents by Quick Look framework</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.documentController presentPreviewAnimated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后运行程序，点击Button，弹出了一个新视图，可以看到<code>史蒂夫•乔布斯传</code>的内容，如下图<br><img src=\"/images/直接预览.png\"></p>\n<h1 id=\"展示预览操作\"><a href=\"#展示预览操作\" class=\"headerlink\" title=\"展示预览操作\"></a>展示预览操作</h1><p>通过上面的操作我们就可以欣赏阅读我们想看的<code>史蒂夫•乔布斯传</code>啦，不过别忘记我们上面还卖了一个小关子，就是在展示可选操的时候，除了<code>Copy</code>，<code>Print</code>，其实我们还可以展示<code>Quick Look</code>这个预览操作。为什么我要卖关子呢，因为我是一个相信因果循环的人，我组织文章的逻辑是由浅入深，我设想通过一步步铺垫来展开<code>UIDocumentInteractionController</code>所有特性。</p>\n<p>好啦，回归正题！我们想要实现显示<code>Quick Look</code>预览操作，其大部分的工作在<code>直接预览</code>这一小节中都做完了，比如指定代理对象，然后实现这个代理方法来指定<code>UIDocumentInteractionController</code>的父视图容器：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *)documentInteractionControllerViewControllerForPreview:(<span class=\"built_in\">UIDocumentInteractionController</span> *)controller;</span><br></pre></td></tr></table></figure>\n<p>由于我们已经做完了所有准备，在这一步，我们只需要将直接展示<code>史蒂夫•乔布斯传</code>内容的方法替换为下面这段，展示<code>可选操作列表</code>的方法,就可以啦！<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)presentOptionsMenu</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// display third-party apps as well as actions, such as Copy, Print, Save Image, Quick Look</span></span><br><span class=\"line\">    [_documentController presentOptionsMenuFromRect:<span class=\"keyword\">self</span>.view.bounds inView:<span class=\"keyword\">self</span>.view animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后我们运行程序，点击Button，就可以看到<code>Quick Look</code>操作已经显示出来啦！如下图：<br><img src=\"/images/QuickLook.png\"></p>\n<p>如果我们点击这个<code>Quick Look</code>操作，就可以看到直接预览内容时所展示的界面啦。好啦，通过<code>UIDocumentInteractionController</code>实现<code>史蒂夫•乔布斯传</code>的预览和分享就到此结束啦。我会在下面的章节中，讲解通过其他技术实现<code>乔布斯自传</code>的分享和操作。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>朋友分享推荐给我一本PDF格式的<code>史蒂夫•乔布斯传</code>，阅读了几篇，很受感触，于是想把他分享给大家欣赏阅读。早起闲来无事，正好就接着写篇文章来分享一下！我在“<a href=\"http://www.jianshu.com/p/88a08d66894f\">iOS实现App之间的内容分享</a>”这篇文章中详细讲解了通过注册UTI的方式让我们的App支持分享，也简单地说了一下App内部怎么处理分享。同时，我也指出了在iOS系统跨App分享内容的几种常用技术，比如<code>URL Scheme</code>,<code>AirDrop</code>, <code>UIDocumentInteractionController</code>,<code>UIActivityViewController</code>这几种。这一篇文章，我们来谈一下最基础的原始方法，怎么通过使用<code>UIDocumentInteractionController</code>来预览、操作和分享<code>史蒂夫•乔布斯传</code>。<br>","more":"</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>从iOS SDK的API文档中，我们可以找到<code>UIDocumentInteractionController</code>的声明:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NS_CLASS_AVAILABLE_IOS</span>(<span class=\"number\">3</span>_2) __TVOS_PROHIBITED <span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIDocumentInteractionController</span> : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">UIActionSheetDelegate</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>由此声明我们可以得知，<code>UIDocumentInteractionController</code>是从iOS 3.2的SDK开始支持的，它是直接继承的<code>NSObject</code>，而不是我们想象的<code>UIViewController</code>，因此我们需要使用<code>UIDocumentInteractionController</code>提供的方法来展示它，而且我们还可以看出它是不能在Apple TV 的开发中使用的。遍观<code>UIDocumentInteractionController</code>的属性和方法可以看出，<code>UIDocumentInteractionController</code>主要给我们提供了三种用途，我会在下面的内容中逐条的讲解<code>UIDocumentInteraction</code>的每一种用途的具体使用：</p>\n<ol>\n<li>展示一个可以操作我们分享的文档类型的第三方App列表</li>\n<li>在第一条展示列表的基础上添加额外的操作，比如<code>复制</code>，<code>打印</code>，<code>预览</code>，<code>保存</code>等。</li>\n<li>结合<code>Quick Look</code>框架直接展示文档内容</li>\n</ol>\n<h1 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h1><p>首先我创建了一个新的应用方便演示和截图，我把它命名为<code>ZSDocumentInteractionTest</code>，然后拖入PDF格式的<code>史蒂夫•乔布斯传</code>到<code>ZSDocumentInteractionTest</code>项目的bundle中。然后在<code>Storyboard</code>的<code>ViewController</code>中添加了一个Button作为<code>UIDocumentInteractionController</code>的触发操作(这些操作都比较简单，就不在这里用图展示啦)。运行程序，我们就可以看到Button啦，截图如下。然后我们就可以在Button的触发方法中，操作<code>UIDocumentInteractionController</code>来显示或者分享我们的<code>史蒂夫•乔布斯传</code>啦，具体的应用详情可以参考GitHub上的Demo：<a href=\"https://github.com/SeraZheng/ZSDocumentInteractionTest\">ZSDocumentInteractionTest</a>。</p>\n<img src=\"/images/显示Button.png\">\n<h1 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h1><p>不管我们使用哪种<code>UIDocumentInteractionController</code>的展示方式和用途，都需要给<code>UIDocumentInteractionController</code>指定文档的URL，所以我们通常使用下面的初始化方式，给<code>UIDocumentInteractionController</code>指定<code>文件的URL</code>。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)presentPDFDocumentInteraction:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIDocumentInteractionController</span> *documentController = [<span class=\"built_in\">UIDocumentInteractionController</span> interactionControllerWithURL:[[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Steve\"</span> withExtension:<span class=\"string\">@\"pdf\"</span>]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"展示第三方App列表\"><a href=\"#展示第三方App列表\" class=\"headerlink\" title=\"展示第三方App列表\"></a>展示第三方App列表</h1><p>我们先实现<code>UIDocumentInteractionController</code>的第一个用途，展示可以操作PDF文件的第三方App列表。我们需要使用<code>UIDocumentInteractionController</code>提供的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentOpenInMenuFromRect:(<span class=\"built_in\">CGRect</span>)rect inView:(<span class=\"built_in\">UIView</span> *)view animated:(<span class=\"built_in\">BOOL</span>)animated;</span><br></pre></td></tr></table></figure></p>\n<p>我在Button的触发方法中添加下面的代码,意思就是让<code>UIDocumentInteractionController</code>的View在当前控制器视图上显示：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[documentController presentOpenInMenuFromRect:<span class=\"keyword\">self</span>.view.bounds inView:<span class=\"keyword\">self</span>.view animated:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure></p>\n<p>运行程序，点击Button，我们可以开始第一次展示测试啦。</p>\n<h1 id=\"第一次展示测试\"><a href=\"#第一次展示测试\" class=\"headerlink\" title=\"第一次展示测试\"></a>第一次展示测试</h1><p>一切准备就绪之后，我开始进行<code>UIDocumentInteractionController</code>的测试，点击Button，就可以看到下面的界面啦。这说明我们的第一步成功了!!(真棒)</p>\n<img src=\"/images/展示图标.png\">\n<p>简单介绍一下这个界面，这个视图中的第一行列表显示<code>AirDrop</code>，是苹果在<code>iOS 7</code>提供的一种跨设备分享的技术，我会在后边的文章中讲解。视图中的第二行列表就是整个iOS系统中，可以操作PDF文档的应用程序列表，还包括了苹果在<code>iOS 8</code>提供的<code>Share Extension</code>图标，关于<code>Share Extension</code>，我会在后边的文章中讲解。视图中的第三行列表，就是现实设备可选的操作，如<code>Copy</code>,<code>Print</code>中，这里什么操作都没有，并不是说没有可执行的操作，而是我们没有让他显示出来。</p>\n<p>接着我试着点击QQ图标，打算把<code>史蒂夫•乔布斯传</code>分享给我的好友，然而意外发生了，<code>ZSDocumentInteractionTest</code>崩溃掉啦，而且还给出我们一段错误提示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2015-12-30 19:00:40.078 ZSDocumentInteractionTest[1254:344240] *** Assertion failure <span class=\"keyword\">in</span> -[_UIOpenWithAppActivity performActivity], /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit/UIKit-3512.29.5/UIDocumentInteractionController.m:408</span><br><span class=\"line\">2015-12-30 19:00:40.079 ZSDocumentInteractionTest[1254:344240] *** Terminating app due to uncaught exception <span class=\"string\">'NSInternalInconsistencyException'</span>, reason: <span class=\"string\">'UIDocumentInteractionController has gone away prematurely!'</span></span><br><span class=\"line\">*** First throw call stack:</span><br><span class=\"line\">(0x248e185b 0x35fa2dff 0x248e1731 0x25672ddb 0x290638c9 0x292695bb 0x28d5aefd 0x28d5e1a1 0x28b42107 0x28a50a55 0x28a50531 0x28a5042b 0x282e05cf 0x1acd03 0x1b17c9 0x248a4535 0x248a2a2f 0x247f50d9 0x247f4ecd 0x2db6aaf9 0x28a7e2dd 0x780ad 0x366f0873)</span><br><span class=\"line\">libc++abi.dylib: terminating with uncaught exception of <span class=\"built_in\">type</span> NSException</span><br></pre></td></tr></table></figure></p>\n<p>我看到错误提示竟然指向了<code>UIDocumentInteractionController.m</code>文件，而且错误提示是<code>NSInternalInconsistencyException</code>(内部不一致)和”UIDocumentInteractionController has gone away prematurely!”(UIDocumentInteractionController过早地被释放掉啦)。由此我想出这个应该是内存过早释放的一个错误，然后我查阅了一下Apple Developer上的文档，原来，在ARC环境下展示<code>UIDocumentInteractionController</code>时，当我的函数方法调用完毕，退栈之后，<code>UIDocumentInteractionController</code>的实例就被释放掉了，展示出来的这个View由<code>Quick Look</code>框架来操作，并不会对<code>UIDocumentInteractionController</code>产生引用。当点击View上面的Button时，内部操作仍然会继续访问这个<code>UIDocumentInteractionController</code>实例，就会报出上述错误。</p>\n<p>错误原因找到了，那么解决原理也就清楚了，只要不让<code>UIDocumentInteractionController</code>实例过早释放就可以啦。我们可以将<code>UIDocumentInteractionController</code>声明为一个<code>strong</code>类型的实例属性，然后修改一下Button触发方法就可以啦。(仍然不理解的朋友可以去GitHub上下载Demo测试)<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIDocumentInteractionController</span> *documentController;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>我在Button的触发方法中添加下面方法的调用,为了方便区分和理解，我把代码封装成了私有实例方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)presentOpenInMenu</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// display third-party apps</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.documentController presentOpenInMenuFromRect:<span class=\"keyword\">self</span>.view.bounds inView:<span class=\"keyword\">self</span>.view animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)presentPGNDocumentInteraction:(<span class=\"keyword\">id</span>)sender &#123;</span><br><span class=\"line\">    _documentController = [<span class=\"built_in\">UIDocumentInteractionController</span> interactionControllerWithURL:[[<span class=\"built_in\">NSBundle</span> mainBundle] URLForResource:<span class=\"string\">@\"Steve\"</span> withExtension:<span class=\"string\">@\"pdf\"</span>]];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> presentOpenInMenu];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改完之后，运行程序，然后点击Button，看到第一次测试时展示出来的图片啦。然后再点QQ图标，就可以正确地跳转到QQ程序中，选择好友就可以分享<code>史蒂夫•乔布斯传</code>啦。（QQ接收分享页面就不展示了，想试验的可以手动测试下)</p>\n<h1 id=\"展示可选操作\"><a href=\"#展示可选操作\" class=\"headerlink\" title=\"展示可选操作\"></a>展示可选操作</h1><p>我们可以看到第一步图示里面只有App图标，第二行操作列表中只有一个<code>More</code>。所以我们来展示<code>UIDocumentInteractionController</code>的第二种用途，在第一步的基础之上，显示附加的操作选项，。这需要我们使用<code>UIDocumentInteractionController</code>提供的另外一种展示方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentOptionsMenuFromRect:(<span class=\"built_in\">CGRect</span>)rect inView:(<span class=\"built_in\">UIView</span> *)view animated:(<span class=\"built_in\">BOOL</span>)animated;</span><br></pre></td></tr></table></figure><br>我们在Button的触发方法中添加下面方法的调用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)presentOptionsMenu</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// display third-party apps as well as actions, such as Copy, Print, Save Image, Quick Look</span></span><br><span class=\"line\">    [_documentController presentOptionsMenuFromRect:<span class=\"keyword\">self</span>.view.bounds inView:<span class=\"keyword\">self</span>.view animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>运行程序，点击Button,我们可以看到下面的界面，多了<code>Copy</code>和<code>Print</code>的操作。<code>Copy</code>操作可以将文件拷贝到系统粘贴板中，而<code>Print</code>操作则是关联打印机进行打印操作的。（在这里我就不展示这俩种操作的具体界面啦！）</p>\n<img src=\"/images/附加操作.png\">\n<p>如果<code>UIDocumentInteractionController</code>关联的是一个图片文件，这个界面还会提供一个<code>Save Image</code>的操作，用来直接保存图片到系统的<code>Photos</code>中，此外这个界面还提供了一个<code>Quick Look</code>操作，可以让我们直接预览<code>乔布斯自传</code>PDF文档，只不过需要我们再多写点代码，为了文章的合理性和结构性，我决定在下面的标题内容中讲解。(先卖个小关子！！)</p>\n<h1 id=\"直接预览\"><a href=\"#直接预览\" class=\"headerlink\" title=\"直接预览\"></a>直接预览</h1><p><code>UIDocumentInteractionController</code>第三种预览文档内容的用途非常重要，而且也是常见的。我会详细地说一下如何通过<code>UIDocumentInteractionController</code>实现预览<code>史蒂夫•乔布斯传</code>。首先你需要为<code>UIDocumentInteractionController</code>指定一个delegate，并且实现下面的代理方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *)documentInteractionControllerViewControllerForPreview:(<span class=\"built_in\">UIDocumentInteractionController</span> *)controller;</span><br></pre></td></tr></table></figure></p>\n<p>这个代理方法主要是用来指定<code>UIDocumentInteractionController</code>要显示的视图所在的父视图容器。这样<code>UIDocumentInteractionController</code>才清楚在哪里展示<code>Quick Look</code>预览内容， 我在这里就指定Button所在的UIViewController来做<code>UIDocumentInteractionController</code>的代理对象，并且实现上面的代理方法。在Button的触发方法中添加下面的代码</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_documentController.delegate = <span class=\"keyword\">self</span>;</span><br></pre></td></tr></table></figure>\n<p>然后实现代理方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *)documentInteractionControllerViewControllerForPreview:(<span class=\"built_in\">UIDocumentInteractionController</span> *)controller</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>UIDocumentInteractionController</code>是继承自<code>NSObject</code>的，因而为了能够实现直接预览，我们需要用到<code>UIDocumentInteractionController</code>提供的展示预览的方法，<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)presentPreviewAnimated:(<span class=\"built_in\">BOOL</span>)animated;</span><br></pre></td></tr></table></figure><br>这个方法是以模态窗口通过Quick Look框架全屏显示PDF的内容，所以我们在Button的触发方法中添加下面方法的调用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)presentPreview</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// display PDF contents by Quick Look framework</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.documentController presentPreviewAnimated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后运行程序，点击Button，弹出了一个新视图，可以看到<code>史蒂夫•乔布斯传</code>的内容，如下图<br><img src=\"/images/直接预览.png\"></p>\n<h1 id=\"展示预览操作\"><a href=\"#展示预览操作\" class=\"headerlink\" title=\"展示预览操作\"></a>展示预览操作</h1><p>通过上面的操作我们就可以欣赏阅读我们想看的<code>史蒂夫•乔布斯传</code>啦，不过别忘记我们上面还卖了一个小关子，就是在展示可选操的时候，除了<code>Copy</code>，<code>Print</code>，其实我们还可以展示<code>Quick Look</code>这个预览操作。为什么我要卖关子呢，因为我是一个相信因果循环的人，我组织文章的逻辑是由浅入深，我设想通过一步步铺垫来展开<code>UIDocumentInteractionController</code>所有特性。</p>\n<p>好啦，回归正题！我们想要实现显示<code>Quick Look</code>预览操作，其大部分的工作在<code>直接预览</code>这一小节中都做完了，比如指定代理对象，然后实现这个代理方法来指定<code>UIDocumentInteractionController</code>的父视图容器：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *)documentInteractionControllerViewControllerForPreview:(<span class=\"built_in\">UIDocumentInteractionController</span> *)controller;</span><br></pre></td></tr></table></figure>\n<p>由于我们已经做完了所有准备，在这一步，我们只需要将直接展示<code>史蒂夫•乔布斯传</code>内容的方法替换为下面这段，展示<code>可选操作列表</code>的方法,就可以啦！<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)presentOptionsMenu</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// display third-party apps as well as actions, such as Copy, Print, Save Image, Quick Look</span></span><br><span class=\"line\">    [_documentController presentOptionsMenuFromRect:<span class=\"keyword\">self</span>.view.bounds inView:<span class=\"keyword\">self</span>.view animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后我们运行程序，点击Button，就可以看到<code>Quick Look</code>操作已经显示出来啦！如下图：<br><img src=\"/images/QuickLook.png\"></p>\n<p>如果我们点击这个<code>Quick Look</code>操作，就可以看到直接预览内容时所展示的界面啦。好啦，通过<code>UIDocumentInteractionController</code>实现<code>史蒂夫•乔布斯传</code>的预览和分享就到此结束啦。我会在下面的章节中，讲解通过其他技术实现<code>乔布斯自传</code>的分享和操作。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cimx4v9su000094sul0moaoma","category_id":"cimx4v9t6000594sujm1bfnkx","_id":"cimx4v9tg000e94suqctv5le6"},{"post_id":"cimx4v9te000d94suhlknby6x","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9tn000l94suiiq0c69x"},{"post_id":"cimx4v9t0000294su80oi2pcj","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9tp000p94suyfyzhjoq"},{"post_id":"cimx4v9tg000f94suzd843xgq","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9tq000s94sug6jc9yga"},{"post_id":"cimx4v9tl000j94su8qd6fesq","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9ts000w94suceb2urmg"},{"post_id":"cimx4v9t7000694suoh1j33pg","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9tt000z94sua473nz8m"},{"post_id":"cimx4v9tp000r94su6d4loa3w","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9tx001394supmuckbnp"},{"post_id":"cimx4v9t8000894suzklrssc8","category_id":"cimx4v9tp000o94sucat6lqc7","_id":"cimx4v9tz001694sufs11mi6e"},{"post_id":"cimx4v9ta000a94sudzqu3zuk","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9u1001994sur0qxw2in"},{"post_id":"cimx4v9tn000m94su9f0sem98","category_id":"cimx4v9tw001294suo0550dey","_id":"cimx4v9u6001e94sue186t15j"},{"post_id":"cimx4v9u1001b94supdh36pr4","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9u8001j94su383949eg"},{"post_id":"cimx4v9u3001d94suvzp9it26","category_id":"cimx4v9tp000o94sucat6lqc7","_id":"cimx4v9u9001m94suvpiajzky"},{"post_id":"cimx4v9tr000t94suvivjfitx","category_id":"cimx4v9u1001a94sur2973wcq","_id":"cimx4v9ud001r94sukm0fs99n"},{"post_id":"cimx4v9u6001g94sugqjpot4f","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9ui001u94sus5zwqd9k"},{"post_id":"cimx4v9u8001k94su3kkjk7nx","category_id":"cimx4v9t6000594sujm1bfnkx","_id":"cimx4v9un001z94suuupx6o5w"},{"post_id":"cimx4v9ts000x94suc8oex3gm","category_id":"cimx4v9u1001a94sur2973wcq","_id":"cimx4v9uo002294sumjfjobdo"},{"post_id":"cimx4v9ud001s94suebr38nie","category_id":"cimx4v9tp000o94sucat6lqc7","_id":"cimx4v9ur002694sub782sjuz"},{"post_id":"cimx4v9tt001094suftl82n1b","category_id":"cimx4v9u1001a94sur2973wcq","_id":"cimx4v9ut002994sui271k7y5"},{"post_id":"cimx4v9ui001v94suby4bz21l","category_id":"cimx4v9tw001294suo0550dey","_id":"cimx4v9uy002d94su5pypilpo"},{"post_id":"cimx4v9un002094su8scct0kh","category_id":"cimx4v9tw001294suo0550dey","_id":"cimx4v9v1002g94suf9vmvotz"},{"post_id":"cimx4v9ty001494suxpm90srh","category_id":"cimx4v9u1001a94sur2973wcq","_id":"cimx4v9v4002k94susiptotl1"},{"post_id":"cimx4v9uo002394sugei85ckm","category_id":"cimx4v9tw001294suo0550dey","_id":"cimx4v9v9002n94su51hqwa6c"},{"post_id":"cimx4v9us002794suigydzqdv","category_id":"cimx4v9tw001294suo0550dey","_id":"cimx4v9ve002r94sux7rjh4ln"},{"post_id":"cimx4v9tz001794such8cpfcv","category_id":"cimx4v9u1001a94sur2973wcq","_id":"cimx4v9ve002t94suku8g6arb"},{"post_id":"cimx4v9uy002e94suugchanxc","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9ve002v94sum6lp9zjz"},{"post_id":"cimx4v9ua001o94sul5iwcc9h","category_id":"cimx4v9uv002b94su0lixfwrz","_id":"cimx4v9ve002x94subk7e514d"},{"post_id":"cimx4v9v1002h94sua54bphxj","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9vf002z94suhzqfcs5p"},{"post_id":"cimx4v9v4002l94sulw02qhcr","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9vf003194sudnzznb4x"},{"post_id":"cimx4v9ut002a94su5n5nf5fs","category_id":"cimx4v9uv002b94su0lixfwrz","_id":"cimx4v9vf003294su3lxsouap"},{"post_id":"cimx4v9va002o94su1xjdjyks","category_id":"cimx4v9tc000b94suatfjm3ye","_id":"cimx4v9vf003594su7kin5rn9"}],"PostTag":[{"post_id":"cimx4v9su000094sul0moaoma","tag_id":"cimx4v9t4000494suybj9w0ck","_id":"cimx4v9te000c94su83v8lsr5"},{"post_id":"cimx4v9te000d94suhlknby6x","tag_id":"cimx4v9t9000994suq2eyaq67","_id":"cimx4v9tk000i94sulrdzo5x0"},{"post_id":"cimx4v9t0000294su80oi2pcj","tag_id":"cimx4v9t9000994suq2eyaq67","_id":"cimx4v9tn000k94su64ema9nb"},{"post_id":"cimx4v9t7000694suoh1j33pg","tag_id":"cimx4v9t9000994suq2eyaq67","_id":"cimx4v9tp000q94suaj5bno0s"},{"post_id":"cimx4v9t8000894suzklrssc8","tag_id":"cimx4v9to000n94su6l41r2sk","_id":"cimx4v9tt000y94sujztrh2gf"},{"post_id":"cimx4v9ta000a94sudzqu3zuk","tag_id":"cimx4v9t9000994suq2eyaq67","_id":"cimx4v9tz001594su9y0ypefk"},{"post_id":"cimx4v9tg000f94suzd843xgq","tag_id":"cimx4v9tv001194su1wv2z29t","_id":"cimx4v9u3001c94su7m3r5pkq"},{"post_id":"cimx4v9tl000j94su8qd6fesq","tag_id":"cimx4v9tv001194su1wv2z29t","_id":"cimx4v9u8001i94suu96mojwo"},{"post_id":"cimx4v9u3001d94suvzp9it26","tag_id":"cimx4v9to000n94su6l41r2sk","_id":"cimx4v9u9001l94su6zyd4qxs"},{"post_id":"cimx4v9u6001g94sugqjpot4f","tag_id":"cimx4v9tv001194su1wv2z29t","_id":"cimx4v9uc001q94su858mkrte"},{"post_id":"cimx4v9u8001k94su3kkjk7nx","tag_id":"cimx4v9t4000494suybj9w0ck","_id":"cimx4v9ui001t94suqi3xl3oe"},{"post_id":"cimx4v9tn000m94su9f0sem98","tag_id":"cimx4v9u6001f94su9eiunngq","_id":"cimx4v9un001y94suqcz42va9"},{"post_id":"cimx4v9tp000r94su6d4loa3w","tag_id":"cimx4v9ua001n94suvxjrn6hi","_id":"cimx4v9uo002194suyu1jfbn9"},{"post_id":"cimx4v9tr000t94suvivjfitx","tag_id":"cimx4v9um001x94su0803br0e","_id":"cimx4v9us002894su5qy03464"},{"post_id":"cimx4v9ts000x94suc8oex3gm","tag_id":"cimx4v9um001x94su0803br0e","_id":"cimx4v9v0002f94suc10a0quj"},{"post_id":"cimx4v9tt001094suftl82n1b","tag_id":"cimx4v9um001x94su0803br0e","_id":"cimx4v9v9002m94su8duzklyh"},{"post_id":"cimx4v9v4002l94sulw02qhcr","tag_id":"cimx4v9tv001194su1wv2z29t","_id":"cimx4v9vd002q94suh4j751x6"},{"post_id":"cimx4v9ty001494suxpm90srh","tag_id":"cimx4v9um001x94su0803br0e","_id":"cimx4v9ve002s94sudb3zd5l0"},{"post_id":"cimx4v9tz001794such8cpfcv","tag_id":"cimx4v9um001x94su0803br0e","_id":"cimx4v9ve002w94su1wlj6fbz"},{"post_id":"cimx4v9u1001b94supdh36pr4","tag_id":"cimx4v9ve002u94sun02jz8sn","_id":"cimx4v9vf003094sut6yv4vx1"},{"post_id":"cimx4v9ua001o94sul5iwcc9h","tag_id":"cimx4v9ve002y94sulm3er1n9","_id":"cimx4v9vf003494suc1ve8503"},{"post_id":"cimx4v9ud001s94suebr38nie","tag_id":"cimx4v9vf003394subl3bns9g","_id":"cimx4v9vf003794suczv6rkk1"},{"post_id":"cimx4v9ui001v94suby4bz21l","tag_id":"cimx4v9vf003694surx219gni","_id":"cimx4v9vg003994sum4y14o5m"},{"post_id":"cimx4v9un002094su8scct0kh","tag_id":"cimx4v9vg003894sug0ggua41","_id":"cimx4v9vg003b94su6qd913jt"},{"post_id":"cimx4v9uo002394sugei85ckm","tag_id":"cimx4v9vg003a94suhaeirdmw","_id":"cimx4v9vh003d94su8n7xmkqu"},{"post_id":"cimx4v9us002794suigydzqdv","tag_id":"cimx4v9vh003c94sua79sgmx6","_id":"cimx4v9vi003f94suv8x3vxah"},{"post_id":"cimx4v9ut002a94su5n5nf5fs","tag_id":"cimx4v9ve002y94sulm3er1n9","_id":"cimx4v9vi003h94suflmdfv37"},{"post_id":"cimx4v9uy002e94suugchanxc","tag_id":"cimx4v9ve002u94sun02jz8sn","_id":"cimx4v9vi003j94su9ho1c40c"},{"post_id":"cimx4v9v1002h94sua54bphxj","tag_id":"cimx4v9ve002u94sun02jz8sn","_id":"cimx4v9vj003l94suqalg3spa"},{"post_id":"cimx4v9va002o94su1xjdjyks","tag_id":"cimx4v9ve002u94sun02jz8sn","_id":"cimx4v9vj003m94susw2d7b62"}],"Tag":[{"name":"设计","_id":"cimx4v9t4000494suybj9w0ck"},{"name":"APNS","_id":"cimx4v9t9000994suq2eyaq67"},{"name":"OC基础","_id":"cimx4v9to000n94su6l41r2sk"},{"name":"UIKit","_id":"cimx4v9tv001194su1wv2z29t"},{"name":"架构","_id":"cimx4v9u6001f94su9eiunngq"},{"name":"CoreAnimation","_id":"cimx4v9ua001n94suvxjrn6hi"},{"name":"多线程","_id":"cimx4v9um001x94su0803br0e"},{"name":"UTI","_id":"cimx4v9ve002u94sun02jz8sn"},{"name":"注释","_id":"cimx4v9ve002y94sulm3er1n9"},{"name":"内存管理","_id":"cimx4v9vf003394subl3bns9g"},{"name":"TestFlight","_id":"cimx4v9vf003694surx219gni"},{"name":"年度总结","_id":"cimx4v9vg003894sug0ggua41"},{"name":"开篇博客","_id":"cimx4v9vg003a94suhaeirdmw"},{"name":"GitHub开源","_id":"cimx4v9vh003c94sua79sgmx6"}]}}